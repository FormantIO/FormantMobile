var sn = Object.defineProperty;
var ln = (e, t, n) => t in e ? sn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var be = (e, t, n) => (ln(e, typeof t != "symbol" ? t + "" : t, n), n);
const DEFAULT_FORMANT_API_URL = "https://api.formant.io";
function whichFormantApiUrl(e, t) {
  try {
    if (t.get("formant_stage"))
      return "https://api-stage.formant.io";
    if (t.get("formant_dev"))
      return "https://api-dev.formant.io";
    if (t.get("formant_local"))
      return "https://api.formant.local";
    if (t.get("formant_url")) {
      const n = t.get("formant_url");
      if (n !== null)
        try {
          return new URL(n).origin;
        } catch {
          console.warn(
            `Ignoring malformed \`formant_url\` url parameter: ${n}`
          );
        }
    }
  } catch {
  }
  return typeof e < "u" && "FORMANT_API_URL" in e && typeof e.FORMANT_API_URL == "string" ? e.FORMANT_API_URL : DEFAULT_FORMANT_API_URL;
}
const FORMANT_API_URL = whichFormantApiUrl(
  typeof window < "u" ? window : globalThis,
  new URLSearchParams(
    typeof window < "u" && window.location ? window.location.search : void 0
  )
);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var base64 = { exports: {} };
/*! https://mths.be/base64 v1.0.0 by @mathias | MIT license */
base64.exports;
(function(e, t) {
  (function(n) {
    var r = t, o = e && e.exports == r && e, l = typeof commonjsGlobal == "object" && commonjsGlobal;
    (l.global === l || l.window === l) && (n = l);
    var u = function(f) {
      this.message = f;
    };
    u.prototype = new Error(), u.prototype.name = "InvalidCharacterError";
    var s = function(f) {
      throw new u(f);
    }, g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = /[\t\n\f\r ]/g, d = function(f) {
      f = String(f).replace(c, "");
      var v = f.length;
      v % 4 == 0 && (f = f.replace(/==?$/, ""), v = f.length), (v % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
      /[^+a-zA-Z0-9/]/.test(f)) && s(
        "Invalid character: the string to be decoded is not correctly encoded."
      );
      for (var E = 0, j, B, I = "", R = -1; ++R < v; )
        B = g.indexOf(f.charAt(R)), j = E % 4 ? j * 64 + B : B, E++ % 4 && (I += String.fromCharCode(
          255 & j >> (-2 * E & 6)
        ));
      return I;
    }, T = function(f) {
      f = String(f), /[^\0-\xFF]/.test(f) && s(
        "The string to be encoded contains characters outside of the Latin1 range."
      );
      for (var v = f.length % 3, E = "", j = -1, B, I, R, p, M = f.length - v; ++j < M; )
        B = f.charCodeAt(j) << 16, I = f.charCodeAt(++j) << 8, R = f.charCodeAt(++j), p = B + I + R, E += g.charAt(p >> 18 & 63) + g.charAt(p >> 12 & 63) + g.charAt(p >> 6 & 63) + g.charAt(p & 63);
      return v == 2 ? (B = f.charCodeAt(j) << 8, I = f.charCodeAt(++j), p = B + I, E += g.charAt(p >> 10) + g.charAt(p >> 4 & 63) + g.charAt(p << 2 & 63) + "=") : v == 1 && (p = f.charCodeAt(j), E += g.charAt(p >> 2) + g.charAt(p << 4 & 63) + "=="), E;
    }, b = {
      encode: T,
      decode: d,
      version: "1.0.0"
    };
    if (r && !r.nodeType)
      if (o)
        o.exports = b;
      else
        for (var h in b)
          b.hasOwnProperty(h) && (r[h] = b[h]);
    else
      n.base64 = b;
  })(commonjsGlobal);
})(base64, base64.exports);
var base64Exports = base64.exports;
class AuthenticationStore {
  constructor({
    apiUrl: t,
    refreshAuthToken: n,
    addAccessTokenRefreshListener: r
  }) {
    be(this, "_refreshToken");
    be(this, "_isShareToken", !1);
    be(this, "_currentOrganization");
    be(this, "_currentUser");
    be(this, "_defaultDeviceId");
    be(this, "_token");
    be(this, "_waitingForAuth", /* @__PURE__ */ new Set());
    be(this, "_refreshTimer");
    be(this, "_apiUrl");
    be(this, "_refreshAuthToken");
    be(this, "_addAccessTokenRefreshListener");
    this._apiUrl = t, this._refreshAuthToken = n, this._addAccessTokenRefreshListener = r;
  }
  get token() {
    return this._token;
  }
  get currentUser() {
    return this._currentUser;
  }
  get currentOrganization() {
    return this._currentOrganization;
  }
  get defaultDeviceId() {
    return this._defaultDeviceId;
  }
  /**
   * @deprecated Do not use directly. This will be removed in future versions of the API
   */
  get refreshToken() {
    return this._refreshToken;
  }
  /**
   * @deprecated Do not use directly. This will be removed in future versions of the API
   */
  get isShareToken() {
    return this._isShareToken;
  }
  async login(t, n) {
    try {
      const r = await fetch(`${this._apiUrl}/v1/admin/auth/login`, {
        method: "POST",
        body: JSON.stringify({ email: t, password: n }),
        headers: {
          "Content-Type": "application/json"
        }
      }), o = await r.json();
      if (r.status !== 200)
        throw new Error(o.message);
      return await this.loginWithToken(
        o.authentication.accessToken,
        o.authentication.refreshToken
      ), o.authentication;
    } catch (r) {
      return console.error("login() failed", { err: r }), this._waitingForAuth.forEach((o) => o(!1)), this._waitingForAuth.clear(), Promise.reject(r);
    }
  }
  async loginWithToken(t, n) {
    var o;
    const r = JSON.parse(base64Exports.decode(t.split(".")[1]));
    try {
      let l;
      if (this._isShareToken = r["formant:claims"] && r["formant:claims"].type == "share", r["formant:claims"] && (this._currentOrganization = r["formant:claims"].organizationId), r["custom:organization_id"] && (this._currentOrganization = r["custom:organization_id"]), this._isShareToken || (l = r.sub), r["formant:claims"] && r["formant:claims"].userId && (l = r["formant:claims"].userId), l && ((o = this._currentUser) == null ? void 0 : o.id) !== l) {
        const u = await fetch(`${this._apiUrl}/v1/admin/users/${l}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + t
          }
        }), s = await u.json();
        if (u.status !== 200)
          throw new Error(s.message);
        this._currentUser = s;
      }
      this._token = t, this._waitingForAuth.forEach((u) => u(!0));
    } catch (l) {
      console.error("loginWithToken() failed", { err: l }), this._waitingForAuth.forEach((u) => u(!1));
    } finally {
      this._waitingForAuth.clear();
    }
    n && (this._refreshToken = n, setInterval(async () => {
      if (this._refreshToken) {
        const u = await (await fetch(`${this._apiUrl}/v1/admin/auth/refresh`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            refreshToken: this._refreshToken
          })
        })).json();
        this._token = u.authentication.accessToken;
      }
    }, 1e3 * 60 * 60));
  }
  isAuthenticated() {
    return this._token !== void 0;
  }
  /**
   * @deprecated use currentUser property instead.
   */
  getCurrentUser() {
    return this._currentUser;
  }
  async waitTilAuthenticated() {
    return this.token !== void 0 ? !0 : new Promise((t) => {
      this._waitingForAuth.add(t);
    });
  }
  async listenForRefresh() {
    const n = () => {
      this._refreshTimer = void 0, this._refreshAuthToken();
    };
    this._addAccessTokenRefreshListener((r) => {
      this._refreshTimer && clearTimeout(this._refreshTimer), this._refreshTimer = setTimeout(n, 36e5), this.loginWithToken(r);
    }), this._refreshTimer = setTimeout(n, 36e5);
  }
  async forgotPassword(t) {
    await fetch(`${this._apiUrl}/v1/admin/auth/forgot-password`, {
      method: "POST",
      body: JSON.stringify({ email: t }),
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
  /**
   * @example
   * // Body
   * await this.confirmForgotPassword({
   *     email: "joe@gmail.com"
   *     confirmationCode: "1",
   *     newPassword: "NewPassword"
   *   });
   */
  async confirmForgotPassword(t) {
    return (await fetch(
      `${this._apiUrl}/v1/admin/auth/confirm-forgot-password`,
      {
        method: "POST",
        body: JSON.stringify(t),
        headers: {
          "Content-Type": "application/json"
        }
      }
    )).ok;
  }
  async respondToNewPasswordRequiredChallenge(t) {
    return await (await fetch(
      `${this._apiUrl}/v1/admin/auth/respond-to-new-password-required-challenge`,
      {
        method: "POST",
        body: JSON.stringify(t),
        headers: {
          "Content-Type": "application/json"
        }
      }
    )).json();
  }
  async loginWithGoogle(t) {
    return await (await fetch(`${this._apiUrl}/v1/admin/auth/login-google`, {
      method: "POST",
      body: JSON.stringify(t),
      headers: {
        "Content-Type": "application/json"
      }
    })).json();
  }
  async refresh(t) {
    const r = await (await fetch(`${this._apiUrl}/v1/admin/auth/refresh`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        refreshToken: t
      })
    })).json();
    await this.loginWithToken(r.authentication.accessToken, t);
  }
}
function getCurrentModuleContext() {
  return typeof window < "u" && window.location ? new URLSearchParams(window.location.search).get("module") : null;
}
function sendAppMessage(e) {
  if (!(window && window.parent))
    throw new Error("cannot send message to non-existent parent");
  window.parent.postMessage(e, "*");
}
function refreshAuthToken() {
  const e = getCurrentModuleContext();
  if (!e)
    throw new Error("No module context");
  sendAppMessage({
    type: "refresh_auth_token",
    module: e
  });
}
function addAccessTokenRefreshListener(e) {
  function t(n) {
    const r = n.data;
    r.type === "auth_token" && e(r.token);
  }
  return window.addEventListener("message", t), () => {
    window.removeEventListener("message", t);
  };
}
const Authentication = new AuthenticationStore({
  apiUrl: FORMANT_API_URL,
  refreshAuthToken,
  addAccessTokenRefreshListener
});
async function getModuleConfiguration(e) {
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/admin/module-configurations/${e}`,
    {
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).configuration;
}
function disableAnalyticsBottomBar() {
  sendAppMessage({
    type: "hide_analytics_date_picker"
  });
}
function goToDevice(e) {
  sendAppMessage({
    type: "go_to_device",
    deviceId: e
  });
}
function goToTime(e) {
  sendAppMessage({
    type: "go_to_time",
    time: e.getTime()
  });
}
function requestModuleData() {
  const e = getCurrentModuleContext();
  if (!e)
    throw new Error("No module context");
  sendAppMessage({
    type: "request_module_data",
    module: e
  });
}
function sendChannelData(e, t) {
  const n = getCurrentModuleContext();
  if (!n)
    throw new Error("No module context");
  sendAppMessage({
    type: "send_channel_data",
    source: n,
    channel: e,
    data: t
  });
}
function setModuleDateTimeRange(e, t) {
  const n = getCurrentModuleContext();
  if (!n)
    throw new Error("No module context");
  sendAppMessage({
    type: "set_module_data_time_range",
    module: n,
    before: e,
    after: t || 0
  });
}
function setupModuleMenus(e) {
  const t = getCurrentModuleContext();
  if (!t)
    throw new Error("No module context");
  sendAppMessage({
    type: "setup_module_menus",
    module: t,
    menus: e
  });
}
function showMessage(e) {
  sendAppMessage({ type: "show_message", message: e });
}
function addChannelDataListener(e, t) {
  const n = (r) => {
    const o = r.data;
    o.type === "channel_data" && o.channel === e && t({
      source: o.source,
      data: o.data
    });
  };
  return window.addEventListener("message", n), () => window.removeEventListener("message", n);
}
function addMenuListener(e) {
  const t = (n) => {
    const r = n.data;
    r.type === "module_menu_item_clicked" && e(r.menu);
  };
  return window.addEventListener("message", t), () => window.removeEventListener("message", t);
}
function addModuleConfigurationListener(e) {
  const t = (n) => {
    const r = n.data;
    r.type === "module_configuration" && e(r);
  };
  return window.addEventListener("message", t), () => window.removeEventListener("message", t);
}
function addModuleDataListener(e) {
  const t = getCurrentModuleContext();
  t && sendAppMessage({ type: "request_module_data", module: t });
  const n = (r) => {
    const o = r.data;
    o.type === "module_data" && e({
      streams: o.streams,
      time: o.time,
      queryRange: o.queryRange
    });
  };
  return window.addEventListener("message", n), () => window.removeEventListener("message", n);
}
function addOverviewDeviceListener(e) {
  sendAppMessage({ type: "request_devices" });
  const t = (n) => {
    const r = n.data;
    r.type === "overview_devices" && e(r.data);
  };
  return window.addEventListener("message", t), () => window.removeEventListener("message", t);
}
function _typeof(e) {
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _typeof(e);
}
function toInteger(e) {
  if (e === null || e === !0 || e === !1)
    return NaN;
  var t = Number(e);
  return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t);
}
function requiredArgs(e, t) {
  if (t.length < e)
    throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present");
}
function toDate(e) {
  requiredArgs(1, arguments);
  var t = Object.prototype.toString.call(e);
  return e instanceof Date || _typeof(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function addDays(e, t) {
  requiredArgs(2, arguments);
  var n = toDate(e), r = toInteger(t);
  return isNaN(r) ? /* @__PURE__ */ new Date(NaN) : (r && n.setDate(n.getDate() + r), n);
}
function addMonths(e, t) {
  requiredArgs(2, arguments);
  var n = toDate(e), r = toInteger(t);
  if (isNaN(r))
    return /* @__PURE__ */ new Date(NaN);
  if (!r)
    return n;
  var o = n.getDate(), l = new Date(n.getTime());
  l.setMonth(n.getMonth() + r + 1, 0);
  var u = l.getDate();
  return o >= u ? l : (n.setFullYear(l.getFullYear(), l.getMonth(), o), n);
}
function addMilliseconds(e, t) {
  requiredArgs(2, arguments);
  var n = toDate(e).getTime(), r = toInteger(t);
  return new Date(n + r);
}
var MILLISECONDS_IN_HOUR = 36e5;
function addHours(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMilliseconds(e, n * MILLISECONDS_IN_HOUR);
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(e, t) {
  var n, r, o, l, u, s, g, c;
  requiredArgs(1, arguments);
  var d = getDefaultOptions(), T = toInteger((n = (r = (o = (l = t == null ? void 0 : t.weekStartsOn) !== null && l !== void 0 ? l : t == null || (u = t.locale) === null || u === void 0 || (s = u.options) === null || s === void 0 ? void 0 : s.weekStartsOn) !== null && o !== void 0 ? o : d.weekStartsOn) !== null && r !== void 0 ? r : (g = d.locale) === null || g === void 0 || (c = g.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(T >= 0 && T <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var b = toDate(e), h = b.getDay(), f = (h < T ? 7 : 0) + h - T;
  return b.setDate(b.getDate() - f), b.setHours(0, 0, 0, 0), b;
}
function startOfDay(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setHours(0, 0, 0, 0), t;
}
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMilliseconds(e, n * MILLISECONDS_IN_MINUTE);
}
function addQuarters(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t), r = n * 3;
  return addMonths(e, r);
}
function addSeconds(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMilliseconds(e, n * 1e3);
}
function addWeeks(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t), r = n * 7;
  return addDays(e, r);
}
function addYears(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMonths(e, n * 12);
}
function getQuarter(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = Math.floor(t.getMonth() / 3) + 1;
  return n;
}
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(t) {
    return t < 0 ? Math.ceil(t) : Math.floor(t);
  }
  // Math.trunc is not supported by IE
}, defaultRoundingMethod = "trunc";
function getRoundingMethod(e) {
  return e ? roundingMap[e] : roundingMap[defaultRoundingMethod];
}
function endOfDay(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setHours(23, 59, 59, 999), t;
}
function endOfMonth(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getMonth();
  return t.setFullYear(t.getFullYear(), n + 1, 0), t.setHours(23, 59, 59, 999), t;
}
function eachDayOfInterval(e, t) {
  var n;
  requiredArgs(1, arguments);
  var r = e || {}, o = toDate(r.start), l = toDate(r.end), u = l.getTime();
  if (!(o.getTime() <= u))
    throw new RangeError("Invalid interval");
  var s = [], g = o;
  g.setHours(0, 0, 0, 0);
  var c = Number((n = t == null ? void 0 : t.step) !== null && n !== void 0 ? n : 1);
  if (c < 1 || isNaN(c))
    throw new RangeError("`options.step` must be a number greater than 1");
  for (; g.getTime() <= u; )
    s.push(toDate(g)), g.setDate(g.getDate() + c), g.setHours(0, 0, 0, 0);
  return s;
}
function eachHourOfInterval(e, t) {
  var n;
  requiredArgs(1, arguments);
  var r = e || {}, o = toDate(r.start), l = toDate(r.end), u = o.getTime(), s = l.getTime();
  if (!(u <= s))
    throw new RangeError("Invalid interval");
  var g = [], c = o;
  c.setMinutes(0, 0, 0);
  var d = Number((n = t == null ? void 0 : t.step) !== null && n !== void 0 ? n : 1);
  if (d < 1 || isNaN(d))
    throw new RangeError("`options.step` must be a number greater than 1");
  for (; c.getTime() <= s; )
    g.push(toDate(c)), c = addHours(c, d);
  return g;
}
function startOfMinute(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setSeconds(0, 0), t;
}
function eachMinuteOfInterval(e, t) {
  var n;
  requiredArgs(1, arguments);
  var r = startOfMinute(toDate(e.start)), o = toDate(e.end), l = r.getTime(), u = o.getTime();
  if (l >= u)
    throw new RangeError("Invalid interval");
  var s = [], g = r, c = Number((n = t == null ? void 0 : t.step) !== null && n !== void 0 ? n : 1);
  if (c < 1 || isNaN(c))
    throw new RangeError("`options.step` must be a number equal to or greater than 1");
  for (; g.getTime() <= u; )
    s.push(toDate(g)), g = addMinutes(g, c);
  return s;
}
function eachMonthOfInterval(e) {
  requiredArgs(1, arguments);
  var t = e || {}, n = toDate(t.start), r = toDate(t.end), o = r.getTime(), l = [];
  if (!(n.getTime() <= o))
    throw new RangeError("Invalid interval");
  var u = n;
  for (u.setHours(0, 0, 0, 0), u.setDate(1); u.getTime() <= o; )
    l.push(toDate(u)), u.setMonth(u.getMonth() + 1);
  return l;
}
function startOfQuarter(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getMonth(), r = n - n % 3;
  return t.setMonth(r, 1), t.setHours(0, 0, 0, 0), t;
}
function eachQuarterOfInterval(e) {
  requiredArgs(1, arguments);
  var t = e || {}, n = toDate(t.start), r = toDate(t.end), o = r.getTime();
  if (!(n.getTime() <= o))
    throw new RangeError("Invalid interval");
  var l = startOfQuarter(n), u = startOfQuarter(r);
  o = u.getTime();
  for (var s = [], g = l; g.getTime() <= o; )
    s.push(toDate(g)), g = addQuarters(g, 1);
  return s;
}
function eachWeekOfInterval(e, t) {
  requiredArgs(1, arguments);
  var n = e || {}, r = toDate(n.start), o = toDate(n.end), l = o.getTime();
  if (!(r.getTime() <= l))
    throw new RangeError("Invalid interval");
  var u = startOfWeek(r, t), s = startOfWeek(o, t);
  u.setHours(15), s.setHours(15), l = s.getTime();
  for (var g = [], c = u; c.getTime() <= l; )
    c.setHours(0), g.push(toDate(c)), c = addWeeks(c, 1), c.setHours(15);
  return g;
}
function startOfMonth(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t;
}
function endOfYear(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getFullYear();
  return t.setFullYear(n + 1, 0, 0), t.setHours(23, 59, 59, 999), t;
}
function startOfYear(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(t.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function eachYearOfInterval(e) {
  requiredArgs(1, arguments);
  var t = e || {}, n = toDate(t.start), r = toDate(t.end), o = r.getTime();
  if (!(n.getTime() <= o))
    throw new RangeError("Invalid interval");
  var l = [], u = n;
  for (u.setHours(0, 0, 0, 0), u.setMonth(0, 1); u.getTime() <= o; )
    l.push(toDate(u)), u.setFullYear(u.getFullYear() + 1);
  return l;
}
function endOfHour(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setMinutes(59, 59, 999), t;
}
function endOfWeek(e, t) {
  var n, r, o, l, u, s, g, c;
  requiredArgs(1, arguments);
  var d = getDefaultOptions(), T = toInteger((n = (r = (o = (l = t == null ? void 0 : t.weekStartsOn) !== null && l !== void 0 ? l : t == null || (u = t.locale) === null || u === void 0 || (s = u.options) === null || s === void 0 ? void 0 : s.weekStartsOn) !== null && o !== void 0 ? o : d.weekStartsOn) !== null && r !== void 0 ? r : (g = d.locale) === null || g === void 0 || (c = g.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
  if (!(T >= 0 && T <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var b = toDate(e), h = b.getDay(), f = (h < T ? -7 : 0) + 6 - (h - T);
  return b.setDate(b.getDate() + f), b.setHours(23, 59, 59, 999), b;
}
function endOfMinute(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setSeconds(59, 999), t;
}
function endOfQuarter(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getMonth(), r = n - n % 3 + 3;
  return t.setMonth(r, 0), t.setHours(23, 59, 59, 999), t;
}
function getDay(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getDay();
  return n;
}
function getHours(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getHours();
  return n;
}
function getMinutes(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getMinutes();
  return n;
}
function getMonth(e) {
  requiredArgs(1, arguments);
  var t = toDate(e), n = t.getMonth();
  return n;
}
function getWeekYear(e, t) {
  var n, r, o, l, u, s, g, c;
  requiredArgs(1, arguments);
  var d = toDate(e), T = d.getFullYear(), b = getDefaultOptions(), h = toInteger((n = (r = (o = (l = t == null ? void 0 : t.firstWeekContainsDate) !== null && l !== void 0 ? l : t == null || (u = t.locale) === null || u === void 0 || (s = u.options) === null || s === void 0 ? void 0 : s.firstWeekContainsDate) !== null && o !== void 0 ? o : b.firstWeekContainsDate) !== null && r !== void 0 ? r : (g = b.locale) === null || g === void 0 || (c = g.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1);
  if (!(h >= 1 && h <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var f = /* @__PURE__ */ new Date(0);
  f.setFullYear(T + 1, 0, h), f.setHours(0, 0, 0, 0);
  var v = startOfWeek(f, t), E = /* @__PURE__ */ new Date(0);
  E.setFullYear(T, 0, h), E.setHours(0, 0, 0, 0);
  var j = startOfWeek(E, t);
  return d.getTime() >= v.getTime() ? T + 1 : d.getTime() >= j.getTime() ? T : T - 1;
}
function startOfWeekYear(e, t) {
  var n, r, o, l, u, s, g, c;
  requiredArgs(1, arguments);
  var d = getDefaultOptions(), T = toInteger((n = (r = (o = (l = t == null ? void 0 : t.firstWeekContainsDate) !== null && l !== void 0 ? l : t == null || (u = t.locale) === null || u === void 0 || (s = u.options) === null || s === void 0 ? void 0 : s.firstWeekContainsDate) !== null && o !== void 0 ? o : d.firstWeekContainsDate) !== null && r !== void 0 ? r : (g = d.locale) === null || g === void 0 || (c = g.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && n !== void 0 ? n : 1), b = getWeekYear(e, t), h = /* @__PURE__ */ new Date(0);
  h.setFullYear(b, 0, T), h.setHours(0, 0, 0, 0);
  var f = startOfWeek(h, t);
  return f;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getWeek(e, t) {
  requiredArgs(1, arguments);
  var n = toDate(e), r = startOfWeek(n, t).getTime() - startOfWeekYear(n, t).getTime();
  return Math.round(r / MILLISECONDS_IN_WEEK) + 1;
}
function getYear(e) {
  return requiredArgs(1, arguments), toDate(e).getFullYear();
}
function startOfHour(e) {
  requiredArgs(1, arguments);
  var t = toDate(e);
  return t.setMinutes(0, 0, 0), t;
}
function subDays(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addDays(e, -n);
}
function roundToNearestMinutes(e, t) {
  var n;
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only none provided present");
  var r = toInteger((n = t == null ? void 0 : t.nearestTo) !== null && n !== void 0 ? n : 1);
  if (r < 1 || r > 30)
    throw new RangeError("`options.nearestTo` must be between 1 and 30");
  var o = toDate(e), l = o.getSeconds(), u = o.getMinutes() + l / 60, s = getRoundingMethod(t == null ? void 0 : t.roundingMethod), g = s(u / r) * r, c = u % r, d = Math.round(c / r) * r;
  return new Date(o.getFullYear(), o.getMonth(), o.getDate(), o.getHours(), g + d);
}
function subMonths(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMonths(e, -n);
}
function subHours(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addHours(e, -n);
}
function subMinutes(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addMinutes(e, -n);
}
function subQuarters(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addQuarters(e, -n);
}
function subWeeks(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addWeeks(e, -n);
}
function subYears(e, t) {
  requiredArgs(2, arguments);
  var n = toInteger(t);
  return addYears(e, -n);
}
const millisecond = 1, second = 1e3, minute = 60 * second, hour = 60 * minute, day = 24 * hour, week = 7 * day, month = 30 * day, year = 365 * day, duration = {
  millisecond,
  second,
  minute,
  hour,
  day,
  week,
  month,
  year
};
function filterDataByType(e, t) {
  return e.filter((n) => t.includes(n.type));
}
function filterDataByTime(e, t, n) {
  const r = t.getTime(), o = n.getTime();
  return e.map((l) => ({
    ...l,
    points: l.points.filter(
      ([u]) => u >= r && u < o
    )
  })).filter(({ points: l }) => l.length > 0);
}
function fork(e) {
}
class StoreCache {
  constructor({
    capacity: t,
    timeout: n
  } = {}) {
    be(this, "entries", /* @__PURE__ */ new Map());
    be(this, "metadata", /* @__PURE__ */ new Map());
    be(this, "capacity");
    be(this, "timeout");
    this.capacity = t || 1e4, this.timeout = n || duration.minute;
  }
  get(t, n) {
    const r = this.keyToCacheKey(t), o = this.entries.get(r), l = this.metadata.get(r);
    return (o === void 0 || l && (l == null ? void 0 : l.expiration.getTime()) < Date.now()) && !(l != null && l.generating) && n && this.generate(t, n()), o === void 0 && l && l.lastValue !== void 0 ? l.lastValue : o;
  }
  set(t, n) {
    const r = this.keyToCacheKey(t);
    this.metadata.set(r, {
      generating: !1,
      expiration: new Date(Date.now() + this.timeout),
      lastValue: n
    }), this.entries.set(r, n), this.metadata.size > this.capacity && this.deleteOldestEntry();
  }
  clear() {
    this.entries.clear(), [...this.metadata.values()].forEach((t) => t.generating = !1);
  }
  clearKey(t) {
    this.metadata.delete(t), this.entries.delete(t);
  }
  keyToCacheKey(t) {
    return JSON.stringify(t);
  }
  deleteOldestEntry() {
    if (this.metadata.size < 1)
      return;
    const [t] = [...this.metadata.entries()].reduce(
      ([n, r], [o, l]) => l.expiration.getTime() < r.expiration.getTime() ? [o, l] : [n, r]
    );
    this.clearKey(t);
  }
  generate(t, n) {
    const r = this.keyToCacheKey(t), o = this.metadata.get(r) || {};
    this.metadata.set(r, {
      ...o,
      generating: !0,
      expiration: new Date(Date.now() + this.timeout)
    }), setTimeout(() => {
      n.then((l) => {
        const u = this.metadata.get(r);
        !(u != null && u.generating) || this.set(t, l);
      });
    }, 0);
  }
}
async function queryTelemetry(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/queries/queries`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
class QueryStore {
  constructor() {
    be(this, "queryStoreCache", new StoreCache({
      capacity: 1e4,
      timeout: 20 * duration.second
    }));
    be(this, "liveQueryStoreCache", new StoreCache({
      capacity: 1e4,
      timeout: 200 * duration.millisecond
    }));
  }
  moduleQuery(t, n, r, o, l, u = !1) {
    const s = {
      ...t,
      names: [...n],
      types: [...r]
    }, g = this.query(s, o, l, u);
    return g === void 0 || g === "too much data" ? g : filterDataByType(g, r);
  }
  query(t, n, r, o = !1) {
    const l = {
      ...t,
      start: startOfMinute(n).toISOString(),
      end: o ? r.toISOString() : addMinutes(roundToNearestMinutes(r), 1).toISOString(),
      latestOnly: o
    }, u = r > addSeconds(/* @__PURE__ */ new Date(), -20);
    let s;
    return u ? s = this.liveQueryCache(l) : s = this.queryCache(l), !s || s === "too much data" || o ? s : filterDataByTime(s, n, r);
  }
  queryCache(t) {
    return this.queryStoreCache.get(t, async () => {
      try {
        return await queryTelemetry(t);
      } catch (n) {
        throw n;
      }
    });
  }
  liveQueryCache(t) {
    return this.liveQueryStoreCache.get(t, async () => {
      try {
        return await queryTelemetry(t);
      } catch (n) {
        throw n;
      }
    });
  }
}
const queryStore = new QueryStore();
function addStreamListener(e, t, n) {
  const r = (o) => {
    const l = o.data;
    if (l.type === "module_data") {
      const { start: u, end: s } = l.queryRange;
      n(
        queryStore.moduleQuery(
          {},
          e,
          t,
          new Date(u),
          new Date(s),
          !1
        )
      );
    }
  };
  return window.addEventListener("message", r), () => window.removeEventListener("message", r);
}
async function getDate(e, t, n) {
  return new Promise((r) => {
    sendAppMessage({
      type: "request_date",
      minTime: t,
      maxTime: n,
      time: e
    });
    const o = (l) => {
      const u = l.data;
      u.type === "date_response" && (window.removeEventListener("message", o), r(u.data));
    };
    window.addEventListener("message", o);
  });
}
async function prompt(e, t) {
  return new Promise((n) => {
    const r = Math.random().toString();
    sendAppMessage({
      type: "prompt",
      promptId: r,
      schema: e,
      okText: t == null ? void 0 : t.okText,
      cancelText: t == null ? void 0 : t.cancelText
    });
    const o = (l) => {
      const u = l.data;
      u.type === "prompt_response" && u.promptId === r && n(u.data), window.removeEventListener("message", o);
    };
    window.addEventListener("message", o);
  });
}
const kt = class {
  static isModule() {
    return getCurrentModuleContext() !== null;
  }
  static async getCurrentModuleConfiguration() {
    let t = new URLSearchParams("");
    typeof window < "u" && window.location && (t = new URLSearchParams(window.location.search));
    const n = t.get("configuration");
    if (!(n === null || n.trim() === ""))
      return getModuleConfiguration(n.trim());
  }
  static get isOnline() {
    return kt._isOnline;
  }
  static listenForConnectionEvents() {
    const t = (n) => {
      const { data: r } = n;
      r.type === "formant_online" && (this._isOnline = r.online);
    };
    return window.addEventListener("message", t), () => window.removeEventListener("message", t);
  }
  static checkConnection(t = 1e3) {
    return new Promise((n, r) => {
      const o = setTimeout(
        () => r(new Error("deadline expired: took too long")),
        t
      ), l = (u) => {
        window.removeEventListener("message", l), clearTimeout(o);
        const { data: s } = u;
        s.type === "formant_online" && (this._isOnline = s.online, n(s.online));
      };
      window.addEventListener("message", l), sendAppMessage({ type: "formant_online" });
    });
  }
  static waitForConnection(t = 5e3) {
    let n = !1;
    const r = new Promise((u, s) => {
      setTimeout(() => {
        n = !0, s(new Error("deadline expired: took too long"));
      }, t);
    }), o = (u) => new Promise((s) => setTimeout(s, u)), l = async () => {
      for (await o(50); !n && !(this.isOnline || await this.checkConnection); )
        await o(500);
    };
    return Promise.race([r, l()]);
  }
};
let App = kt;
be(App, "getCurrentModuleContext", getCurrentModuleContext), // senders
be(App, "disableAnalyticsBottomBar", disableAnalyticsBottomBar), be(App, "goToDevice", goToDevice), be(App, "goToTime", goToTime), be(App, "refreshAuthToken", refreshAuthToken), be(App, "requestModuleData", requestModuleData), be(App, "sendChannelData", sendChannelData), be(App, "setModuleDateTimeRange", setModuleDateTimeRange), be(App, "setupModuleMenus", setupModuleMenus), be(App, "showMessage", showMessage), // listeners
be(App, "addAccessTokenRefreshListener", addAccessTokenRefreshListener), be(App, "addChannelDataListener", addChannelDataListener), be(App, "addMenuListener", addMenuListener), be(App, "addModuleConfigurationListener", addModuleConfigurationListener), be(App, "addModuleDataListener", addModuleDataListener), be(App, "addOverviewDeviceListener", addOverviewDeviceListener), be(App, "addStreamListener", addStreamListener), // bidirectional
be(App, "getDate", getDate), be(App, "prompt", prompt), be(App, "_isOnline", null);
function defined(e, t) {
  if (e !== void 0)
    return e;
  throw new Error(t || "Value is undefined");
}
var dist = { exports: {} };
/*! For license information please see index.js.LICENSE.txt */
(function(module, exports) {
  (function(e, t) {
    module.exports = t();
  })(window, function() {
    return function(e) {
      function t(c) {
        for (var d, T, b = c[0], h = c[1], f = 0, v = []; f < b.length; f++)
          T = b[f], Object.prototype.hasOwnProperty.call(r, T) && r[T] && v.push(r[T][0]), r[T] = 0;
        for (d in h)
          Object.prototype.hasOwnProperty.call(h, d) && (e[d] = h[d]);
        for (g && g(c); v.length; )
          v.shift()();
      }
      var n = {}, r = { 0: 0 };
      function o(c) {
        if (n[c])
          return n[c].exports;
        var d = n[c] = { i: c, l: !1, exports: {} };
        return e[c].call(d.exports, d, d.exports, o), d.l = !0, d.exports;
      }
      o.e = function() {
        return Promise.resolve();
      }, o.m = e, o.c = n, o.d = function(c, d, T) {
        o.o(c, d) || Object.defineProperty(c, d, { enumerable: !0, get: T });
      }, o.r = function(c) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(c, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(c, "__esModule", { value: !0 });
      }, o.t = function(c, d) {
        if (1 & d && (c = o(c)), 8 & d || 4 & d && typeof c == "object" && c && c.__esModule)
          return c;
        var T = /* @__PURE__ */ Object.create(null);
        if (o.r(T), Object.defineProperty(T, "default", { enumerable: !0, value: c }), 2 & d && typeof c != "string")
          for (var b in c)
            o.d(T, b, function(h) {
              return c[h];
            }.bind(null, b));
        return T;
      }, o.n = function(c) {
        var d = c && c.__esModule ? function() {
          return c.default;
        } : function() {
          return c;
        };
        return o.d(d, "a", d), d;
      }, o.o = function(c, d) {
        return Object.prototype.hasOwnProperty.call(c, d);
      }, o.p = "", o.oe = function(c) {
        throw console.error(c), c;
      };
      var l = window.webpackJsonpFormantRealtimeSDK = window.webpackJsonpFormantRealtimeSDK || [], u = l.push.bind(l);
      l.push = t, l = l.slice();
      for (var s = 0; s < l.length; s++)
        t(l[s]);
      var g = u;
      return o(o.s = 228);
    }([function(e, t, n) {
      n.d(t, "a", function() {
        return G;
      });
      function r(A, U) {
        if (U.length < A)
          throw new TypeError(A + " argument" + (A > 1 ? "s" : "") + " required, but only " + U.length + " present");
      }
      function o(A) {
        if (A === null || A === !0 || A === !1)
          return NaN;
        var U = Number(A);
        return isNaN(U) ? U : U < 0 ? Math.ceil(U) : Math.floor(U);
      }
      var l = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ }, u = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, s = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, g = /^([+-])(\d{2})(?::?(\d{2}))?$/;
      function c(A) {
        var U, J = {}, K = A.split(l.dateTimeDelimiter);
        if (K.length > 2)
          return J;
        if (/:/.test(K[0]) ? U = K[0] : (J.date = K[0], U = K[1], l.timeZoneDelimiter.test(J.date) && (J.date = A.split(l.timeZoneDelimiter)[0], U = A.substr(J.date.length, A.length))), U) {
          var re = l.timezone.exec(U);
          re ? (J.time = U.replace(re[1], ""), J.timezone = re[1]) : J.time = U;
        }
        return J;
      }
      function d(A, U) {
        var J = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + U) + "})|(\\d{2}|[+-]\\d{" + (2 + U) + "})$)"), K = A.match(J);
        if (!K)
          return { year: NaN, restDateString: "" };
        var re = K[1] ? parseInt(K[1]) : null, se = K[2] ? parseInt(K[2]) : null;
        return { year: se === null ? re : 100 * se, restDateString: A.slice((K[1] || K[2]).length) };
      }
      function T(A, U) {
        if (U === null)
          return /* @__PURE__ */ new Date(NaN);
        var J = A.match(u);
        if (!J)
          return /* @__PURE__ */ new Date(NaN);
        var K = !!J[4], re = b(J[1]), se = b(J[2]) - 1, fe = b(J[3]), we = b(J[4]), Ie = b(J[5]) - 1;
        if (K)
          return function(Ce, Ae, Oe) {
            return Ae >= 1 && Ae <= 53 && Oe >= 0 && Oe <= 6;
          }(0, we, Ie) ? function(Ce, Ae, Oe) {
            var Pe = /* @__PURE__ */ new Date(0);
            Pe.setUTCFullYear(Ce, 0, 4);
            var qe = Pe.getUTCDay() || 7, et = 7 * (Ae - 1) + Oe + 1 - qe;
            return Pe.setUTCDate(Pe.getUTCDate() + et), Pe;
          }(U, we, Ie) : /* @__PURE__ */ new Date(NaN);
        var Ee = /* @__PURE__ */ new Date(0);
        return function(Ce, Ae, Oe) {
          return Ae >= 0 && Ae <= 11 && Oe >= 1 && Oe <= (E[Ae] || (j(Ce) ? 29 : 28));
        }(U, se, fe) && function(Ce, Ae) {
          return Ae >= 1 && Ae <= (j(Ce) ? 366 : 365);
        }(U, re) ? (Ee.setUTCFullYear(U, se, Math.max(re, fe)), Ee) : /* @__PURE__ */ new Date(NaN);
      }
      function b(A) {
        return A ? parseInt(A) : 1;
      }
      function h(A) {
        var U = A.match(s);
        if (!U)
          return NaN;
        var J = f(U[1]), K = f(U[2]), re = f(U[3]);
        return function(se, fe, we) {
          return se === 24 ? fe === 0 && we === 0 : we >= 0 && we < 60 && fe >= 0 && fe < 60 && se >= 0 && se < 25;
        }(J, K, re) ? 36e5 * J + 6e4 * K + 1e3 * re : NaN;
      }
      function f(A) {
        return A && parseFloat(A.replace(",", ".")) || 0;
      }
      function v(A) {
        if (A === "Z")
          return 0;
        var U = A.match(g);
        if (!U)
          return 0;
        var J = U[1] === "+" ? -1 : 1, K = parseInt(U[2]), re = U[3] && parseInt(U[3]) || 0;
        return function(se, fe) {
          return fe >= 0 && fe <= 59;
        }(0, re) ? J * (36e5 * K + 6e4 * re) : NaN;
      }
      var E = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function j(A) {
        return A % 400 == 0 || A % 4 == 0 && A % 100 != 0;
      }
      function B(A) {
        return r(1, arguments), A instanceof Date || typeof A == "object" && Object.prototype.toString.call(A) === "[object Date]";
      }
      function I(A) {
        r(1, arguments);
        var U = Object.prototype.toString.call(A);
        return A instanceof Date || typeof A == "object" && U === "[object Date]" ? new Date(A.getTime()) : typeof A == "number" || U === "[object Number]" ? new Date(A) : (typeof A != "string" && U !== "[object String]" || typeof console > "u" || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
      }
      function R(A) {
        const U = function(J, K) {
          var re;
          r(1, arguments);
          var se = o((re = K == null ? void 0 : K.additionalDigits) !== null && re !== void 0 ? re : 2);
          if (se !== 2 && se !== 1 && se !== 0)
            throw new RangeError("additionalDigits must be 0, 1 or 2");
          if (typeof J != "string" && Object.prototype.toString.call(J) !== "[object String]")
            return /* @__PURE__ */ new Date(NaN);
          var fe, we = c(J);
          if (we.date) {
            var Ie = d(we.date, se);
            fe = T(Ie.restDateString, Ie.year);
          }
          if (!fe || isNaN(fe.getTime()))
            return /* @__PURE__ */ new Date(NaN);
          var Ee, Ce = fe.getTime(), Ae = 0;
          if (we.time && (Ae = h(we.time), isNaN(Ae)))
            return /* @__PURE__ */ new Date(NaN);
          if (!we.timezone) {
            var Oe = new Date(Ce + Ae), Pe = /* @__PURE__ */ new Date(0);
            return Pe.setFullYear(Oe.getUTCFullYear(), Oe.getUTCMonth(), Oe.getUTCDate()), Pe.setHours(Oe.getUTCHours(), Oe.getUTCMinutes(), Oe.getUTCSeconds(), Oe.getUTCMilliseconds()), Pe;
          }
          return Ee = v(we.timezone), isNaN(Ee) ? /* @__PURE__ */ new Date(NaN) : new Date(Ce + Ae + Ee);
        }(A);
        if (!function(J) {
          if (r(1, arguments), !B(J) && typeof J != "number")
            return !1;
          var K = I(J);
          return !isNaN(Number(K));
        }(U))
          throw new Error(`Invalid ISO 8601 date string (${A})`);
        return U;
      }
      const p = Math.pow(2, 20), M = p;
      var $ = n(14), Z = n.n($), _ = n(18), y = n(56), C = n(19), w = n(4), x = n(34);
      function H(A) {
        return Z()(A, { cycles: !0 });
      }
      var L = function(A, U) {
        var J = {};
        for (var K in A)
          Object.prototype.hasOwnProperty.call(A, K) && U.indexOf(K) < 0 && (J[K] = A[K]);
        if (A != null && typeof Object.getOwnPropertySymbols == "function") {
          var re = 0;
          for (K = Object.getOwnPropertySymbols(A); re < K.length; re++)
            U.indexOf(K[re]) < 0 && Object.prototype.propertyIsEnumerable.call(A, K[re]) && (J[K[re]] = A[K[re]]);
        }
        return J;
      };
      function N(A, U = {}) {
        const J = (we) => U.redacted !== !1 ? Object(x.a)(we) : we;
        if (!A.stack)
          return { message: H(J(A)) };
        const { name: K, message: re, stack: se } = A, fe = L(A, ["name", "message", "stack"]);
        return { name: K, message: re !== void 0 ? re : H(J(A)), stack: se, meta: fe && Object.keys(fe).length === 0 ? void 0 : J(fe) };
      }
      function P(A, U = {}) {
        const { message: J, stack: K, meta: re } = N(A, U);
        return `${K || J || ""}${re && Object.keys(re).length > 0 ? ` -- ${H(re)}` : ""}`;
      }
      var z = n(39), O = n(103), m = n.n(O), F = function(A, U, J, K) {
        return new (J || (J = Promise))(function(re, se) {
          function fe(Ee) {
            try {
              Ie(K.next(Ee));
            } catch (Ce) {
              se(Ce);
            }
          }
          function we(Ee) {
            try {
              Ie(K.throw(Ee));
            } catch (Ce) {
              se(Ce);
            }
          }
          function Ie(Ee) {
            var Ce;
            Ee.done ? re(Ee.value) : (Ce = Ee.value, Ce instanceof J ? Ce : new J(function(Ae) {
              Ae(Ce);
            })).then(fe, we);
          }
          Ie((K = K.apply(A, U || [])).next());
        });
      }, V = function(A, U) {
        var J = {};
        for (var K in A)
          Object.prototype.hasOwnProperty.call(A, K) && U.indexOf(K) < 0 && (J[K] = A[K]);
        if (A != null && typeof Object.getOwnPropertySymbols == "function") {
          var re = 0;
          for (K = Object.getOwnPropertySymbols(A); re < K.length; re++)
            U.indexOf(K[re]) < 0 && Object.prototype.propertyIsEnumerable.call(A, K[re]) && (J[K[re]] = A[K[re]]);
        }
        return J;
      };
      class Q extends m.a {
        constructor(U, J) {
          super(), this.endpoint = U, this.metadata = J, this.logClient = this.getLogClient();
        }
        getLogClient() {
          return F(this, void 0, void 0, function* () {
            const { LogClient: U } = yield Promise.resolve().then(n.bind(null, 231));
            return new U(this.endpoint);
          });
        }
        log(U, J) {
          return F(this, void 0, void 0, function* () {
            const { level: K, message: re, error: se } = U, fe = V(U, ["level", "message", "error"]);
            this.emit("logged");
            try {
              yield (yield this.logClient).log([{ timestamp: (/* @__PURE__ */ new Date()).toISOString(), level: K, message: `${re}`.substring(0, 1e3), error: se !== void 0 ? N(se) : void 0, meta: Object.assign(Object.assign({}, fe), this.metadata) }]);
            } catch (we) {
              console.error(`Failed to log to log-api: ${P(we)}`);
            }
            J();
          });
        }
      }
      var ee = function(A, U) {
        var J = {};
        for (var K in A)
          Object.prototype.hasOwnProperty.call(A, K) && U.indexOf(K) < 0 && (J[K] = A[K]);
        if (A != null && typeof Object.getOwnPropertySymbols == "function") {
          var re = 0;
          for (K = Object.getOwnPropertySymbols(A); re < K.length; re++)
            U.indexOf(K[re]) < 0 && Object.prototype.propertyIsEnumerable.call(A, K[re]) && (J[K[re]] = A[K[re]]);
        }
        return J;
      };
      const ne = { app: w.a, namespace: w.i, buildTag: w.b, instanceId: z.a }, Y = w.e ? C.format.printf((A) => {
        var { timestamp: U, level: J, message: K, error: re } = A, se = ee(A, ["timestamp", "level", "message", "error"]);
        const fe = Object.assign(Object.assign({ timestamp: U ? R(U).getTime() : (/* @__PURE__ */ new Date()).getTime(), level: J.toUpperCase(), message: K }, re ? { error: N(re) } : {}), { meta: Object.assign(Object.assign({}, ne), se) });
        return Z()(fe, { cycles: !0 });
      }) : C.format.printf((A) => {
        var { timestamp: U, level: J, message: K, error: re } = A, se = ee(A, ["timestamp", "level", "message", "error"]);
        let fe = `${U || (/* @__PURE__ */ new Date()).toISOString()} ${J.toUpperCase()}: ${K} `;
        return Object.keys(se).length > 0 && (fe += Z()(se, { cycles: !0 })), re && (fe += `
${P(re)}`), fe;
      }), G = Object(C.createLogger)({ level: w.f });
      if (G.add(new C.transports.Console({ format: Y, level: "debug" })), G.transports.forEach((A) => {
        A.silent = !w.g;
      }), w.d && G.add(new Q(w.d, ne)), w.h) {
        const A = y.resolve(_.tmpdir(), `silly-${w.a}.log`);
        G.debug("Logging silly logs to file", { filename: A }), G.add(new C.transports.File({ filename: A, maxsize: 1 * M, maxFiles: 10, format: C.format.combine((S = "silly", Object(C.format)((U) => U.level === S && U)()), Y), level: "silly" }));
      }
      var S;
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return r;
      });
      const r = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 2592e6, year: 31536e6 };
    }, function(e, t) {
      var n, r, o = e.exports = {};
      function l() {
        throw new Error("setTimeout has not been defined");
      }
      function u() {
        throw new Error("clearTimeout has not been defined");
      }
      function s(E) {
        if (n === setTimeout)
          return setTimeout(E, 0);
        if ((n === l || !n) && setTimeout)
          return n = setTimeout, setTimeout(E, 0);
        try {
          return n(E, 0);
        } catch {
          try {
            return n.call(null, E, 0);
          } catch {
            return n.call(this, E, 0);
          }
        }
      }
      (function() {
        try {
          n = typeof setTimeout == "function" ? setTimeout : l;
        } catch {
          n = l;
        }
        try {
          r = typeof clearTimeout == "function" ? clearTimeout : u;
        } catch {
          r = u;
        }
      })();
      var g, c = [], d = !1, T = -1;
      function b() {
        d && g && (d = !1, g.length ? c = g.concat(c) : T = -1, c.length && h());
      }
      function h() {
        if (!d) {
          var E = s(b);
          d = !0;
          for (var j = c.length; j; ) {
            for (g = c, c = []; ++T < j; )
              g && g[T].run();
            T = -1, j = c.length;
          }
          g = null, d = !1, function(B) {
            if (r === clearTimeout)
              return clearTimeout(B);
            if ((r === u || !r) && clearTimeout)
              return r = clearTimeout, clearTimeout(B);
            try {
              r(B);
            } catch {
              try {
                return r.call(null, B);
              } catch {
                return r.call(this, B);
              }
            }
          }(E);
        }
      }
      function f(E, j) {
        this.fun = E, this.array = j;
      }
      function v() {
      }
      o.nextTick = function(E) {
        var j = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var B = 1; B < arguments.length; B++)
            j[B - 1] = arguments[B];
        c.push(new f(E, j)), c.length !== 1 || d || s(h);
      }, f.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = v, o.addListener = v, o.once = v, o.off = v, o.removeListener = v, o.removeAllListeners = v, o.emit = v, o.prependListener = v, o.prependOnceListener = v, o.listeners = function(E) {
        return [];
      }, o.binding = function(E) {
        throw new Error("process.binding is not supported");
      }, o.cwd = function() {
        return "/";
      }, o.chdir = function(E) {
        throw new Error("process.chdir is not supported");
      }, o.umask = function() {
        return 0;
      };
    }, function(e, t, n) {
      Object.defineProperty(t, "LEVEL", { value: Symbol.for("level") }), Object.defineProperty(t, "MESSAGE", { value: Symbol.for("message") }), Object.defineProperty(t, "SPLAT", { value: Symbol.for("splat") }), Object.defineProperty(t, "configs", { value: n(118) });
    }, function(e, t, n) {
      (function(r) {
        n.d(t, "a", function() {
          return u;
        }), n.d(t, "i", function() {
          return s;
        }), n.d(t, "j", function() {
          return g;
        }), n.d(t, "b", function() {
          return c;
        }), n.d(t, "f", function() {
          return d;
        }), n.d(t, "e", function() {
          return T;
        }), n.d(t, "g", function() {
          return b;
        }), n.d(t, "d", function() {
          return h;
        }), n.d(t, "c", function() {
          return f;
        }), n.d(t, "h", function() {
          return v;
        });
        var o = n(102);
        const l = o.from({ ENVIRONMENT: r.env.ENV, AGGREGATE_LEVEL: r.env.AGGREGATE_LEVEL, API_ENDPOINT: r.env.API_ENDPOINT, APP: "realtime-sdk", APP_PATH: r.env.APP_PATH, BUILD_TAG: r.env.BUILD_TAG, ENABLE_SELF_SERVE: r.env.ENABLE_SELF_SERVE, ENABLE_SENTRY: r.env.ENABLE_SENTRY, ENABLE_SENTRY_PROFILING: r.env.ENABLE_SENTRY_PROFILING, GIT_COMMIT: r.env.GIT_COMMIT, JEST_WORKER_ID: r.env.JEST_WORKER_ID, LOG_API_ENDPOINT: r.env.LOG_API_ENDPOINT, LOG_JSON: "false", LOG_LEVEL: r.env.LOG_LEVEL, LOG_TO_CONSOLE: r.env.LOG_TO_CONSOLE, LOG_TO_FILE: r.env.LOG_TO_FILE, NAMESPACE: "production", SENTRY_DSN: r.env.SENTRY_DSN, SHEET_EXPORT_MAX_ROW_COUNT: r.env.SHEET_EXPORT_MAX_ROW_COUNT, STABLE_AGENT_VERSION: r.env.STABLE_AGENT_VERSION, VERSION: r.env.VERSION }), u = (l.get("ENVIRONMENT").default("").asString(), l.get("APP").default("").asString()), s = (l.get("APP_PATH").default("").asString(), l.get("API_ENDPOINT").default("").asString(), l.get("NAMESPACE").default("").asString()), g = l.get("VERSION").default("").asString(), c = l.get("BUILD_TAG").default("").asString(), d = (l.get("GIT_COMMIT").default("").asString(), l.get("ENABLE_SENTRY").default("false").asBool(), l.get("ENABLE_SENTRY_PROFILING").default("false").asBool(), l.get("SENTRY_DSN").default("").asString(), l.get("LOG_LEVEL").default("debug").asString()), T = l.get("LOG_JSON").default("true").asBool(), b = l.get("LOG_TO_CONSOLE").default("true").asBool(), h = (l.get("STABLE_AGENT_VERSION").default("").asString(), l.get("LOG_API_ENDPOINT").asString()), f = l.get("JEST_WORKER_ID").asString(), v = (l.get("SHEET_EXPORT_MAX_ROW_COUNT").default("10000").asIntPositive(), l.get("LOG_TO_FILE").default("false").asBoolStrict());
        l.get("ENABLE_SELF_SERVE").default("true").asBoolStrict(), l.get("AGGREGATE_LEVEL").default("hour").asEnum(["day", "hour", "minute"]);
      }).call(this, n(2));
    }, function(e, t, n) {
      (function(r) {
        var o = n(126), l = n(127), u = n(42);
        function s() {
          return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function g(S, A) {
          if (s() < A)
            throw new RangeError("Invalid typed array length");
          return c.TYPED_ARRAY_SUPPORT ? (S = new Uint8Array(A)).__proto__ = c.prototype : (S === null && (S = new c(A)), S.length = A), S;
        }
        function c(S, A, U) {
          if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c))
            return new c(S, A, U);
          if (typeof S == "number") {
            if (typeof A == "string")
              throw new Error("If encoding is specified then the first argument must be a string");
            return b(this, S);
          }
          return d(this, S, A, U);
        }
        function d(S, A, U, J) {
          if (typeof A == "number")
            throw new TypeError('"value" argument must not be a number');
          return typeof ArrayBuffer < "u" && A instanceof ArrayBuffer ? function(K, re, se, fe) {
            if (re.byteLength, se < 0 || re.byteLength < se)
              throw new RangeError("'offset' is out of bounds");
            if (re.byteLength < se + (fe || 0))
              throw new RangeError("'length' is out of bounds");
            return re = se === void 0 && fe === void 0 ? new Uint8Array(re) : fe === void 0 ? new Uint8Array(re, se) : new Uint8Array(re, se, fe), c.TYPED_ARRAY_SUPPORT ? (K = re).__proto__ = c.prototype : K = h(K, re), K;
          }(S, A, U, J) : typeof A == "string" ? function(K, re, se) {
            if (typeof se == "string" && se !== "" || (se = "utf8"), !c.isEncoding(se))
              throw new TypeError('"encoding" must be a valid string encoding');
            var fe = 0 | v(re, se), we = (K = g(K, fe)).write(re, se);
            return we !== fe && (K = K.slice(0, we)), K;
          }(S, A, U) : function(K, re) {
            if (c.isBuffer(re)) {
              var se = 0 | f(re.length);
              return (K = g(K, se)).length === 0 || re.copy(K, 0, 0, se), K;
            }
            if (re) {
              if (typeof ArrayBuffer < "u" && re.buffer instanceof ArrayBuffer || "length" in re)
                return typeof re.length != "number" || (fe = re.length) != fe ? g(K, 0) : h(K, re);
              if (re.type === "Buffer" && u(re.data))
                return h(K, re.data);
            }
            var fe;
            throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
          }(S, A);
        }
        function T(S) {
          if (typeof S != "number")
            throw new TypeError('"size" argument must be a number');
          if (S < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function b(S, A) {
          if (T(A), S = g(S, A < 0 ? 0 : 0 | f(A)), !c.TYPED_ARRAY_SUPPORT)
            for (var U = 0; U < A; ++U)
              S[U] = 0;
          return S;
        }
        function h(S, A) {
          var U = A.length < 0 ? 0 : 0 | f(A.length);
          S = g(S, U);
          for (var J = 0; J < U; J += 1)
            S[J] = 255 & A[J];
          return S;
        }
        function f(S) {
          if (S >= s())
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
          return 0 | S;
        }
        function v(S, A) {
          if (c.isBuffer(S))
            return S.length;
          if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(S) || S instanceof ArrayBuffer))
            return S.byteLength;
          typeof S != "string" && (S = "" + S);
          var U = S.length;
          if (U === 0)
            return 0;
          for (var J = !1; ; )
            switch (A) {
              case "ascii":
              case "latin1":
              case "binary":
                return U;
              case "utf8":
              case "utf-8":
              case void 0:
                return ne(S).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * U;
              case "hex":
                return U >>> 1;
              case "base64":
                return Y(S).length;
              default:
                if (J)
                  return ne(S).length;
                A = ("" + A).toLowerCase(), J = !0;
            }
        }
        function E(S, A, U) {
          var J = !1;
          if ((A === void 0 || A < 0) && (A = 0), A > this.length || ((U === void 0 || U > this.length) && (U = this.length), U <= 0) || (U >>>= 0) <= (A >>>= 0))
            return "";
          for (S || (S = "utf8"); ; )
            switch (S) {
              case "hex":
                return H(this, A, U);
              case "utf8":
              case "utf-8":
                return C(this, A, U);
              case "ascii":
                return w(this, A, U);
              case "latin1":
              case "binary":
                return x(this, A, U);
              case "base64":
                return y(this, A, U);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return L(this, A, U);
              default:
                if (J)
                  throw new TypeError("Unknown encoding: " + S);
                S = (S + "").toLowerCase(), J = !0;
            }
        }
        function j(S, A, U) {
          var J = S[A];
          S[A] = S[U], S[U] = J;
        }
        function B(S, A, U, J, K) {
          if (S.length === 0)
            return -1;
          if (typeof U == "string" ? (J = U, U = 0) : U > 2147483647 ? U = 2147483647 : U < -2147483648 && (U = -2147483648), U = +U, isNaN(U) && (U = K ? 0 : S.length - 1), U < 0 && (U = S.length + U), U >= S.length) {
            if (K)
              return -1;
            U = S.length - 1;
          } else if (U < 0) {
            if (!K)
              return -1;
            U = 0;
          }
          if (typeof A == "string" && (A = c.from(A, J)), c.isBuffer(A))
            return A.length === 0 ? -1 : I(S, A, U, J, K);
          if (typeof A == "number")
            return A &= 255, c.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? K ? Uint8Array.prototype.indexOf.call(S, A, U) : Uint8Array.prototype.lastIndexOf.call(S, A, U) : I(S, [A], U, J, K);
          throw new TypeError("val must be string, number or Buffer");
        }
        function I(S, A, U, J, K) {
          var re, se = 1, fe = S.length, we = A.length;
          if (J !== void 0 && ((J = String(J).toLowerCase()) === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")) {
            if (S.length < 2 || A.length < 2)
              return -1;
            se = 2, fe /= 2, we /= 2, U /= 2;
          }
          function Ie(Oe, Pe) {
            return se === 1 ? Oe[Pe] : Oe.readUInt16BE(Pe * se);
          }
          if (K) {
            var Ee = -1;
            for (re = U; re < fe; re++)
              if (Ie(S, re) === Ie(A, Ee === -1 ? 0 : re - Ee)) {
                if (Ee === -1 && (Ee = re), re - Ee + 1 === we)
                  return Ee * se;
              } else
                Ee !== -1 && (re -= re - Ee), Ee = -1;
          } else
            for (U + we > fe && (U = fe - we), re = U; re >= 0; re--) {
              for (var Ce = !0, Ae = 0; Ae < we; Ae++)
                if (Ie(S, re + Ae) !== Ie(A, Ae)) {
                  Ce = !1;
                  break;
                }
              if (Ce)
                return re;
            }
          return -1;
        }
        function R(S, A, U, J) {
          U = Number(U) || 0;
          var K = S.length - U;
          J ? (J = Number(J)) > K && (J = K) : J = K;
          var re = A.length;
          if (re % 2 != 0)
            throw new TypeError("Invalid hex string");
          J > re / 2 && (J = re / 2);
          for (var se = 0; se < J; ++se) {
            var fe = parseInt(A.substr(2 * se, 2), 16);
            if (isNaN(fe))
              return se;
            S[U + se] = fe;
          }
          return se;
        }
        function p(S, A, U, J) {
          return G(ne(A, S.length - U), S, U, J);
        }
        function M(S, A, U, J) {
          return G(function(K) {
            for (var re = [], se = 0; se < K.length; ++se)
              re.push(255 & K.charCodeAt(se));
            return re;
          }(A), S, U, J);
        }
        function $(S, A, U, J) {
          return M(S, A, U, J);
        }
        function Z(S, A, U, J) {
          return G(Y(A), S, U, J);
        }
        function _(S, A, U, J) {
          return G(function(K, re) {
            for (var se, fe, we, Ie = [], Ee = 0; Ee < K.length && !((re -= 2) < 0); ++Ee)
              se = K.charCodeAt(Ee), fe = se >> 8, we = se % 256, Ie.push(we), Ie.push(fe);
            return Ie;
          }(A, S.length - U), S, U, J);
        }
        function y(S, A, U) {
          return A === 0 && U === S.length ? o.fromByteArray(S) : o.fromByteArray(S.slice(A, U));
        }
        function C(S, A, U) {
          U = Math.min(S.length, U);
          for (var J = [], K = A; K < U; ) {
            var re, se, fe, we, Ie = S[K], Ee = null, Ce = Ie > 239 ? 4 : Ie > 223 ? 3 : Ie > 191 ? 2 : 1;
            if (K + Ce <= U)
              switch (Ce) {
                case 1:
                  Ie < 128 && (Ee = Ie);
                  break;
                case 2:
                  (192 & (re = S[K + 1])) == 128 && (we = (31 & Ie) << 6 | 63 & re) > 127 && (Ee = we);
                  break;
                case 3:
                  re = S[K + 1], se = S[K + 2], (192 & re) == 128 && (192 & se) == 128 && (we = (15 & Ie) << 12 | (63 & re) << 6 | 63 & se) > 2047 && (we < 55296 || we > 57343) && (Ee = we);
                  break;
                case 4:
                  re = S[K + 1], se = S[K + 2], fe = S[K + 3], (192 & re) == 128 && (192 & se) == 128 && (192 & fe) == 128 && (we = (15 & Ie) << 18 | (63 & re) << 12 | (63 & se) << 6 | 63 & fe) > 65535 && we < 1114112 && (Ee = we);
              }
            Ee === null ? (Ee = 65533, Ce = 1) : Ee > 65535 && (Ee -= 65536, J.push(Ee >>> 10 & 1023 | 55296), Ee = 56320 | 1023 & Ee), J.push(Ee), K += Ce;
          }
          return function(Ae) {
            var Oe = Ae.length;
            if (Oe <= 4096)
              return String.fromCharCode.apply(String, Ae);
            for (var Pe = "", qe = 0; qe < Oe; )
              Pe += String.fromCharCode.apply(String, Ae.slice(qe, qe += 4096));
            return Pe;
          }(J);
        }
        t.Buffer = c, t.SlowBuffer = function(S) {
          return +S != S && (S = 0), c.alloc(+S);
        }, t.INSPECT_MAX_BYTES = 50, c.TYPED_ARRAY_SUPPORT = r.TYPED_ARRAY_SUPPORT !== void 0 ? r.TYPED_ARRAY_SUPPORT : function() {
          try {
            var S = new Uint8Array(1);
            return S.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, S.foo() === 42 && typeof S.subarray == "function" && S.subarray(1, 1).byteLength === 0;
          } catch {
            return !1;
          }
        }(), t.kMaxLength = s(), c.poolSize = 8192, c._augment = function(S) {
          return S.__proto__ = c.prototype, S;
        }, c.from = function(S, A, U) {
          return d(null, S, A, U);
        }, c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, { value: null, configurable: !0 })), c.alloc = function(S, A, U) {
          return function(J, K, re, se) {
            return T(K), K <= 0 ? g(J, K) : re !== void 0 ? typeof se == "string" ? g(J, K).fill(re, se) : g(J, K).fill(re) : g(J, K);
          }(null, S, A, U);
        }, c.allocUnsafe = function(S) {
          return b(null, S);
        }, c.allocUnsafeSlow = function(S) {
          return b(null, S);
        }, c.isBuffer = function(S) {
          return !(S == null || !S._isBuffer);
        }, c.compare = function(S, A) {
          if (!c.isBuffer(S) || !c.isBuffer(A))
            throw new TypeError("Arguments must be Buffers");
          if (S === A)
            return 0;
          for (var U = S.length, J = A.length, K = 0, re = Math.min(U, J); K < re; ++K)
            if (S[K] !== A[K]) {
              U = S[K], J = A[K];
              break;
            }
          return U < J ? -1 : J < U ? 1 : 0;
        }, c.isEncoding = function(S) {
          switch (String(S).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, c.concat = function(S, A) {
          if (!u(S))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (S.length === 0)
            return c.alloc(0);
          var U;
          if (A === void 0)
            for (A = 0, U = 0; U < S.length; ++U)
              A += S[U].length;
          var J = c.allocUnsafe(A), K = 0;
          for (U = 0; U < S.length; ++U) {
            var re = S[U];
            if (!c.isBuffer(re))
              throw new TypeError('"list" argument must be an Array of Buffers');
            re.copy(J, K), K += re.length;
          }
          return J;
        }, c.byteLength = v, c.prototype._isBuffer = !0, c.prototype.swap16 = function() {
          var S = this.length;
          if (S % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var A = 0; A < S; A += 2)
            j(this, A, A + 1);
          return this;
        }, c.prototype.swap32 = function() {
          var S = this.length;
          if (S % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var A = 0; A < S; A += 4)
            j(this, A, A + 3), j(this, A + 1, A + 2);
          return this;
        }, c.prototype.swap64 = function() {
          var S = this.length;
          if (S % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var A = 0; A < S; A += 8)
            j(this, A, A + 7), j(this, A + 1, A + 6), j(this, A + 2, A + 5), j(this, A + 3, A + 4);
          return this;
        }, c.prototype.toString = function() {
          var S = 0 | this.length;
          return S === 0 ? "" : arguments.length === 0 ? C(this, 0, S) : E.apply(this, arguments);
        }, c.prototype.equals = function(S) {
          if (!c.isBuffer(S))
            throw new TypeError("Argument must be a Buffer");
          return this === S || c.compare(this, S) === 0;
        }, c.prototype.inspect = function() {
          var S = "", A = t.INSPECT_MAX_BYTES;
          return this.length > 0 && (S = this.toString("hex", 0, A).match(/.{2}/g).join(" "), this.length > A && (S += " ... ")), "<Buffer " + S + ">";
        }, c.prototype.compare = function(S, A, U, J, K) {
          if (!c.isBuffer(S))
            throw new TypeError("Argument must be a Buffer");
          if (A === void 0 && (A = 0), U === void 0 && (U = S ? S.length : 0), J === void 0 && (J = 0), K === void 0 && (K = this.length), A < 0 || U > S.length || J < 0 || K > this.length)
            throw new RangeError("out of range index");
          if (J >= K && A >= U)
            return 0;
          if (J >= K)
            return -1;
          if (A >= U)
            return 1;
          if (this === S)
            return 0;
          for (var re = (K >>>= 0) - (J >>>= 0), se = (U >>>= 0) - (A >>>= 0), fe = Math.min(re, se), we = this.slice(J, K), Ie = S.slice(A, U), Ee = 0; Ee < fe; ++Ee)
            if (we[Ee] !== Ie[Ee]) {
              re = we[Ee], se = Ie[Ee];
              break;
            }
          return re < se ? -1 : se < re ? 1 : 0;
        }, c.prototype.includes = function(S, A, U) {
          return this.indexOf(S, A, U) !== -1;
        }, c.prototype.indexOf = function(S, A, U) {
          return B(this, S, A, U, !0);
        }, c.prototype.lastIndexOf = function(S, A, U) {
          return B(this, S, A, U, !1);
        }, c.prototype.write = function(S, A, U, J) {
          if (A === void 0)
            J = "utf8", U = this.length, A = 0;
          else if (U === void 0 && typeof A == "string")
            J = A, U = this.length, A = 0;
          else {
            if (!isFinite(A))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            A |= 0, isFinite(U) ? (U |= 0, J === void 0 && (J = "utf8")) : (J = U, U = void 0);
          }
          var K = this.length - A;
          if ((U === void 0 || U > K) && (U = K), S.length > 0 && (U < 0 || A < 0) || A > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          J || (J = "utf8");
          for (var re = !1; ; )
            switch (J) {
              case "hex":
                return R(this, S, A, U);
              case "utf8":
              case "utf-8":
                return p(this, S, A, U);
              case "ascii":
                return M(this, S, A, U);
              case "latin1":
              case "binary":
                return $(this, S, A, U);
              case "base64":
                return Z(this, S, A, U);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return _(this, S, A, U);
              default:
                if (re)
                  throw new TypeError("Unknown encoding: " + J);
                J = ("" + J).toLowerCase(), re = !0;
            }
        }, c.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        function w(S, A, U) {
          var J = "";
          U = Math.min(S.length, U);
          for (var K = A; K < U; ++K)
            J += String.fromCharCode(127 & S[K]);
          return J;
        }
        function x(S, A, U) {
          var J = "";
          U = Math.min(S.length, U);
          for (var K = A; K < U; ++K)
            J += String.fromCharCode(S[K]);
          return J;
        }
        function H(S, A, U) {
          var J = S.length;
          (!A || A < 0) && (A = 0), (!U || U < 0 || U > J) && (U = J);
          for (var K = "", re = A; re < U; ++re)
            K += ee(S[re]);
          return K;
        }
        function L(S, A, U) {
          for (var J = S.slice(A, U), K = "", re = 0; re < J.length; re += 2)
            K += String.fromCharCode(J[re] + 256 * J[re + 1]);
          return K;
        }
        function N(S, A, U) {
          if (S % 1 != 0 || S < 0)
            throw new RangeError("offset is not uint");
          if (S + A > U)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function P(S, A, U, J, K, re) {
          if (!c.isBuffer(S))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (A > K || A < re)
            throw new RangeError('"value" argument is out of bounds');
          if (U + J > S.length)
            throw new RangeError("Index out of range");
        }
        function z(S, A, U, J) {
          A < 0 && (A = 65535 + A + 1);
          for (var K = 0, re = Math.min(S.length - U, 2); K < re; ++K)
            S[U + K] = (A & 255 << 8 * (J ? K : 1 - K)) >>> 8 * (J ? K : 1 - K);
        }
        function O(S, A, U, J) {
          A < 0 && (A = 4294967295 + A + 1);
          for (var K = 0, re = Math.min(S.length - U, 4); K < re; ++K)
            S[U + K] = A >>> 8 * (J ? K : 3 - K) & 255;
        }
        function m(S, A, U, J, K, re) {
          if (U + J > S.length)
            throw new RangeError("Index out of range");
          if (U < 0)
            throw new RangeError("Index out of range");
        }
        function F(S, A, U, J, K) {
          return K || m(S, 0, U, 4), l.write(S, A, U, J, 23, 4), U + 4;
        }
        function V(S, A, U, J, K) {
          return K || m(S, 0, U, 8), l.write(S, A, U, J, 52, 8), U + 8;
        }
        c.prototype.slice = function(S, A) {
          var U, J = this.length;
          if ((S = ~~S) < 0 ? (S += J) < 0 && (S = 0) : S > J && (S = J), (A = A === void 0 ? J : ~~A) < 0 ? (A += J) < 0 && (A = 0) : A > J && (A = J), A < S && (A = S), c.TYPED_ARRAY_SUPPORT)
            (U = this.subarray(S, A)).__proto__ = c.prototype;
          else {
            var K = A - S;
            U = new c(K, void 0);
            for (var re = 0; re < K; ++re)
              U[re] = this[re + S];
          }
          return U;
        }, c.prototype.readUIntLE = function(S, A, U) {
          S |= 0, A |= 0, U || N(S, A, this.length);
          for (var J = this[S], K = 1, re = 0; ++re < A && (K *= 256); )
            J += this[S + re] * K;
          return J;
        }, c.prototype.readUIntBE = function(S, A, U) {
          S |= 0, A |= 0, U || N(S, A, this.length);
          for (var J = this[S + --A], K = 1; A > 0 && (K *= 256); )
            J += this[S + --A] * K;
          return J;
        }, c.prototype.readUInt8 = function(S, A) {
          return A || N(S, 1, this.length), this[S];
        }, c.prototype.readUInt16LE = function(S, A) {
          return A || N(S, 2, this.length), this[S] | this[S + 1] << 8;
        }, c.prototype.readUInt16BE = function(S, A) {
          return A || N(S, 2, this.length), this[S] << 8 | this[S + 1];
        }, c.prototype.readUInt32LE = function(S, A) {
          return A || N(S, 4, this.length), (this[S] | this[S + 1] << 8 | this[S + 2] << 16) + 16777216 * this[S + 3];
        }, c.prototype.readUInt32BE = function(S, A) {
          return A || N(S, 4, this.length), 16777216 * this[S] + (this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3]);
        }, c.prototype.readIntLE = function(S, A, U) {
          S |= 0, A |= 0, U || N(S, A, this.length);
          for (var J = this[S], K = 1, re = 0; ++re < A && (K *= 256); )
            J += this[S + re] * K;
          return J >= (K *= 128) && (J -= Math.pow(2, 8 * A)), J;
        }, c.prototype.readIntBE = function(S, A, U) {
          S |= 0, A |= 0, U || N(S, A, this.length);
          for (var J = A, K = 1, re = this[S + --J]; J > 0 && (K *= 256); )
            re += this[S + --J] * K;
          return re >= (K *= 128) && (re -= Math.pow(2, 8 * A)), re;
        }, c.prototype.readInt8 = function(S, A) {
          return A || N(S, 1, this.length), 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];
        }, c.prototype.readInt16LE = function(S, A) {
          A || N(S, 2, this.length);
          var U = this[S] | this[S + 1] << 8;
          return 32768 & U ? 4294901760 | U : U;
        }, c.prototype.readInt16BE = function(S, A) {
          A || N(S, 2, this.length);
          var U = this[S + 1] | this[S] << 8;
          return 32768 & U ? 4294901760 | U : U;
        }, c.prototype.readInt32LE = function(S, A) {
          return A || N(S, 4, this.length), this[S] | this[S + 1] << 8 | this[S + 2] << 16 | this[S + 3] << 24;
        }, c.prototype.readInt32BE = function(S, A) {
          return A || N(S, 4, this.length), this[S] << 24 | this[S + 1] << 16 | this[S + 2] << 8 | this[S + 3];
        }, c.prototype.readFloatLE = function(S, A) {
          return A || N(S, 4, this.length), l.read(this, S, !0, 23, 4);
        }, c.prototype.readFloatBE = function(S, A) {
          return A || N(S, 4, this.length), l.read(this, S, !1, 23, 4);
        }, c.prototype.readDoubleLE = function(S, A) {
          return A || N(S, 8, this.length), l.read(this, S, !0, 52, 8);
        }, c.prototype.readDoubleBE = function(S, A) {
          return A || N(S, 8, this.length), l.read(this, S, !1, 52, 8);
        }, c.prototype.writeUIntLE = function(S, A, U, J) {
          S = +S, A |= 0, U |= 0, J || P(this, S, A, U, Math.pow(2, 8 * U) - 1, 0);
          var K = 1, re = 0;
          for (this[A] = 255 & S; ++re < U && (K *= 256); )
            this[A + re] = S / K & 255;
          return A + U;
        }, c.prototype.writeUIntBE = function(S, A, U, J) {
          S = +S, A |= 0, U |= 0, J || P(this, S, A, U, Math.pow(2, 8 * U) - 1, 0);
          var K = U - 1, re = 1;
          for (this[A + K] = 255 & S; --K >= 0 && (re *= 256); )
            this[A + K] = S / re & 255;
          return A + U;
        }, c.prototype.writeUInt8 = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 1, 255, 0), c.TYPED_ARRAY_SUPPORT || (S = Math.floor(S)), this[A] = 255 & S, A + 1;
        }, c.prototype.writeUInt16LE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[A] = 255 & S, this[A + 1] = S >>> 8) : z(this, S, A, !0), A + 2;
        }, c.prototype.writeUInt16BE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[A] = S >>> 8, this[A + 1] = 255 & S) : z(this, S, A, !1), A + 2;
        }, c.prototype.writeUInt32LE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[A + 3] = S >>> 24, this[A + 2] = S >>> 16, this[A + 1] = S >>> 8, this[A] = 255 & S) : O(this, S, A, !0), A + 4;
        }, c.prototype.writeUInt32BE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[A] = S >>> 24, this[A + 1] = S >>> 16, this[A + 2] = S >>> 8, this[A + 3] = 255 & S) : O(this, S, A, !1), A + 4;
        }, c.prototype.writeIntLE = function(S, A, U, J) {
          if (S = +S, A |= 0, !J) {
            var K = Math.pow(2, 8 * U - 1);
            P(this, S, A, U, K - 1, -K);
          }
          var re = 0, se = 1, fe = 0;
          for (this[A] = 255 & S; ++re < U && (se *= 256); )
            S < 0 && fe === 0 && this[A + re - 1] !== 0 && (fe = 1), this[A + re] = (S / se >> 0) - fe & 255;
          return A + U;
        }, c.prototype.writeIntBE = function(S, A, U, J) {
          if (S = +S, A |= 0, !J) {
            var K = Math.pow(2, 8 * U - 1);
            P(this, S, A, U, K - 1, -K);
          }
          var re = U - 1, se = 1, fe = 0;
          for (this[A + re] = 255 & S; --re >= 0 && (se *= 256); )
            S < 0 && fe === 0 && this[A + re + 1] !== 0 && (fe = 1), this[A + re] = (S / se >> 0) - fe & 255;
          return A + U;
        }, c.prototype.writeInt8 = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 1, 127, -128), c.TYPED_ARRAY_SUPPORT || (S = Math.floor(S)), S < 0 && (S = 255 + S + 1), this[A] = 255 & S, A + 1;
        }, c.prototype.writeInt16LE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[A] = 255 & S, this[A + 1] = S >>> 8) : z(this, S, A, !0), A + 2;
        }, c.prototype.writeInt16BE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[A] = S >>> 8, this[A + 1] = 255 & S) : z(this, S, A, !1), A + 2;
        }, c.prototype.writeInt32LE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 4, 2147483647, -2147483648), c.TYPED_ARRAY_SUPPORT ? (this[A] = 255 & S, this[A + 1] = S >>> 8, this[A + 2] = S >>> 16, this[A + 3] = S >>> 24) : O(this, S, A, !0), A + 4;
        }, c.prototype.writeInt32BE = function(S, A, U) {
          return S = +S, A |= 0, U || P(this, S, A, 4, 2147483647, -2147483648), S < 0 && (S = 4294967295 + S + 1), c.TYPED_ARRAY_SUPPORT ? (this[A] = S >>> 24, this[A + 1] = S >>> 16, this[A + 2] = S >>> 8, this[A + 3] = 255 & S) : O(this, S, A, !1), A + 4;
        }, c.prototype.writeFloatLE = function(S, A, U) {
          return F(this, S, A, !0, U);
        }, c.prototype.writeFloatBE = function(S, A, U) {
          return F(this, S, A, !1, U);
        }, c.prototype.writeDoubleLE = function(S, A, U) {
          return V(this, S, A, !0, U);
        }, c.prototype.writeDoubleBE = function(S, A, U) {
          return V(this, S, A, !1, U);
        }, c.prototype.copy = function(S, A, U, J) {
          if (U || (U = 0), J || J === 0 || (J = this.length), A >= S.length && (A = S.length), A || (A = 0), J > 0 && J < U && (J = U), J === U || S.length === 0 || this.length === 0)
            return 0;
          if (A < 0)
            throw new RangeError("targetStart out of bounds");
          if (U < 0 || U >= this.length)
            throw new RangeError("sourceStart out of bounds");
          if (J < 0)
            throw new RangeError("sourceEnd out of bounds");
          J > this.length && (J = this.length), S.length - A < J - U && (J = S.length - A + U);
          var K, re = J - U;
          if (this === S && U < A && A < J)
            for (K = re - 1; K >= 0; --K)
              S[K + A] = this[K + U];
          else if (re < 1e3 || !c.TYPED_ARRAY_SUPPORT)
            for (K = 0; K < re; ++K)
              S[K + A] = this[K + U];
          else
            Uint8Array.prototype.set.call(S, this.subarray(U, U + re), A);
          return re;
        }, c.prototype.fill = function(S, A, U, J) {
          if (typeof S == "string") {
            if (typeof A == "string" ? (J = A, A = 0, U = this.length) : typeof U == "string" && (J = U, U = this.length), S.length === 1) {
              var K = S.charCodeAt(0);
              K < 256 && (S = K);
            }
            if (J !== void 0 && typeof J != "string")
              throw new TypeError("encoding must be a string");
            if (typeof J == "string" && !c.isEncoding(J))
              throw new TypeError("Unknown encoding: " + J);
          } else
            typeof S == "number" && (S &= 255);
          if (A < 0 || this.length < A || this.length < U)
            throw new RangeError("Out of range index");
          if (U <= A)
            return this;
          var re;
          if (A >>>= 0, U = U === void 0 ? this.length : U >>> 0, S || (S = 0), typeof S == "number")
            for (re = A; re < U; ++re)
              this[re] = S;
          else {
            var se = c.isBuffer(S) ? S : ne(new c(S, J).toString()), fe = se.length;
            for (re = 0; re < U - A; ++re)
              this[re + A] = se[re % fe];
          }
          return this;
        };
        var Q = /[^+\/0-9A-Za-z-_]/g;
        function ee(S) {
          return S < 16 ? "0" + S.toString(16) : S.toString(16);
        }
        function ne(S, A) {
          var U;
          A = A || 1 / 0;
          for (var J = S.length, K = null, re = [], se = 0; se < J; ++se) {
            if ((U = S.charCodeAt(se)) > 55295 && U < 57344) {
              if (!K) {
                if (U > 56319) {
                  (A -= 3) > -1 && re.push(239, 191, 189);
                  continue;
                }
                if (se + 1 === J) {
                  (A -= 3) > -1 && re.push(239, 191, 189);
                  continue;
                }
                K = U;
                continue;
              }
              if (U < 56320) {
                (A -= 3) > -1 && re.push(239, 191, 189), K = U;
                continue;
              }
              U = 65536 + (K - 55296 << 10 | U - 56320);
            } else
              K && (A -= 3) > -1 && re.push(239, 191, 189);
            if (K = null, U < 128) {
              if ((A -= 1) < 0)
                break;
              re.push(U);
            } else if (U < 2048) {
              if ((A -= 2) < 0)
                break;
              re.push(U >> 6 | 192, 63 & U | 128);
            } else if (U < 65536) {
              if ((A -= 3) < 0)
                break;
              re.push(U >> 12 | 224, U >> 6 & 63 | 128, 63 & U | 128);
            } else {
              if (!(U < 1114112))
                throw new Error("Invalid code point");
              if ((A -= 4) < 0)
                break;
              re.push(U >> 18 | 240, U >> 12 & 63 | 128, U >> 6 & 63 | 128, 63 & U | 128);
            }
          }
          return re;
        }
        function Y(S) {
          return o.toByteArray(function(A) {
            if ((A = function(U) {
              return U.trim ? U.trim() : U.replace(/^\s+|\s+$/g, "");
            }(A).replace(Q, "")).length < 2)
              return "";
            for (; A.length % 4 != 0; )
              A += "=";
            return A;
          }(S));
        }
        function G(S, A, U, J) {
          for (var K = 0; K < J && !(K + U >= A.length || K >= S.length); ++K)
            A[K + U] = S[K];
          return K;
        }
      }).call(this, n(6));
    }, function(e, t) {
      var n;
      n = function() {
        return this;
      }();
      try {
        n = n || new Function("return this")();
      } catch {
        typeof window == "object" && (n = window);
      }
      e.exports = n;
    }, function(e, t) {
      typeof Object.create == "function" ? e.exports = function(n, r) {
        r && (n.super_ = r, n.prototype = Object.create(r.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }));
      } : e.exports = function(n, r) {
        if (r) {
          n.super_ = r;
          var o = function() {
          };
          o.prototype = r.prototype, n.prototype = new o(), n.prototype.constructor = n;
        }
      };
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return r;
      });
      const r = (o) => new Promise((l) => setTimeout(l, o || 0));
    }, function(e, t, n) {
      var r = n(99), o = r, l = Function("return this")(), u = n(98);
      o.object.extend(proto, u), o.exportSymbol("proto.v1.signaling.api.CreatePeerRequest", null, l), o.exportSymbol("proto.v1.signaling.api.CreatePeerResponse", null, l), o.exportSymbol("proto.v1.signaling.api.DeletePeerRequest", null, l), o.exportSymbol("proto.v1.signaling.api.DeletePeerResponse", null, l), o.exportSymbol("proto.v1.signaling.api.GetHealthRequest", null, l), o.exportSymbol("proto.v1.signaling.api.GetHealthResponse", null, l), o.exportSymbol("proto.v1.signaling.api.GetIceServersRequest", null, l), o.exportSymbol("proto.v1.signaling.api.GetIceServersResponse", null, l), o.exportSymbol("proto.v1.signaling.api.GetPeersRequest", null, l), o.exportSymbol("proto.v1.signaling.api.GetPeersResponse", null, l), o.exportSymbol("proto.v1.signaling.api.Peer", null, l), o.exportSymbol("proto.v1.signaling.api.ReceiveSignalStreamRequest", null, l), o.exportSymbol("proto.v1.signaling.api.ReceiveSignalStreamResponse", null, l), o.exportSymbol("proto.v1.signaling.api.RefreshPeerRequest", null, l), o.exportSymbol("proto.v1.signaling.api.RefreshPeerResponse", null, l), o.exportSymbol("proto.v1.signaling.api.SendSignalRequest", null, l), o.exportSymbol("proto.v1.signaling.api.SendSignalResponse", null, l), o.exportSymbol("proto.v1.signaling.api.SessionType", null, l), o.exportSymbol("proto.v1.signaling.api.Signal", null, l), proto.v1.signaling.api.Peer = function(s) {
        r.Message.initialize(this, s, 0, -1, proto.v1.signaling.api.Peer.repeatedFields_, null);
      }, o.inherits(proto.v1.signaling.api.Peer, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.Peer.displayName = "proto.v1.signaling.api.Peer"), proto.v1.signaling.api.Signal = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.Signal, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.Signal.displayName = "proto.v1.signaling.api.Signal"), proto.v1.signaling.api.GetHealthRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.GetHealthRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetHealthRequest.displayName = "proto.v1.signaling.api.GetHealthRequest"), proto.v1.signaling.api.GetHealthResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.GetHealthResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetHealthResponse.displayName = "proto.v1.signaling.api.GetHealthResponse"), proto.v1.signaling.api.CreatePeerRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.CreatePeerRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.CreatePeerRequest.displayName = "proto.v1.signaling.api.CreatePeerRequest"), proto.v1.signaling.api.CreatePeerResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.CreatePeerResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.CreatePeerResponse.displayName = "proto.v1.signaling.api.CreatePeerResponse"), proto.v1.signaling.api.DeletePeerRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.DeletePeerRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.DeletePeerRequest.displayName = "proto.v1.signaling.api.DeletePeerRequest"), proto.v1.signaling.api.DeletePeerResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.DeletePeerResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.DeletePeerResponse.displayName = "proto.v1.signaling.api.DeletePeerResponse"), proto.v1.signaling.api.RefreshPeerRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.RefreshPeerRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.RefreshPeerRequest.displayName = "proto.v1.signaling.api.RefreshPeerRequest"), proto.v1.signaling.api.RefreshPeerResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.RefreshPeerResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.RefreshPeerResponse.displayName = "proto.v1.signaling.api.RefreshPeerResponse"), proto.v1.signaling.api.GetPeersRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.GetPeersRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetPeersRequest.displayName = "proto.v1.signaling.api.GetPeersRequest"), proto.v1.signaling.api.GetPeersResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, proto.v1.signaling.api.GetPeersResponse.repeatedFields_, null);
      }, o.inherits(proto.v1.signaling.api.GetPeersResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetPeersResponse.displayName = "proto.v1.signaling.api.GetPeersResponse"), proto.v1.signaling.api.GetIceServersRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.GetIceServersRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetIceServersRequest.displayName = "proto.v1.signaling.api.GetIceServersRequest"), proto.v1.signaling.api.GetIceServersResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.GetIceServersResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.GetIceServersResponse.displayName = "proto.v1.signaling.api.GetIceServersResponse"), proto.v1.signaling.api.SendSignalRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.SendSignalRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.SendSignalRequest.displayName = "proto.v1.signaling.api.SendSignalRequest"), proto.v1.signaling.api.SendSignalResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.SendSignalResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.SendSignalResponse.displayName = "proto.v1.signaling.api.SendSignalResponse"), proto.v1.signaling.api.ReceiveSignalStreamRequest = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.ReceiveSignalStreamRequest, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.ReceiveSignalStreamRequest.displayName = "proto.v1.signaling.api.ReceiveSignalStreamRequest"), proto.v1.signaling.api.ReceiveSignalStreamResponse = function(s) {
        r.Message.initialize(this, s, 0, -1, null, null);
      }, o.inherits(proto.v1.signaling.api.ReceiveSignalStreamResponse, r.Message), o.DEBUG && !COMPILED && (proto.v1.signaling.api.ReceiveSignalStreamResponse.displayName = "proto.v1.signaling.api.ReceiveSignalStreamResponse"), proto.v1.signaling.api.Peer.repeatedFields_ = [5], r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.Peer.prototype.toObject = function(s) {
        return proto.v1.signaling.api.Peer.toObject(s, this);
      }, proto.v1.signaling.api.Peer.toObject = function(s, g) {
        var c, d = { peerId: r.Message.getFieldWithDefault(g, 1, ""), organizationId: r.Message.getFieldWithDefault(g, 2, ""), userId: (c = g.getUserId()) && u.StringValue.toObject(s, c), deviceId: (c = g.getDeviceId()) && u.StringValue.toObject(s, c), sessionIdsList: (c = r.Message.getRepeatedField(g, 5)) == null ? void 0 : c, peerCreatedTimestamp: (c = g.getPeerCreatedTimestamp()) && u.Int64Value.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.Peer.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.Peer();
        return proto.v1.signaling.api.Peer.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.Peer.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = g.readString();
              s.setPeerId(c);
              break;
            case 2:
              c = g.readString(), s.setOrganizationId(c);
              break;
            case 3:
              c = new u.StringValue(), g.readMessage(c, u.StringValue.deserializeBinaryFromReader), s.setUserId(c);
              break;
            case 4:
              c = new u.StringValue(), g.readMessage(c, u.StringValue.deserializeBinaryFromReader), s.setDeviceId(c);
              break;
            case 5:
              c = g.readString(), s.addSessionIds(c);
              break;
            case 6:
              c = new u.Int64Value(), g.readMessage(c, u.Int64Value.deserializeBinaryFromReader), s.setPeerCreatedTimestamp(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.Peer.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.Peer.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.Peer.serializeBinaryToWriter = function(s, g) {
        var c = void 0;
        (c = s.getPeerId()).length > 0 && g.writeString(1, c), (c = s.getOrganizationId()).length > 0 && g.writeString(2, c), (c = s.getUserId()) != null && g.writeMessage(3, c, u.StringValue.serializeBinaryToWriter), (c = s.getDeviceId()) != null && g.writeMessage(4, c, u.StringValue.serializeBinaryToWriter), (c = s.getSessionIdsList()).length > 0 && g.writeRepeatedString(5, c), (c = s.getPeerCreatedTimestamp()) != null && g.writeMessage(6, c, u.Int64Value.serializeBinaryToWriter);
      }, proto.v1.signaling.api.Peer.prototype.getPeerId = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.v1.signaling.api.Peer.prototype.setPeerId = function(s) {
        return r.Message.setProto3StringField(this, 1, s);
      }, proto.v1.signaling.api.Peer.prototype.getOrganizationId = function() {
        return r.Message.getFieldWithDefault(this, 2, "");
      }, proto.v1.signaling.api.Peer.prototype.setOrganizationId = function(s) {
        return r.Message.setProto3StringField(this, 2, s);
      }, proto.v1.signaling.api.Peer.prototype.getUserId = function() {
        return r.Message.getWrapperField(this, u.StringValue, 3);
      }, proto.v1.signaling.api.Peer.prototype.setUserId = function(s) {
        return r.Message.setWrapperField(this, 3, s);
      }, proto.v1.signaling.api.Peer.prototype.clearUserId = function() {
        return this.setUserId(void 0);
      }, proto.v1.signaling.api.Peer.prototype.hasUserId = function() {
        return r.Message.getField(this, 3) != null;
      }, proto.v1.signaling.api.Peer.prototype.getDeviceId = function() {
        return r.Message.getWrapperField(this, u.StringValue, 4);
      }, proto.v1.signaling.api.Peer.prototype.setDeviceId = function(s) {
        return r.Message.setWrapperField(this, 4, s);
      }, proto.v1.signaling.api.Peer.prototype.clearDeviceId = function() {
        return this.setDeviceId(void 0);
      }, proto.v1.signaling.api.Peer.prototype.hasDeviceId = function() {
        return r.Message.getField(this, 4) != null;
      }, proto.v1.signaling.api.Peer.prototype.getSessionIdsList = function() {
        return r.Message.getRepeatedField(this, 5);
      }, proto.v1.signaling.api.Peer.prototype.setSessionIdsList = function(s) {
        return r.Message.setField(this, 5, s || []);
      }, proto.v1.signaling.api.Peer.prototype.addSessionIds = function(s, g) {
        return r.Message.addToRepeatedField(this, 5, s, g);
      }, proto.v1.signaling.api.Peer.prototype.clearSessionIdsList = function() {
        return this.setSessionIdsList([]);
      }, proto.v1.signaling.api.Peer.prototype.getPeerCreatedTimestamp = function() {
        return r.Message.getWrapperField(this, u.Int64Value, 6);
      }, proto.v1.signaling.api.Peer.prototype.setPeerCreatedTimestamp = function(s) {
        return r.Message.setWrapperField(this, 6, s);
      }, proto.v1.signaling.api.Peer.prototype.clearPeerCreatedTimestamp = function() {
        return this.setPeerCreatedTimestamp(void 0);
      }, proto.v1.signaling.api.Peer.prototype.hasPeerCreatedTimestamp = function() {
        return r.Message.getField(this, 6) != null;
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.Signal.prototype.toObject = function(s) {
        return proto.v1.signaling.api.Signal.toObject(s, this);
      }, proto.v1.signaling.api.Signal.toObject = function(s, g) {
        var c, d = { sessionId: (c = g.getSessionId()) && u.StringValue.toObject(s, c), sessionCreatedTimestamp: (c = g.getSessionCreatedTimestamp()) && u.Int64Value.toObject(s, c), senderId: r.Message.getFieldWithDefault(g, 3, ""), receiverId: r.Message.getFieldWithDefault(g, 4, ""), payload: r.Message.getFieldWithDefault(g, 5, ""), iceServers: r.Message.getFieldWithDefault(g, 6, ""), iceTransportPolicy: r.Message.getFieldWithDefault(g, 7, ""), sessionType: r.Message.getFieldWithDefault(g, 8, 0) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.Signal.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.Signal();
        return proto.v1.signaling.api.Signal.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.Signal.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new u.StringValue();
              g.readMessage(c, u.StringValue.deserializeBinaryFromReader), s.setSessionId(c);
              break;
            case 2:
              c = new u.Int64Value(), g.readMessage(c, u.Int64Value.deserializeBinaryFromReader), s.setSessionCreatedTimestamp(c);
              break;
            case 3:
              c = g.readString(), s.setSenderId(c);
              break;
            case 4:
              c = g.readString(), s.setReceiverId(c);
              break;
            case 5:
              c = g.readString(), s.setPayload(c);
              break;
            case 6:
              c = g.readString(), s.setIceServers(c);
              break;
            case 7:
              c = g.readString(), s.setIceTransportPolicy(c);
              break;
            case 8:
              c = g.readEnum(), s.setSessionType(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.Signal.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.Signal.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.Signal.serializeBinaryToWriter = function(s, g) {
        var c = void 0;
        (c = s.getSessionId()) != null && g.writeMessage(1, c, u.StringValue.serializeBinaryToWriter), (c = s.getSessionCreatedTimestamp()) != null && g.writeMessage(2, c, u.Int64Value.serializeBinaryToWriter), (c = s.getSenderId()).length > 0 && g.writeString(3, c), (c = s.getReceiverId()).length > 0 && g.writeString(4, c), (c = s.getPayload()).length > 0 && g.writeString(5, c), (c = s.getIceServers()).length > 0 && g.writeString(6, c), (c = s.getIceTransportPolicy()).length > 0 && g.writeString(7, c), (c = s.getSessionType()) !== 0 && g.writeEnum(8, c);
      }, proto.v1.signaling.api.Signal.prototype.getSessionId = function() {
        return r.Message.getWrapperField(this, u.StringValue, 1);
      }, proto.v1.signaling.api.Signal.prototype.setSessionId = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.Signal.prototype.clearSessionId = function() {
        return this.setSessionId(void 0);
      }, proto.v1.signaling.api.Signal.prototype.hasSessionId = function() {
        return r.Message.getField(this, 1) != null;
      }, proto.v1.signaling.api.Signal.prototype.getSessionCreatedTimestamp = function() {
        return r.Message.getWrapperField(this, u.Int64Value, 2);
      }, proto.v1.signaling.api.Signal.prototype.setSessionCreatedTimestamp = function(s) {
        return r.Message.setWrapperField(this, 2, s);
      }, proto.v1.signaling.api.Signal.prototype.clearSessionCreatedTimestamp = function() {
        return this.setSessionCreatedTimestamp(void 0);
      }, proto.v1.signaling.api.Signal.prototype.hasSessionCreatedTimestamp = function() {
        return r.Message.getField(this, 2) != null;
      }, proto.v1.signaling.api.Signal.prototype.getSenderId = function() {
        return r.Message.getFieldWithDefault(this, 3, "");
      }, proto.v1.signaling.api.Signal.prototype.setSenderId = function(s) {
        return r.Message.setProto3StringField(this, 3, s);
      }, proto.v1.signaling.api.Signal.prototype.getReceiverId = function() {
        return r.Message.getFieldWithDefault(this, 4, "");
      }, proto.v1.signaling.api.Signal.prototype.setReceiverId = function(s) {
        return r.Message.setProto3StringField(this, 4, s);
      }, proto.v1.signaling.api.Signal.prototype.getPayload = function() {
        return r.Message.getFieldWithDefault(this, 5, "");
      }, proto.v1.signaling.api.Signal.prototype.setPayload = function(s) {
        return r.Message.setProto3StringField(this, 5, s);
      }, proto.v1.signaling.api.Signal.prototype.getIceServers = function() {
        return r.Message.getFieldWithDefault(this, 6, "");
      }, proto.v1.signaling.api.Signal.prototype.setIceServers = function(s) {
        return r.Message.setProto3StringField(this, 6, s);
      }, proto.v1.signaling.api.Signal.prototype.getIceTransportPolicy = function() {
        return r.Message.getFieldWithDefault(this, 7, "");
      }, proto.v1.signaling.api.Signal.prototype.setIceTransportPolicy = function(s) {
        return r.Message.setProto3StringField(this, 7, s);
      }, proto.v1.signaling.api.Signal.prototype.getSessionType = function() {
        return r.Message.getFieldWithDefault(this, 8, 0);
      }, proto.v1.signaling.api.Signal.prototype.setSessionType = function(s) {
        return r.Message.setProto3EnumField(this, 8, s);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetHealthRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetHealthRequest.toObject(s, this);
      }, proto.v1.signaling.api.GetHealthRequest.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetHealthRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetHealthRequest();
        return proto.v1.signaling.api.GetHealthRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetHealthRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.GetHealthRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetHealthRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetHealthRequest.serializeBinaryToWriter = function(s, g) {
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetHealthResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetHealthResponse.toObject(s, this);
      }, proto.v1.signaling.api.GetHealthResponse.toObject = function(s, g) {
        var c = { version: r.Message.getFieldWithDefault(g, 1, "") };
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetHealthResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetHealthResponse();
        return proto.v1.signaling.api.GetHealthResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetHealthResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = g.readString();
              s.setVersion(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.GetHealthResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetHealthResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetHealthResponse.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getVersion()).length > 0 && g.writeString(1, c);
      }, proto.v1.signaling.api.GetHealthResponse.prototype.getVersion = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.v1.signaling.api.GetHealthResponse.prototype.setVersion = function(s) {
        return r.Message.setProto3StringField(this, 1, s);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.CreatePeerRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.CreatePeerRequest.toObject(s, this);
      }, proto.v1.signaling.api.CreatePeerRequest.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.CreatePeerRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.CreatePeerRequest();
        return proto.v1.signaling.api.CreatePeerRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.CreatePeerRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.CreatePeerRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.CreatePeerRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.CreatePeerRequest.serializeBinaryToWriter = function(s, g) {
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.CreatePeerResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.CreatePeerResponse.toObject(s, this);
      }, proto.v1.signaling.api.CreatePeerResponse.toObject = function(s, g) {
        var c, d = { peer: (c = g.getPeer()) && proto.v1.signaling.api.Peer.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.CreatePeerResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.CreatePeerResponse();
        return proto.v1.signaling.api.CreatePeerResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.CreatePeerResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new proto.v1.signaling.api.Peer();
              g.readMessage(c, proto.v1.signaling.api.Peer.deserializeBinaryFromReader), s.setPeer(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.CreatePeerResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.CreatePeerResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.CreatePeerResponse.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getPeer()) != null && g.writeMessage(1, c, proto.v1.signaling.api.Peer.serializeBinaryToWriter);
      }, proto.v1.signaling.api.CreatePeerResponse.prototype.getPeer = function() {
        return r.Message.getWrapperField(this, proto.v1.signaling.api.Peer, 1);
      }, proto.v1.signaling.api.CreatePeerResponse.prototype.setPeer = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.CreatePeerResponse.prototype.clearPeer = function() {
        return this.setPeer(void 0);
      }, proto.v1.signaling.api.CreatePeerResponse.prototype.hasPeer = function() {
        return r.Message.getField(this, 1) != null;
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.DeletePeerRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.DeletePeerRequest.toObject(s, this);
      }, proto.v1.signaling.api.DeletePeerRequest.toObject = function(s, g) {
        var c = { peerId: r.Message.getFieldWithDefault(g, 1, "") };
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.DeletePeerRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.DeletePeerRequest();
        return proto.v1.signaling.api.DeletePeerRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.DeletePeerRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = g.readString();
              s.setPeerId(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.DeletePeerRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.DeletePeerRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.DeletePeerRequest.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getPeerId()).length > 0 && g.writeString(1, c);
      }, proto.v1.signaling.api.DeletePeerRequest.prototype.getPeerId = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.v1.signaling.api.DeletePeerRequest.prototype.setPeerId = function(s) {
        return r.Message.setProto3StringField(this, 1, s);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.DeletePeerResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.DeletePeerResponse.toObject(s, this);
      }, proto.v1.signaling.api.DeletePeerResponse.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.DeletePeerResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.DeletePeerResponse();
        return proto.v1.signaling.api.DeletePeerResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.DeletePeerResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.DeletePeerResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.DeletePeerResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.DeletePeerResponse.serializeBinaryToWriter = function(s, g) {
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.RefreshPeerRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.RefreshPeerRequest.toObject(s, this);
      }, proto.v1.signaling.api.RefreshPeerRequest.toObject = function(s, g) {
        var c, d = { peer: (c = g.getPeer()) && proto.v1.signaling.api.Peer.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.RefreshPeerRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.RefreshPeerRequest();
        return proto.v1.signaling.api.RefreshPeerRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.RefreshPeerRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new proto.v1.signaling.api.Peer();
              g.readMessage(c, proto.v1.signaling.api.Peer.deserializeBinaryFromReader), s.setPeer(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.RefreshPeerRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.RefreshPeerRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.RefreshPeerRequest.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getPeer()) != null && g.writeMessage(1, c, proto.v1.signaling.api.Peer.serializeBinaryToWriter);
      }, proto.v1.signaling.api.RefreshPeerRequest.prototype.getPeer = function() {
        return r.Message.getWrapperField(this, proto.v1.signaling.api.Peer, 1);
      }, proto.v1.signaling.api.RefreshPeerRequest.prototype.setPeer = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.RefreshPeerRequest.prototype.clearPeer = function() {
        return this.setPeer(void 0);
      }, proto.v1.signaling.api.RefreshPeerRequest.prototype.hasPeer = function() {
        return r.Message.getField(this, 1) != null;
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.RefreshPeerResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.RefreshPeerResponse.toObject(s, this);
      }, proto.v1.signaling.api.RefreshPeerResponse.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.RefreshPeerResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.RefreshPeerResponse();
        return proto.v1.signaling.api.RefreshPeerResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.RefreshPeerResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.RefreshPeerResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.RefreshPeerResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.RefreshPeerResponse.serializeBinaryToWriter = function(s, g) {
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetPeersRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetPeersRequest.toObject(s, this);
      }, proto.v1.signaling.api.GetPeersRequest.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetPeersRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetPeersRequest();
        return proto.v1.signaling.api.GetPeersRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetPeersRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.GetPeersRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetPeersRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetPeersRequest.serializeBinaryToWriter = function(s, g) {
      }, proto.v1.signaling.api.GetPeersResponse.repeatedFields_ = [1], r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetPeersResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetPeersResponse.toObject(s, this);
      }, proto.v1.signaling.api.GetPeersResponse.toObject = function(s, g) {
        var c = { peersList: r.Message.toObjectList(g.getPeersList(), proto.v1.signaling.api.Peer.toObject, s) };
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetPeersResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetPeersResponse();
        return proto.v1.signaling.api.GetPeersResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetPeersResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new proto.v1.signaling.api.Peer();
              g.readMessage(c, proto.v1.signaling.api.Peer.deserializeBinaryFromReader), s.addPeers(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.GetPeersResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetPeersResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetPeersResponse.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getPeersList()).length > 0 && g.writeRepeatedMessage(1, c, proto.v1.signaling.api.Peer.serializeBinaryToWriter);
      }, proto.v1.signaling.api.GetPeersResponse.prototype.getPeersList = function() {
        return r.Message.getRepeatedWrapperField(this, proto.v1.signaling.api.Peer, 1);
      }, proto.v1.signaling.api.GetPeersResponse.prototype.setPeersList = function(s) {
        return r.Message.setRepeatedWrapperField(this, 1, s);
      }, proto.v1.signaling.api.GetPeersResponse.prototype.addPeers = function(s, g) {
        return r.Message.addToRepeatedWrapperField(this, 1, s, proto.v1.signaling.api.Peer, g);
      }, proto.v1.signaling.api.GetPeersResponse.prototype.clearPeersList = function() {
        return this.setPeersList([]);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetIceServersRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetIceServersRequest.toObject(s, this);
      }, proto.v1.signaling.api.GetIceServersRequest.toObject = function(s, g) {
        var c = {};
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetIceServersRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetIceServersRequest();
        return proto.v1.signaling.api.GetIceServersRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetIceServersRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          g.getFieldNumber(), g.skipField();
        return s;
      }, proto.v1.signaling.api.GetIceServersRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetIceServersRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetIceServersRequest.serializeBinaryToWriter = function(s, g) {
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.GetIceServersResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.GetIceServersResponse.toObject(s, this);
      }, proto.v1.signaling.api.GetIceServersResponse.toObject = function(s, g) {
        var c = { iceServers: r.Message.getFieldWithDefault(g, 1, "") };
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.GetIceServersResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.GetIceServersResponse();
        return proto.v1.signaling.api.GetIceServersResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.GetIceServersResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = g.readString();
              s.setIceServers(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.GetIceServersResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.GetIceServersResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.GetIceServersResponse.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getIceServers()).length > 0 && g.writeString(1, c);
      }, proto.v1.signaling.api.GetIceServersResponse.prototype.getIceServers = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.v1.signaling.api.GetIceServersResponse.prototype.setIceServers = function(s) {
        return r.Message.setProto3StringField(this, 1, s);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.SendSignalRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.SendSignalRequest.toObject(s, this);
      }, proto.v1.signaling.api.SendSignalRequest.toObject = function(s, g) {
        var c, d = { signal: (c = g.getSignal()) && proto.v1.signaling.api.Signal.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.SendSignalRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.SendSignalRequest();
        return proto.v1.signaling.api.SendSignalRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.SendSignalRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new proto.v1.signaling.api.Signal();
              g.readMessage(c, proto.v1.signaling.api.Signal.deserializeBinaryFromReader), s.setSignal(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.SendSignalRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.SendSignalRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.SendSignalRequest.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getSignal()) != null && g.writeMessage(1, c, proto.v1.signaling.api.Signal.serializeBinaryToWriter);
      }, proto.v1.signaling.api.SendSignalRequest.prototype.getSignal = function() {
        return r.Message.getWrapperField(this, proto.v1.signaling.api.Signal, 1);
      }, proto.v1.signaling.api.SendSignalRequest.prototype.setSignal = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.SendSignalRequest.prototype.clearSignal = function() {
        return this.setSignal(void 0);
      }, proto.v1.signaling.api.SendSignalRequest.prototype.hasSignal = function() {
        return r.Message.getField(this, 1) != null;
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.SendSignalResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.SendSignalResponse.toObject(s, this);
      }, proto.v1.signaling.api.SendSignalResponse.toObject = function(s, g) {
        var c, d = { sessionId: (c = g.getSessionId()) && u.StringValue.toObject(s, c), sessionCreatedTimestamp: (c = g.getSessionCreatedTimestamp()) && u.Int64Value.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.SendSignalResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.SendSignalResponse();
        return proto.v1.signaling.api.SendSignalResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.SendSignalResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new u.StringValue();
              g.readMessage(c, u.StringValue.deserializeBinaryFromReader), s.setSessionId(c);
              break;
            case 2:
              c = new u.Int64Value(), g.readMessage(c, u.Int64Value.deserializeBinaryFromReader), s.setSessionCreatedTimestamp(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.SendSignalResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.SendSignalResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.SendSignalResponse.serializeBinaryToWriter = function(s, g) {
        var c = void 0;
        (c = s.getSessionId()) != null && g.writeMessage(1, c, u.StringValue.serializeBinaryToWriter), (c = s.getSessionCreatedTimestamp()) != null && g.writeMessage(2, c, u.Int64Value.serializeBinaryToWriter);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.getSessionId = function() {
        return r.Message.getWrapperField(this, u.StringValue, 1);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.setSessionId = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.clearSessionId = function() {
        return this.setSessionId(void 0);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.hasSessionId = function() {
        return r.Message.getField(this, 1) != null;
      }, proto.v1.signaling.api.SendSignalResponse.prototype.getSessionCreatedTimestamp = function() {
        return r.Message.getWrapperField(this, u.Int64Value, 2);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.setSessionCreatedTimestamp = function(s) {
        return r.Message.setWrapperField(this, 2, s);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.clearSessionCreatedTimestamp = function() {
        return this.setSessionCreatedTimestamp(void 0);
      }, proto.v1.signaling.api.SendSignalResponse.prototype.hasSessionCreatedTimestamp = function() {
        return r.Message.getField(this, 2) != null;
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.ReceiveSignalStreamRequest.prototype.toObject = function(s) {
        return proto.v1.signaling.api.ReceiveSignalStreamRequest.toObject(s, this);
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.toObject = function(s, g) {
        var c = { peerId: r.Message.getFieldWithDefault(g, 1, "") };
        return s && (c.$jspbMessageInstance = g), c;
      }), proto.v1.signaling.api.ReceiveSignalStreamRequest.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.ReceiveSignalStreamRequest();
        return proto.v1.signaling.api.ReceiveSignalStreamRequest.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = g.readString();
              s.setPeerId(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.ReceiveSignalStreamRequest.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getPeerId()).length > 0 && g.writeString(1, c);
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.prototype.getPeerId = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.v1.signaling.api.ReceiveSignalStreamRequest.prototype.setPeerId = function(s) {
        return r.Message.setProto3StringField(this, 1, s);
      }, r.Message.GENERATE_TO_OBJECT && (proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.toObject = function(s) {
        return proto.v1.signaling.api.ReceiveSignalStreamResponse.toObject(s, this);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.toObject = function(s, g) {
        var c, d = { signal: (c = g.getSignal()) && proto.v1.signaling.api.Signal.toObject(s, c) };
        return s && (d.$jspbMessageInstance = g), d;
      }), proto.v1.signaling.api.ReceiveSignalStreamResponse.deserializeBinary = function(s) {
        var g = new r.BinaryReader(s), c = new proto.v1.signaling.api.ReceiveSignalStreamResponse();
        return proto.v1.signaling.api.ReceiveSignalStreamResponse.deserializeBinaryFromReader(c, g);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.deserializeBinaryFromReader = function(s, g) {
        for (; g.nextField() && !g.isEndGroup(); )
          switch (g.getFieldNumber()) {
            case 1:
              var c = new proto.v1.signaling.api.Signal();
              g.readMessage(c, proto.v1.signaling.api.Signal.deserializeBinaryFromReader), s.setSignal(c);
              break;
            default:
              g.skipField();
          }
        return s;
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.serializeBinary = function() {
        var s = new r.BinaryWriter();
        return proto.v1.signaling.api.ReceiveSignalStreamResponse.serializeBinaryToWriter(this, s), s.getResultBuffer();
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.serializeBinaryToWriter = function(s, g) {
        var c;
        (c = s.getSignal()) != null && g.writeMessage(1, c, proto.v1.signaling.api.Signal.serializeBinaryToWriter);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.getSignal = function() {
        return r.Message.getWrapperField(this, proto.v1.signaling.api.Signal, 1);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.setSignal = function(s) {
        return r.Message.setWrapperField(this, 1, s);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.clearSignal = function() {
        return this.setSignal(void 0);
      }, proto.v1.signaling.api.ReceiveSignalStreamResponse.prototype.hasSignal = function() {
        return r.Message.getField(this, 1) != null;
      }, proto.v1.signaling.api.SessionType = { UNKNOWN: 0, TELEOP: 1, PORT_FORWARD: 2, OBSERVE: 3 }, o.object.extend(t, proto.v1.signaling.api);
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return o;
      });
      var r = n(34);
      class o extends Error {
        constructor(u, s, g, c, d = {}, T) {
          super(`Unexpected response (${g}) for ${u} ${s}: ${JSON.stringify(T ? Object(r.a)([...T.entries()].reduce((b, [h, f]) => (b[h] = f, b), {})) : {})} -- ${JSON.stringify(Object(r.a)(c))}`), this.method = u, this.url = s, this.statusCode = g, this.body = c, this.validationErrors = d, this.headers = T;
        }
      }
    }, function(e, t, n) {
      function r(o, l, u = () => !0) {
        if (function(s, g, c = () => !0) {
          return s instanceof g && c(s);
        }(o, l, u))
          return o;
        throw o;
      }
      n.d(t, "a", function() {
        return r;
      });
    }, function(e, t, n) {
      function r(b) {
        return (r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
          return typeof h;
        } : function(h) {
          return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
        })(b);
      }
      function o(b, h) {
        return !h || r(h) !== "object" && typeof h != "function" ? l(b) : h;
      }
      function l(b) {
        if (b === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return b;
      }
      function u(b) {
        var h = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return (u = function(f) {
          if (f === null || (v = f, Function.toString.call(v).indexOf("[native code]") === -1))
            return f;
          var v;
          if (typeof f != "function")
            throw new TypeError("Super expression must either be null or a function");
          if (h !== void 0) {
            if (h.has(f))
              return h.get(f);
            h.set(f, E);
          }
          function E() {
            return s(f, arguments, d(this).constructor);
          }
          return E.prototype = Object.create(f.prototype, { constructor: { value: E, enumerable: !1, writable: !0, configurable: !0 } }), c(E, f);
        })(b);
      }
      function s(b, h, f) {
        return (s = g() ? Reflect.construct : function(v, E, j) {
          var B = [null];
          B.push.apply(B, E);
          var I = new (Function.bind.apply(v, B))();
          return j && c(I, j.prototype), I;
        }).apply(null, arguments);
      }
      function g() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
          return !1;
        if (typeof Proxy == "function")
          return !0;
        try {
          return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          })), !0;
        } catch {
          return !1;
        }
      }
      function c(b, h) {
        return (c = Object.setPrototypeOf || function(f, v) {
          return f.__proto__ = v, f;
        })(b, h);
      }
      function d(b) {
        return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(h) {
          return h.__proto__ || Object.getPrototypeOf(h);
        })(b);
      }
      var T = function(b) {
        (function(j, B) {
          if (typeof B != "function" && B !== null)
            throw new TypeError("Super expression must either be null or a function");
          j.prototype = Object.create(B && B.prototype, { constructor: { value: j, writable: !0, configurable: !0 } }), B && c(j, B);
        })(E, b);
        var h, f, v = (h = E, f = g(), function() {
          var j, B = d(h);
          if (f) {
            var I = d(this).constructor;
            j = Reflect.construct(B, arguments, I);
          } else
            j = B.apply(this, arguments);
          return o(this, j);
        });
        function E(j) {
          var B;
          return function(I, R) {
            if (!(I instanceof R))
              throw new TypeError("Cannot call a class as a function");
          }(this, E), B = v.call(this, `Format functions must be synchronous taking a two arguments: (info, opts)
Found: `.concat(j.toString().split(`
`)[0], `
`)), Error.captureStackTrace(l(B), E), B;
        }
        return E;
      }(u(Error));
      e.exports = function(b) {
        if (b.length > 2)
          throw new T(b);
        function h() {
          var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.options = v;
        }
        function f(v) {
          return new h(v);
        }
        return h.prototype.transform = b, f.Format = h, f;
      };
    }, function(e, t, n) {
      (function(r) {
        var o = Object.getOwnPropertyDescriptors || function(N) {
          for (var P = Object.keys(N), z = {}, O = 0; O < P.length; O++)
            z[P[O]] = Object.getOwnPropertyDescriptor(N, P[O]);
          return z;
        }, l = /%[sdj%]/g;
        t.format = function(N) {
          if (!B(N)) {
            for (var P = [], z = 0; z < arguments.length; z++)
              P.push(g(arguments[z]));
            return P.join(" ");
          }
          z = 1;
          for (var O = arguments, m = O.length, F = String(N).replace(l, function(Q) {
            if (Q === "%%")
              return "%";
            if (z >= m)
              return Q;
            switch (Q) {
              case "%s":
                return String(O[z++]);
              case "%d":
                return Number(O[z++]);
              case "%j":
                try {
                  return JSON.stringify(O[z++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return Q;
            }
          }), V = O[z]; z < m; V = O[++z])
            E(V) || !p(V) ? F += " " + V : F += " " + g(V);
          return F;
        }, t.deprecate = function(N, P) {
          if (r !== void 0 && r.noDeprecation === !0)
            return N;
          if (r === void 0)
            return function() {
              return t.deprecate(N, P).apply(this, arguments);
            };
          var z = !1;
          return function() {
            if (!z) {
              if (r.throwDeprecation)
                throw new Error(P);
              r.traceDeprecation ? console.trace(P) : console.error(P), z = !0;
            }
            return N.apply(this, arguments);
          };
        };
        var u, s = {};
        function g(N, P) {
          var z = { seen: [], stylize: d };
          return arguments.length >= 3 && (z.depth = arguments[2]), arguments.length >= 4 && (z.colors = arguments[3]), v(P) ? z.showHidden = P : P && t._extend(z, P), I(z.showHidden) && (z.showHidden = !1), I(z.depth) && (z.depth = 2), I(z.colors) && (z.colors = !1), I(z.customInspect) && (z.customInspect = !0), z.colors && (z.stylize = c), T(z, N, z.depth);
        }
        function c(N, P) {
          var z = g.styles[P];
          return z ? "\x1B[" + g.colors[z][0] + "m" + N + "\x1B[" + g.colors[z][1] + "m" : N;
        }
        function d(N, P) {
          return N;
        }
        function T(N, P, z) {
          if (N.customInspect && P && Z(P.inspect) && P.inspect !== t.inspect && (!P.constructor || P.constructor.prototype !== P)) {
            var O = P.inspect(z, N);
            return B(O) || (O = T(N, O, z)), O;
          }
          var m = function(S, A) {
            if (I(A))
              return S.stylize("undefined", "undefined");
            if (B(A)) {
              var U = "'" + JSON.stringify(A).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return S.stylize(U, "string");
            }
            if (j(A))
              return S.stylize("" + A, "number");
            if (v(A))
              return S.stylize("" + A, "boolean");
            if (E(A))
              return S.stylize("null", "null");
          }(N, P);
          if (m)
            return m;
          var F = Object.keys(P), V = function(S) {
            var A = {};
            return S.forEach(function(U, J) {
              A[U] = !0;
            }), A;
          }(F);
          if (N.showHidden && (F = Object.getOwnPropertyNames(P)), $(P) && (F.indexOf("message") >= 0 || F.indexOf("description") >= 0))
            return b(P);
          if (F.length === 0) {
            if (Z(P)) {
              var Q = P.name ? ": " + P.name : "";
              return N.stylize("[Function" + Q + "]", "special");
            }
            if (R(P))
              return N.stylize(RegExp.prototype.toString.call(P), "regexp");
            if (M(P))
              return N.stylize(Date.prototype.toString.call(P), "date");
            if ($(P))
              return b(P);
          }
          var ee, ne = "", Y = !1, G = ["{", "}"];
          return f(P) && (Y = !0, G = ["[", "]"]), Z(P) && (ne = " [Function" + (P.name ? ": " + P.name : "") + "]"), R(P) && (ne = " " + RegExp.prototype.toString.call(P)), M(P) && (ne = " " + Date.prototype.toUTCString.call(P)), $(P) && (ne = " " + b(P)), F.length !== 0 || Y && P.length != 0 ? z < 0 ? R(P) ? N.stylize(RegExp.prototype.toString.call(P), "regexp") : N.stylize("[Object]", "special") : (N.seen.push(P), ee = Y ? function(S, A, U, J, K) {
            for (var re = [], se = 0, fe = A.length; se < fe; ++se)
              x(A, String(se)) ? re.push(h(S, A, U, J, String(se), !0)) : re.push("");
            return K.forEach(function(we) {
              we.match(/^\d+$/) || re.push(h(S, A, U, J, we, !0));
            }), re;
          }(N, P, z, V, F) : F.map(function(S) {
            return h(N, P, z, V, S, Y);
          }), N.seen.pop(), function(S, A, U) {
            return S.reduce(function(J, K) {
              return K.indexOf(`
`) >= 0, J + K.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? U[0] + (A === "" ? "" : A + `
 `) + " " + S.join(`,
  `) + " " + U[1] : U[0] + A + " " + S.join(", ") + " " + U[1];
          }(ee, ne, G)) : G[0] + ne + G[1];
        }
        function b(N) {
          return "[" + Error.prototype.toString.call(N) + "]";
        }
        function h(N, P, z, O, m, F) {
          var V, Q, ee;
          if ((ee = Object.getOwnPropertyDescriptor(P, m) || { value: P[m] }).get ? Q = ee.set ? N.stylize("[Getter/Setter]", "special") : N.stylize("[Getter]", "special") : ee.set && (Q = N.stylize("[Setter]", "special")), x(O, m) || (V = "[" + m + "]"), Q || (N.seen.indexOf(ee.value) < 0 ? (Q = E(z) ? T(N, ee.value, null) : T(N, ee.value, z - 1)).indexOf(`
`) > -1 && (Q = F ? Q.split(`
`).map(function(ne) {
            return "  " + ne;
          }).join(`
`).substr(2) : `
` + Q.split(`
`).map(function(ne) {
            return "   " + ne;
          }).join(`
`)) : Q = N.stylize("[Circular]", "special")), I(V)) {
            if (F && m.match(/^\d+$/))
              return Q;
            (V = JSON.stringify("" + m)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (V = V.substr(1, V.length - 2), V = N.stylize(V, "name")) : (V = V.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), V = N.stylize(V, "string"));
          }
          return V + ": " + Q;
        }
        function f(N) {
          return Array.isArray(N);
        }
        function v(N) {
          return typeof N == "boolean";
        }
        function E(N) {
          return N === null;
        }
        function j(N) {
          return typeof N == "number";
        }
        function B(N) {
          return typeof N == "string";
        }
        function I(N) {
          return N === void 0;
        }
        function R(N) {
          return p(N) && _(N) === "[object RegExp]";
        }
        function p(N) {
          return typeof N == "object" && N !== null;
        }
        function M(N) {
          return p(N) && _(N) === "[object Date]";
        }
        function $(N) {
          return p(N) && (_(N) === "[object Error]" || N instanceof Error);
        }
        function Z(N) {
          return typeof N == "function";
        }
        function _(N) {
          return Object.prototype.toString.call(N);
        }
        function y(N) {
          return N < 10 ? "0" + N.toString(10) : N.toString(10);
        }
        t.debuglog = function(N) {
          if (I(u) && (u = r.env.NODE_DEBUG || ""), N = N.toUpperCase(), !s[N])
            if (new RegExp("\\b" + N + "\\b", "i").test(u)) {
              var P = r.pid;
              s[N] = function() {
                var z = t.format.apply(t, arguments);
                console.error("%s %d: %s", N, P, z);
              };
            } else
              s[N] = function() {
              };
          return s[N];
        }, t.inspect = g, g.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, g.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, t.isArray = f, t.isBoolean = v, t.isNull = E, t.isNullOrUndefined = function(N) {
          return N == null;
        }, t.isNumber = j, t.isString = B, t.isSymbol = function(N) {
          return typeof N == "symbol";
        }, t.isUndefined = I, t.isRegExp = R, t.isObject = p, t.isDate = M, t.isError = $, t.isFunction = Z, t.isPrimitive = function(N) {
          return N === null || typeof N == "boolean" || typeof N == "number" || typeof N == "string" || typeof N == "symbol" || N === void 0;
        }, t.isBuffer = n(107);
        var C = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function w() {
          var N = /* @__PURE__ */ new Date(), P = [y(N.getHours()), y(N.getMinutes()), y(N.getSeconds())].join(":");
          return [N.getDate(), C[N.getMonth()], P].join(" ");
        }
        function x(N, P) {
          return Object.prototype.hasOwnProperty.call(N, P);
        }
        t.log = function() {
          console.log("%s - %s", w(), t.format.apply(t, arguments));
        }, t.inherits = n(108), t._extend = function(N, P) {
          if (!P || !p(P))
            return N;
          for (var z = Object.keys(P), O = z.length; O--; )
            N[z[O]] = P[z[O]];
          return N;
        };
        var H = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        function L(N, P) {
          if (!N) {
            var z = new Error("Promise was rejected with a falsy value");
            z.reason = N, N = z;
          }
          return P(N);
        }
        t.promisify = function(N) {
          if (typeof N != "function")
            throw new TypeError('The "original" argument must be of type Function');
          if (H && N[H]) {
            var P;
            if (typeof (P = N[H]) != "function")
              throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(P, H, { value: P, enumerable: !1, writable: !1, configurable: !0 }), P;
          }
          function P() {
            for (var z, O, m = new Promise(function(Q, ee) {
              z = Q, O = ee;
            }), F = [], V = 0; V < arguments.length; V++)
              F.push(arguments[V]);
            F.push(function(Q, ee) {
              Q ? O(Q) : z(ee);
            });
            try {
              N.apply(this, F);
            } catch (Q) {
              O(Q);
            }
            return m;
          }
          return Object.setPrototypeOf(P, Object.getPrototypeOf(N)), H && Object.defineProperty(P, H, { value: P, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(P, o(N));
        }, t.promisify.custom = H, t.callbackify = function(N) {
          if (typeof N != "function")
            throw new TypeError('The "original" argument must be of type Function');
          function P() {
            for (var z = [], O = 0; O < arguments.length; O++)
              z.push(arguments[O]);
            var m = z.pop();
            if (typeof m != "function")
              throw new TypeError("The last argument must be of type Function");
            var F = this, V = function() {
              return m.apply(F, arguments);
            };
            N.apply(this, z).then(function(Q) {
              r.nextTick(V, null, Q);
            }, function(Q) {
              r.nextTick(L, Q, V);
            });
          }
          return Object.setPrototypeOf(P, Object.getPrototypeOf(N)), Object.defineProperties(P, o(N)), P;
        };
      }).call(this, n(2));
    }, function(e, t, n) {
      e.exports = function(r, o) {
        o || (o = {}), typeof o == "function" && (o = { cmp: o });
        var l, u = typeof o.cycles == "boolean" && o.cycles, s = o.cmp && (l = o.cmp, function(c) {
          return function(d, T) {
            var b = { key: d, value: c[d] }, h = { key: T, value: c[T] };
            return l(b, h);
          };
        }), g = [];
        return function c(d) {
          if (d && d.toJSON && typeof d.toJSON == "function" && (d = d.toJSON()), d !== void 0) {
            if (typeof d == "number")
              return isFinite(d) ? "" + d : "null";
            if (typeof d != "object")
              return JSON.stringify(d);
            var T, b;
            if (Array.isArray(d)) {
              for (b = "[", T = 0; T < d.length; T++)
                T && (b += ","), b += c(d[T]) || "null";
              return b + "]";
            }
            if (d === null)
              return "null";
            if (g.indexOf(d) !== -1) {
              if (u)
                return JSON.stringify("__cycle__");
              throw new TypeError("Converting circular structure to JSON");
            }
            var h = g.push(d) - 1, f = Object.keys(d).sort(s && s(d));
            for (b = "", T = 0; T < f.length; T++) {
              var v = f[T], E = c(d[v]);
              E && (b && (b += ","), b += JSON.stringify(v) + ":" + E);
            }
            return g.splice(h, 1), "{" + b + "}";
          }
        }(r);
      };
    }, function(e, t, n) {
      (function(r) {
        var o = r !== void 0 && r || typeof self < "u" && self || window, l = Function.prototype.apply;
        function u(s, g) {
          this._id = s, this._clearFn = g;
        }
        t.setTimeout = function() {
          return new u(l.call(setTimeout, o, arguments), clearTimeout);
        }, t.setInterval = function() {
          return new u(l.call(setInterval, o, arguments), clearInterval);
        }, t.clearTimeout = t.clearInterval = function(s) {
          s && s.close();
        }, u.prototype.unref = u.prototype.ref = function() {
        }, u.prototype.close = function() {
          this._clearFn.call(o, this._id);
        }, t.enroll = function(s, g) {
          clearTimeout(s._idleTimeoutId), s._idleTimeout = g;
        }, t.unenroll = function(s) {
          clearTimeout(s._idleTimeoutId), s._idleTimeout = -1;
        }, t._unrefActive = t.active = function(s) {
          clearTimeout(s._idleTimeoutId);
          var g = s._idleTimeout;
          g >= 0 && (s._idleTimeoutId = setTimeout(function() {
            s._onTimeout && s._onTimeout();
          }, g));
        }, n(141), t.setImmediate = typeof self < "u" && self.setImmediate || r !== void 0 && r.setImmediate || this && this.setImmediate, t.clearImmediate = typeof self < "u" && self.clearImmediate || r !== void 0 && r.clearImmediate || this && this.clearImmediate;
      }).call(this, n(6));
    }, function(e, t, n) {
      (function(r) {
        r === void 0 || !r.version || r.version.indexOf("v0.") === 0 || r.version.indexOf("v1.") === 0 && r.version.indexOf("v1.8.") !== 0 ? e.exports = { nextTick: function(o, l, u, s) {
          if (typeof o != "function")
            throw new TypeError('"callback" argument must be a function');
          var g, c, d = arguments.length;
          switch (d) {
            case 0:
            case 1:
              return r.nextTick(o);
            case 2:
              return r.nextTick(function() {
                o.call(null, l);
              });
            case 3:
              return r.nextTick(function() {
                o.call(null, l, u);
              });
            case 4:
              return r.nextTick(function() {
                o.call(null, l, u, s);
              });
            default:
              for (g = new Array(d - 1), c = 0; c < g.length; )
                g[c++] = arguments[c];
              return r.nextTick(function() {
                o.apply(null, g);
              });
          }
        } } : e.exports = r;
      }).call(this, n(2));
    }, function(e, t, n) {
      (function(r) {
        function o(l) {
          return Object.prototype.toString.call(l);
        }
        t.isArray = function(l) {
          return Array.isArray ? Array.isArray(l) : o(l) === "[object Array]";
        }, t.isBoolean = function(l) {
          return typeof l == "boolean";
        }, t.isNull = function(l) {
          return l === null;
        }, t.isNullOrUndefined = function(l) {
          return l == null;
        }, t.isNumber = function(l) {
          return typeof l == "number";
        }, t.isString = function(l) {
          return typeof l == "string";
        }, t.isSymbol = function(l) {
          return typeof l == "symbol";
        }, t.isUndefined = function(l) {
          return l === void 0;
        }, t.isRegExp = function(l) {
          return o(l) === "[object RegExp]";
        }, t.isObject = function(l) {
          return typeof l == "object" && l !== null;
        }, t.isDate = function(l) {
          return o(l) === "[object Date]";
        }, t.isError = function(l) {
          return o(l) === "[object Error]" || l instanceof Error;
        }, t.isFunction = function(l) {
          return typeof l == "function";
        }, t.isPrimitive = function(l) {
          return l === null || typeof l == "boolean" || typeof l == "number" || typeof l == "string" || typeof l == "symbol" || l === void 0;
        }, t.isBuffer = r.isBuffer;
      }).call(this, n(5).Buffer);
    }, function(e, t) {
      t.endianness = function() {
        return "LE";
      }, t.hostname = function() {
        return typeof location < "u" ? location.hostname : "";
      }, t.loadavg = function() {
        return [];
      }, t.uptime = function() {
        return 0;
      }, t.freemem = function() {
        return Number.MAX_VALUE;
      }, t.totalmem = function() {
        return Number.MAX_VALUE;
      }, t.cpus = function() {
        return [];
      }, t.type = function() {
        return "Browser";
      }, t.release = function() {
        return typeof navigator < "u" ? navigator.appVersion : "";
      }, t.networkInterfaces = t.getNetworkInterfaces = function() {
        return {};
      }, t.arch = function() {
        return "javascript";
      }, t.platform = function() {
        return "browser";
      }, t.tmpdir = t.tmpDir = function() {
        return "/tmp";
      }, t.EOL = `
`, t.homedir = function() {
        return "/";
      };
    }, function(e, t, n) {
      var r = n(58), o = n(61).warn, l = t;
      l.version = n(138).version, l.transports = n(139), l.config = n(50), l.addColors = r.levels, l.format = r.format, l.createLogger = n(88), l.ExceptionHandler = n(89), l.RejectionHandler = n(93), l.Container = n(210), l.Transport = n(20), l.loggers = new l.Container();
      var u = l.createLogger();
      Object.keys(l.config.npm.levels).concat(["log", "query", "stream", "add", "remove", "clear", "profile", "startTimer", "handleExceptions", "unhandleExceptions", "handleRejections", "unhandleRejections", "configure", "child"]).forEach(function(s) {
        return l[s] = function() {
          return u[s].apply(u, arguments);
        };
      }), Object.defineProperty(l, "level", { get: function() {
        return u.level;
      }, set: function(s) {
        u.level = s;
      } }), Object.defineProperty(l, "exceptions", { get: function() {
        return u.exceptions;
      } }), ["exitOnError"].forEach(function(s) {
        Object.defineProperty(l, s, { get: function() {
          return u[s];
        }, set: function(g) {
          u[s] = g;
        } });
      }), Object.defineProperty(l, "default", { get: function() {
        return { exceptionHandlers: u.exceptionHandlers, rejectionHandlers: u.rejectionHandlers, transports: u.transports };
      } }), o.deprecated(l, "setLevels"), o.forFunctions(l, "useFormat", ["cli"]), o.forProperties(l, "useFormat", ["padLevels", "stripColors"]), o.forFunctions(l, "deprecated", ["addRewriter", "addFilter", "clone", "extend"]), o.forProperties(l, "deprecated", ["emitErrs", "levelLength"]), o.moved(l, "createLogger", "Logger");
    }, function(e, t, n) {
      var r = n(13), o = n(142), l = n(3).LEVEL, u = e.exports = function() {
        var s = this, g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        o.call(this, { objectMode: !0, highWaterMark: g.highWaterMark }), this.format = g.format, this.level = g.level, this.handleExceptions = g.handleExceptions, this.handleRejections = g.handleRejections, this.silent = g.silent, g.log && (this.log = g.log), g.logv && (this.logv = g.logv), g.close && (this.close = g.close), this.once("pipe", function(c) {
          s.levels = c.levels, s.parent = c;
        }), this.once("unpipe", function(c) {
          c === s.parent && (s.parent = null, s.close && s.close());
        });
      };
      r.inherits(u, o), u.prototype._write = function(s, g, c) {
        if (this.silent || s.exception === !0 && !this.handleExceptions)
          return c(null);
        var d = this.level || this.parent && this.parent.level;
        if (!d || this.levels[d] >= this.levels[s[l]]) {
          if (s && !this.format)
            return this.log(s, c);
          var T = void 0, b = void 0;
          try {
            b = this.format.transform(Object.assign({}, s), this.format.options);
          } catch (h) {
            T = h;
          }
          if (T || !b) {
            if (c(), T)
              throw T;
            return;
          }
          return this.log(b, c);
        }
        return c(null);
      }, u.prototype._writev = function(s, g) {
        if (this.logv) {
          var c = s.filter(this._accept, this);
          return c.length ? this.logv(c, g) : g(null);
        }
        for (var d = 0; d < s.length; d++)
          if (this._accept(s[d]))
            if (!s[d].chunk || this.format) {
              var T = void 0, b = void 0;
              try {
                b = this.format.transform(Object.assign({}, s[d].chunk), this.format.options);
              } catch (h) {
                T = h;
              }
              if (T || !b) {
                if (s[d].callback(), T)
                  throw g(null), T;
              } else
                this.log(b, s[d].callback);
            } else
              this.log(s[d].chunk, s[d].callback);
        return g(null);
      }, u.prototype._accept = function(s) {
        var g = s.chunk;
        if (this.silent)
          return !1;
        var c = this.level || this.parent && this.parent.level;
        return !(g.exception !== !0 && c && !(this.levels[c] >= this.levels[g[l]]) || !this.handleExceptions && g.exception === !0);
      }, u.prototype._nop = function() {
      }, e.exports.LegacyTransportStream = n(148);
    }, function(e, t, n) {
      var r, o = typeof Reflect == "object" ? Reflect : null, l = o && typeof o.apply == "function" ? o.apply : function(E, j, B) {
        return Function.prototype.apply.call(E, j, B);
      };
      r = o && typeof o.ownKeys == "function" ? o.ownKeys : Object.getOwnPropertySymbols ? function(E) {
        return Object.getOwnPropertyNames(E).concat(Object.getOwnPropertySymbols(E));
      } : function(E) {
        return Object.getOwnPropertyNames(E);
      };
      var u = Number.isNaN || function(E) {
        return E != E;
      };
      function s() {
        s.init.call(this);
      }
      e.exports = s, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
      var g = 10;
      function c(E) {
        return E._maxListeners === void 0 ? s.defaultMaxListeners : E._maxListeners;
      }
      function d(E, j, B, I) {
        var R, p, M, $;
        if (typeof B != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof B);
        if ((p = E._events) === void 0 ? (p = E._events = /* @__PURE__ */ Object.create(null), E._eventsCount = 0) : (p.newListener !== void 0 && (E.emit("newListener", j, B.listener ? B.listener : B), p = E._events), M = p[j]), M === void 0)
          M = p[j] = B, ++E._eventsCount;
        else if (typeof M == "function" ? M = p[j] = I ? [B, M] : [M, B] : I ? M.unshift(B) : M.push(B), (R = c(E)) > 0 && M.length > R && !M.warned) {
          M.warned = !0;
          var Z = new Error("Possible EventEmitter memory leak detected. " + M.length + " " + String(j) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          Z.name = "MaxListenersExceededWarning", Z.emitter = E, Z.type = j, Z.count = M.length, $ = Z, console && console.warn && console.warn($);
        }
        return E;
      }
      function T() {
        for (var E = [], j = 0; j < arguments.length; j++)
          E.push(arguments[j]);
        this.fired || (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, l(this.listener, this.target, E));
      }
      function b(E, j, B) {
        var I = { fired: !1, wrapFn: void 0, target: E, type: j, listener: B }, R = T.bind(I);
        return R.listener = B, I.wrapFn = R, R;
      }
      function h(E, j, B) {
        var I = E._events;
        if (I === void 0)
          return [];
        var R = I[j];
        return R === void 0 ? [] : typeof R == "function" ? B ? [R.listener || R] : [R] : B ? function(p) {
          for (var M = new Array(p.length), $ = 0; $ < M.length; ++$)
            M[$] = p[$].listener || p[$];
          return M;
        }(R) : v(R, R.length);
      }
      function f(E) {
        var j = this._events;
        if (j !== void 0) {
          var B = j[E];
          if (typeof B == "function")
            return 1;
          if (B !== void 0)
            return B.length;
        }
        return 0;
      }
      function v(E, j) {
        for (var B = new Array(j), I = 0; I < j; ++I)
          B[I] = E[I];
        return B;
      }
      Object.defineProperty(s, "defaultMaxListeners", { enumerable: !0, get: function() {
        return g;
      }, set: function(E) {
        if (typeof E != "number" || E < 0 || u(E))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + E + ".");
        g = E;
      } }), s.init = function() {
        this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, s.prototype.setMaxListeners = function(E) {
        if (typeof E != "number" || E < 0 || u(E))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + E + ".");
        return this._maxListeners = E, this;
      }, s.prototype.getMaxListeners = function() {
        return c(this);
      }, s.prototype.emit = function(E) {
        for (var j = [], B = 1; B < arguments.length; B++)
          j.push(arguments[B]);
        var I = E === "error", R = this._events;
        if (R !== void 0)
          I = I && R.error === void 0;
        else if (!I)
          return !1;
        if (I) {
          var p;
          if (j.length > 0 && (p = j[0]), p instanceof Error)
            throw p;
          var M = new Error("Unhandled error." + (p ? " (" + p.message + ")" : ""));
          throw M.context = p, M;
        }
        var $ = R[E];
        if ($ === void 0)
          return !1;
        if (typeof $ == "function")
          l($, this, j);
        else {
          var Z = $.length, _ = v($, Z);
          for (B = 0; B < Z; ++B)
            l(_[B], this, j);
        }
        return !0;
      }, s.prototype.addListener = function(E, j) {
        return d(this, E, j, !1);
      }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(E, j) {
        return d(this, E, j, !0);
      }, s.prototype.once = function(E, j) {
        if (typeof j != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
        return this.on(E, b(this, E, j)), this;
      }, s.prototype.prependOnceListener = function(E, j) {
        if (typeof j != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
        return this.prependListener(E, b(this, E, j)), this;
      }, s.prototype.removeListener = function(E, j) {
        var B, I, R, p, M;
        if (typeof j != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof j);
        if ((I = this._events) === void 0)
          return this;
        if ((B = I[E]) === void 0)
          return this;
        if (B === j || B.listener === j)
          --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete I[E], I.removeListener && this.emit("removeListener", E, B.listener || j));
        else if (typeof B != "function") {
          for (R = -1, p = B.length - 1; p >= 0; p--)
            if (B[p] === j || B[p].listener === j) {
              M = B[p].listener, R = p;
              break;
            }
          if (R < 0)
            return this;
          R === 0 ? B.shift() : function($, Z) {
            for (; Z + 1 < $.length; Z++)
              $[Z] = $[Z + 1];
            $.pop();
          }(B, R), B.length === 1 && (I[E] = B[0]), I.removeListener !== void 0 && this.emit("removeListener", E, M || j);
        }
        return this;
      }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(E) {
        var j, B, I;
        if ((B = this._events) === void 0)
          return this;
        if (B.removeListener === void 0)
          return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : B[E] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete B[E]), this;
        if (arguments.length === 0) {
          var R, p = Object.keys(B);
          for (I = 0; I < p.length; ++I)
            (R = p[I]) !== "removeListener" && this.removeAllListeners(R);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (typeof (j = B[E]) == "function")
          this.removeListener(E, j);
        else if (j !== void 0)
          for (I = j.length - 1; I >= 0; I--)
            this.removeListener(E, j[I]);
        return this;
      }, s.prototype.listeners = function(E) {
        return h(this, E, !0);
      }, s.prototype.rawListeners = function(E) {
        return h(this, E, !1);
      }, s.listenerCount = function(E, j) {
        return typeof E.listenerCount == "function" ? E.listenerCount(j) : f.call(E, j);
      }, s.prototype.listenerCount = f, s.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r(this._events) : [];
      };
    }, function(e, t, n) {
      var r = n(147).Buffer, o = r.isEncoding || function(f) {
        switch ((f = "" + f) && f.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function l(f) {
        var v;
        switch (this.encoding = function(E) {
          var j = function(B) {
            if (!B)
              return "utf8";
            for (var I; ; )
              switch (B) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return B;
                default:
                  if (I)
                    return;
                  B = ("" + B).toLowerCase(), I = !0;
              }
          }(E);
          if (typeof j != "string" && (r.isEncoding === o || !o(E)))
            throw new Error("Unknown encoding: " + E);
          return j || E;
        }(f), this.encoding) {
          case "utf16le":
            this.text = g, this.end = c, v = 4;
            break;
          case "utf8":
            this.fillLast = s, v = 4;
            break;
          case "base64":
            this.text = d, this.end = T, v = 3;
            break;
          default:
            return this.write = b, void (this.end = h);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(v);
      }
      function u(f) {
        return f <= 127 ? 0 : f >> 5 == 6 ? 2 : f >> 4 == 14 ? 3 : f >> 3 == 30 ? 4 : f >> 6 == 2 ? -1 : -2;
      }
      function s(f) {
        var v = this.lastTotal - this.lastNeed, E = function(j, B, I) {
          if ((192 & B[0]) != 128)
            return j.lastNeed = 0, "�";
          if (j.lastNeed > 1 && B.length > 1) {
            if ((192 & B[1]) != 128)
              return j.lastNeed = 1, "�";
            if (j.lastNeed > 2 && B.length > 2 && (192 & B[2]) != 128)
              return j.lastNeed = 2, "�";
          }
        }(this, f);
        return E !== void 0 ? E : this.lastNeed <= f.length ? (f.copy(this.lastChar, v, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (f.copy(this.lastChar, v, 0, f.length), void (this.lastNeed -= f.length));
      }
      function g(f, v) {
        if ((f.length - v) % 2 == 0) {
          var E = f.toString("utf16le", v);
          if (E) {
            var j = E.charCodeAt(E.length - 1);
            if (j >= 55296 && j <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = f[f.length - 2], this.lastChar[1] = f[f.length - 1], E.slice(0, -1);
          }
          return E;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = f[f.length - 1], f.toString("utf16le", v, f.length - 1);
      }
      function c(f) {
        var v = f && f.length ? this.write(f) : "";
        if (this.lastNeed) {
          var E = this.lastTotal - this.lastNeed;
          return v + this.lastChar.toString("utf16le", 0, E);
        }
        return v;
      }
      function d(f, v) {
        var E = (f.length - v) % 3;
        return E === 0 ? f.toString("base64", v) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = f[f.length - 1] : (this.lastChar[0] = f[f.length - 2], this.lastChar[1] = f[f.length - 1]), f.toString("base64", v, f.length - E));
      }
      function T(f) {
        var v = f && f.length ? this.write(f) : "";
        return this.lastNeed ? v + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : v;
      }
      function b(f) {
        return f.toString(this.encoding);
      }
      function h(f) {
        return f && f.length ? this.write(f) : "";
      }
      t.StringDecoder = l, l.prototype.write = function(f) {
        if (f.length === 0)
          return "";
        var v, E;
        if (this.lastNeed) {
          if ((v = this.fillLast(f)) === void 0)
            return "";
          E = this.lastNeed, this.lastNeed = 0;
        } else
          E = 0;
        return E < f.length ? v ? v + this.text(f, E) : this.text(f, E) : v || "";
      }, l.prototype.end = function(f) {
        var v = f && f.length ? this.write(f) : "";
        return this.lastNeed ? v + "�" : v;
      }, l.prototype.text = function(f, v) {
        var E = function(B, I, R) {
          var p = I.length - 1;
          if (p < R)
            return 0;
          var M = u(I[p]);
          return M >= 0 ? (M > 0 && (B.lastNeed = M - 1), M) : --p < R || M === -2 ? 0 : (M = u(I[p])) >= 0 ? (M > 0 && (B.lastNeed = M - 2), M) : --p < R || M === -2 ? 0 : (M = u(I[p])) >= 0 ? (M > 0 && (M === 2 ? M = 0 : B.lastNeed = M - 3), M) : 0;
        }(this, f, v);
        if (!this.lastNeed)
          return f.toString("utf8", v);
        this.lastTotal = E;
        var j = f.length - (E - this.lastNeed);
        return f.copy(this.lastChar, 0, j), f.toString("utf8", v, j);
      }, l.prototype.fillLast = function(f) {
        if (this.lastNeed <= f.length)
          return f.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        f.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, f.length), this.lastNeed -= f.length;
      };
    }, function(e, t, n) {
      var r = n(16), o = Object.keys || function(f) {
        var v = [];
        for (var E in f)
          v.push(E);
        return v;
      };
      e.exports = T;
      var l = n(17);
      l.inherits = n(7);
      var u = n(69), s = n(48);
      l.inherits(T, u);
      for (var g = o(s.prototype), c = 0; c < g.length; c++) {
        var d = g[c];
        T.prototype[d] || (T.prototype[d] = s.prototype[d]);
      }
      function T(f) {
        if (!(this instanceof T))
          return new T(f);
        u.call(this, f), s.call(this, f), f && f.readable === !1 && (this.readable = !1), f && f.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, f && f.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", b);
      }
      function b() {
        this.allowHalfOpen || this._writableState.ended || r.nextTick(h, this);
      }
      function h(f) {
        f.end();
      }
      Object.defineProperty(T.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(T.prototype, "destroyed", { get: function() {
        return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(f) {
        this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = f, this._writableState.destroyed = f);
      } }), T.prototype._destroy = function(f, v) {
        this.push(null), this.end(), r.nextTick(v, f);
      };
    }, function(e, t, n) {
      (function(r) {
        function o(D) {
          var q = 0;
          return function() {
            return q < D.length ? { done: !1, value: D[q++] } : { done: !0 };
          };
        }
        var l = typeof Object.defineProperties == "function" ? Object.defineProperty : function(D, q, te) {
          D != Array.prototype && D != Object.prototype && (D[q] = te.value);
        }, u = function(D) {
          D = [typeof window == "object" && window, typeof self == "object" && self, typeof r == "object" && r, D];
          for (var q = 0; q < D.length; ++q) {
            var te = D[q];
            if (te && te.Math == Math)
              return te;
          }
          throw Error("Cannot find global object");
        }(this);
        function s(D, q) {
          if (q) {
            var te = u;
            D = D.split(".");
            for (var ae = 0; ae < D.length - 1; ae++) {
              var ge = D[ae];
              ge in te || (te[ge] = {}), te = te[ge];
            }
            (q = q(ae = te[D = D[D.length - 1]])) != ae && q != null && l(te, D, { configurable: !0, writable: !0, value: q });
          }
        }
        function g(D) {
          var q = typeof Symbol < "u" && Symbol.iterator && D[Symbol.iterator];
          return q ? q.call(D) : { next: o(D) };
        }
        s("Object.is", function(D) {
          return D || function(q, te) {
            return q === te ? q !== 0 || 1 / q == 1 / te : q != q && te != te;
          };
        }), s("Array.prototype.includes", function(D) {
          return D || function(q, te) {
            var ae = this;
            ae instanceof String && (ae = String(ae));
            var ge = ae.length;
            for (0 > (te = te || 0) && (te = Math.max(te + ge, 0)); te < ge; te++) {
              var me = ae[te];
              if (me === q || Object.is(me, q))
                return !0;
            }
            return !1;
          };
        }), s("Promise", function(D) {
          function q(ue) {
            this.b = 0, this.c = void 0, this.a = [];
            var de = this.f();
            try {
              ue(de.resolve, de.reject);
            } catch (Se) {
              de.reject(Se);
            }
          }
          function te() {
            this.a = null;
          }
          function ae(ue) {
            return ue instanceof q ? ue : new q(function(de) {
              de(ue);
            });
          }
          if (D)
            return D;
          te.prototype.b = function(ue) {
            if (this.a == null) {
              this.a = [];
              var de = this;
              this.c(function() {
                de.g();
              });
            }
            this.a.push(ue);
          };
          var ge = u.setTimeout;
          te.prototype.c = function(ue) {
            ge(ue, 0);
          }, te.prototype.g = function() {
            for (; this.a && this.a.length; ) {
              var ue = this.a;
              this.a = [];
              for (var de = 0; de < ue.length; ++de) {
                var Se = ue[de];
                ue[de] = null;
                try {
                  Se();
                } catch (ve) {
                  this.f(ve);
                }
              }
            }
            this.a = null;
          }, te.prototype.f = function(ue) {
            this.c(function() {
              throw ue;
            });
          }, q.prototype.f = function() {
            function ue(ve) {
              return function(Te) {
                Se || (Se = !0, ve.call(de, Te));
              };
            }
            var de = this, Se = !1;
            return { resolve: ue(this.m), reject: ue(this.g) };
          }, q.prototype.m = function(ue) {
            if (ue === this)
              this.g(new TypeError("A Promise cannot resolve to itself"));
            else if (ue instanceof q)
              this.o(ue);
            else {
              e:
                switch (typeof ue) {
                  case "object":
                    var de = ue != null;
                    break e;
                  case "function":
                    de = !0;
                    break e;
                  default:
                    de = !1;
                }
              de ? this.l(ue) : this.h(ue);
            }
          }, q.prototype.l = function(ue) {
            var de = void 0;
            try {
              de = ue.then;
            } catch (Se) {
              return void this.g(Se);
            }
            typeof de == "function" ? this.u(de, ue) : this.h(ue);
          }, q.prototype.g = function(ue) {
            this.i(2, ue);
          }, q.prototype.h = function(ue) {
            this.i(1, ue);
          }, q.prototype.i = function(ue, de) {
            if (this.b != 0)
              throw Error("Cannot settle(" + ue + ", " + de + "): Promise already settled in state" + this.b);
            this.b = ue, this.c = de, this.j();
          }, q.prototype.j = function() {
            if (this.a != null) {
              for (var ue = 0; ue < this.a.length; ++ue)
                me.b(this.a[ue]);
              this.a = null;
            }
          };
          var me = new te();
          return q.prototype.o = function(ue) {
            var de = this.f();
            ue.w(de.resolve, de.reject);
          }, q.prototype.u = function(ue, de) {
            var Se = this.f();
            try {
              ue.call(de, Se.resolve, Se.reject);
            } catch (ve) {
              Se.reject(ve);
            }
          }, q.prototype.then = function(ue, de) {
            function Se(xe, He) {
              return typeof xe == "function" ? function(ze) {
                try {
                  ve(xe(ze));
                } catch (We) {
                  Te(We);
                }
              } : He;
            }
            var ve, Te, ke = new q(function(xe, He) {
              ve = xe, Te = He;
            });
            return this.w(Se(ue, ve), Se(de, Te)), ke;
          }, q.prototype.catch = function(ue) {
            return this.then(void 0, ue);
          }, q.prototype.w = function(ue, de) {
            function Se() {
              switch (ve.b) {
                case 1:
                  ue(ve.c);
                  break;
                case 2:
                  de(ve.c);
                  break;
                default:
                  throw Error("Unexpected state: " + ve.b);
              }
            }
            var ve = this;
            this.a == null ? me.b(Se) : this.a.push(Se);
          }, q.resolve = ae, q.reject = function(ue) {
            return new q(function(de, Se) {
              Se(ue);
            });
          }, q.race = function(ue) {
            return new q(function(de, Se) {
              for (var ve = g(ue), Te = ve.next(); !Te.done; Te = ve.next())
                ae(Te.value).w(de, Se);
            });
          }, q.all = function(ue) {
            var de = g(ue), Se = de.next();
            return Se.done ? ae([]) : new q(function(ve, Te) {
              function ke(ze) {
                return function(We) {
                  xe[ze] = We, --He == 0 && ve(xe);
                };
              }
              var xe = [], He = 0;
              do
                xe.push(void 0), He++, ae(Se.value).w(ke(xe.length - 1), Te), Se = de.next();
              while (!Se.done);
            });
          }, q;
        });
        var c = c || {}, d = this || self;
        function T(D, q) {
          D = D.split("."), q = q || d;
          for (var te = 0; te < D.length; te++)
            if ((q = q[D[te]]) == null)
              return null;
          return q;
        }
        function b() {
        }
        function h(D) {
          var q = typeof D;
          if (q == "object") {
            if (!D)
              return "null";
            if (D instanceof Array)
              return "array";
            if (D instanceof Object)
              return q;
            var te = Object.prototype.toString.call(D);
            if (te == "[object Window]")
              return "object";
            if (te == "[object Array]" || typeof D.length == "number" && D.splice !== void 0 && D.propertyIsEnumerable !== void 0 && !D.propertyIsEnumerable("splice"))
              return "array";
            if (te == "[object Function]" || D.call !== void 0 && D.propertyIsEnumerable !== void 0 && !D.propertyIsEnumerable("call"))
              return "function";
          } else if (q == "function" && D.call === void 0)
            return "object";
          return q;
        }
        function f(D) {
          var q = typeof D;
          return q == "object" && D != null || q == "function";
        }
        function v(D, q, te) {
          return D.call.apply(D.bind, arguments);
        }
        function E(D, q, te) {
          if (!D)
            throw Error();
          if (2 < arguments.length) {
            var ae = Array.prototype.slice.call(arguments, 2);
            return function() {
              var ge = Array.prototype.slice.call(arguments);
              return Array.prototype.unshift.apply(ge, ae), D.apply(q, ge);
            };
          }
          return function() {
            return D.apply(q, arguments);
          };
        }
        function j(D, q, te) {
          return (j = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? v : E).apply(null, arguments);
        }
        function B(D, q) {
          function te() {
          }
          te.prototype = q.prototype, D.S = q.prototype, D.prototype = new te(), D.prototype.constructor = D;
        }
        function I() {
          this.a = {};
        }
        function R(D, q, te, ae) {
          this.f = D, this.c = q, this.b = te, this.a = ae;
        }
        function p(D, q, te, ae) {
          te = te === void 0 ? {} : te, this.c = D, this.a = te, this.b = q, this.f = ae === void 0 ? null : ae;
        }
        function M(D, q, te, ae, ge, me) {
          this.name = D, this.a = ge, this.b = me;
        }
        function $(D, q, te) {
          te = te === void 0 ? {} : te;
          var ae = ae === void 0 ? new I() : ae;
          return new R(q, D, te, ae);
        }
        function Z(D, q, te, ae) {
          return ae instanceof M ? ae : new M(D, te, ae.b || q.constructor, ae.f, ae.a, ae.c);
        }
        function _(D) {
          this.a = D;
        }
        function y(D) {
          switch (D) {
            case 0:
              return "No Error";
            case 1:
              return "Access denied to content document";
            case 2:
              return "File not found";
            case 3:
              return "Firefox silently errored";
            case 4:
              return "Application custom error";
            case 5:
              return "An exception occurred";
            case 6:
              return "Http response at 400 or 500 level";
            case 7:
              return "Request was aborted";
            case 8:
              return "Request timed out";
            case 9:
              return "The resource is not available offline";
            default:
              return "Unrecognized error code";
          }
        }
        function C(D) {
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, C);
          else {
            var q = Error().stack;
            q && (this.stack = q);
          }
          D && (this.message = String(D));
        }
        function w(D, q) {
          for (var te = "", ae = (D = D.split("%s")).length - 1, ge = 0; ge < ae; ge++)
            te += D[ge] + (ge < q.length ? q[ge] : "%s");
          C.call(this, te + D[ae]);
        }
        function x() {
          this.j = null, this.i = [], this.l = 0, this.b = H, this.f = this.a = this.h = 0, this.c = null, this.g = 0;
        }
        I.prototype.get = function(D) {
          return this.a[D];
        }, I.prototype.f = function() {
          return Object.keys(this.a);
        }, R.prototype.getRequestMessage = function() {
          return this.f;
        }, R.prototype.getMethodDescriptor = function() {
          return this.c;
        }, R.prototype.getMetadata = function() {
          return this.b;
        }, R.prototype.getCallOptions = function() {
          return this.a;
        }, p.prototype.getResponseMessage = function() {
          return this.c;
        }, p.prototype.getMetadata = function() {
          return this.a;
        }, p.prototype.getMethodDescriptor = function() {
          return this.b;
        }, p.prototype.getStatus = function() {
          return this.f;
        }, _.prototype.on = function(D, q) {
          return D == "data" || D == "error" ? this : this.a.on(D, q);
        }, _.prototype.removeListener = function(D, q) {
          return this.a.removeListener(D, q);
        }, _.prototype.cancel = function() {
          this.a.cancel();
        }, B(C, Error), C.prototype.name = "CustomError", B(w, C), w.prototype.name = "AssertionError";
        var H = 0, L = 1, N = 2, P = 3, z = 0, O = 128;
        function m(D, q, te, ae) {
          throw D.b = P, D.j = "The stream is broken @" + D.l + "/" + te + ". Error: " + ae + `. With input:
` + q, Error(D.j);
        }
        var F = Array.prototype.indexOf ? function(D, q) {
          return Array.prototype.indexOf.call(D, q, void 0);
        } : function(D, q) {
          if (typeof D == "string")
            return typeof q != "string" || q.length != 1 ? -1 : D.indexOf(q, 0);
          for (var te = 0; te < D.length; te++)
            if (te in D && D[te] === q)
              return te;
          return -1;
        }, V, Q = String.prototype.trim ? function(D) {
          return D.trim();
        } : function(D) {
          return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(D)[1];
        };
        function ee(D, q) {
          return D.indexOf(q) != -1;
        }
        function ne(D, q) {
          return D < q ? -1 : D > q ? 1 : 0;
        }
        e: {
          var Y = d.navigator;
          if (Y) {
            var G = Y.userAgent;
            if (G) {
              V = G;
              break e;
            }
          }
          V = "";
        }
        var S = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
        function A(D) {
          var q = 1;
          D = D.split(":");
          for (var te = []; 0 < q && D.length; )
            te.push(D.shift()), q--;
          return D.length && te.push(D.join(":")), te;
        }
        function U(D) {
          return U[" "](D), D;
        }
        U[" "] = b;
        var J, K, re = ee(V, "Opera"), se = ee(V, "Trident") || ee(V, "MSIE"), fe = ee(V, "Edge"), we = ee(V, "Gecko") && !(ee(V.toLowerCase(), "webkit") && !ee(V, "Edge")) && !(ee(V, "Trident") || ee(V, "MSIE")) && !ee(V, "Edge"), Ie = ee(V.toLowerCase(), "webkit") && !ee(V, "Edge");
        function Ee() {
          var D = d.document;
          return D ? D.documentMode : void 0;
        }
        e: {
          var Ce = "", Ae = (K = V, we ? /rv:([^\);]+)(\)|;)/.exec(K) : fe ? /Edge\/([\d\.]+)/.exec(K) : se ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(K) : Ie ? /WebKit\/(\S+)/.exec(K) : re ? /(?:Version)[ \/]?(\S+)/.exec(K) : void 0);
          if (Ae && (Ce = Ae ? Ae[1] : ""), se) {
            var Oe = Ee();
            if (Oe != null && Oe > parseFloat(Ce)) {
              J = String(Oe);
              break e;
            }
          }
          J = Ce;
        }
        var Pe, qe = {};
        function et(D) {
          return function(q, te) {
            var ae = qe;
            return Object.prototype.hasOwnProperty.call(ae, q) ? ae[q] : ae[q] = te(q);
          }(D, function() {
            for (var q = 0, te = Q(String(J)).split("."), ae = Q(String(D)).split("."), ge = Math.max(te.length, ae.length), me = 0; q == 0 && me < ge; me++) {
              var ue = te[me] || "", de = ae[me] || "";
              do {
                if (ue = /(\d*)(\D*)(.*)/.exec(ue) || ["", "", "", ""], de = /(\d*)(\D*)(.*)/.exec(de) || ["", "", "", ""], ue[0].length == 0 && de[0].length == 0)
                  break;
                q = ne(ue[1].length == 0 ? 0 : parseInt(ue[1], 10), de[1].length == 0 ? 0 : parseInt(de[1], 10)) || ne(ue[2].length == 0, de[2].length == 0) || ne(ue[2], de[2]), ue = ue[3], de = de[3];
              } while (q == 0);
            }
            return 0 <= q;
          });
        }
        if (d.document && se) {
          var Qe = Ee();
          Pe = Qe || parseInt(J, 10) || void 0;
        } else
          Pe = void 0;
        var yt = Pe;
        function at() {
          this.F = this.F;
        }
        at.prototype.F = !1;
        var _t, Ot = Object.freeze || function(D) {
          return D;
        };
        (_t = !se) || (_t = 9 <= Number(yt));
        var St = _t, Ue = se && !et("9"), Mt = function() {
          if (!d.addEventListener || !Object.defineProperty)
            return !1;
          var D = !1, q = Object.defineProperty({}, "passive", { get: function() {
            D = !0;
          } });
          try {
            d.addEventListener("test", b, q), d.removeEventListener("test", b, q);
          } catch {
          }
          return D;
        }();
        function tt(D, q) {
          this.type = D, this.a = this.target = q, this.defaultPrevented = !1;
        }
        function rt(D, q) {
          if (tt.call(this, D ? D.type : ""), this.relatedTarget = this.a = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.pointerId = 0, this.pointerType = "", this.c = null, D) {
            var te = this.type = D.type, ae = D.changedTouches && D.changedTouches.length ? D.changedTouches[0] : null;
            if (this.target = D.target || D.srcElement, this.a = q, q = D.relatedTarget) {
              if (we) {
                e: {
                  try {
                    U(q.nodeName);
                    var ge = !0;
                    break e;
                  } catch {
                  }
                  ge = !1;
                }
                ge || (q = null);
              }
            } else
              te == "mouseover" ? q = D.fromElement : te == "mouseout" && (q = D.toElement);
            this.relatedTarget = q, ae ? (this.clientX = ae.clientX !== void 0 ? ae.clientX : ae.pageX, this.clientY = ae.clientY !== void 0 ? ae.clientY : ae.pageY, this.screenX = ae.screenX || 0, this.screenY = ae.screenY || 0) : (this.clientX = D.clientX !== void 0 ? D.clientX : D.pageX, this.clientY = D.clientY !== void 0 ? D.clientY : D.pageY, this.screenX = D.screenX || 0, this.screenY = D.screenY || 0), this.button = D.button, this.key = D.key || "", this.ctrlKey = D.ctrlKey, this.altKey = D.altKey, this.shiftKey = D.shiftKey, this.metaKey = D.metaKey, this.pointerId = D.pointerId || 0, this.pointerType = typeof D.pointerType == "string" ? D.pointerType : jt[D.pointerType] || "", this.c = D, D.defaultPrevented && this.b();
          }
        }
        tt.prototype.b = function() {
          this.defaultPrevented = !0;
        }, B(rt, tt);
        var jt = Ot({ 2: "touch", 3: "pen", 4: "mouse" });
        rt.prototype.b = function() {
          rt.S.b.call(this);
          var D = this.c;
          if (D.preventDefault)
            D.preventDefault();
          else if (D.returnValue = !1, Ue)
            try {
              (D.ctrlKey || 112 <= D.keyCode && 123 >= D.keyCode) && (D.keyCode = -1);
            } catch {
            }
        };
        var ht = "closure_listenable_" + (1e6 * Math.random() | 0), Ct = 0;
        function st(D, q, te, ae, ge) {
          this.listener = D, this.proxy = null, this.src = q, this.type = te, this.capture = !!ae, this.A = ge, this.key = ++Ct, this.s = this.v = !1;
        }
        function Et(D) {
          D.s = !0, D.listener = null, D.proxy = null, D.src = null, D.A = null;
        }
        function Be(D) {
          this.src = D, this.a = {}, this.b = 0;
        }
        function Tt(D, q) {
          var te = q.type;
          if (te in D.a) {
            var ae, ge = D.a[te], me = F(ge, q);
            (ae = 0 <= me) && Array.prototype.splice.call(ge, me, 1), ae && (Et(q), D.a[te].length == 0 && (delete D.a[te], D.b--));
          }
        }
        function pe(D, q, te, ae) {
          for (var ge = 0; ge < D.length; ++ge) {
            var me = D[ge];
            if (!me.s && me.listener == q && me.capture == !!te && me.A == ae)
              return ge;
          }
          return -1;
        }
        Be.prototype.add = function(D, q, te, ae, ge) {
          var me = D.toString();
          (D = this.a[me]) || (D = this.a[me] = [], this.b++);
          var ue = pe(D, q, ae, ge);
          return -1 < ue ? (q = D[ue], te || (q.v = !1)) : ((q = new st(q, this.src, me, !!ae, ge)).v = te, D.push(q)), q;
        };
        var k = "closure_lm_" + (1e6 * Math.random() | 0), W = {};
        function X(D, q, te, ae, ge) {
          if (ae && ae.once)
            (function ue(de, Se, ve, Te, ke) {
              if (Array.isArray(Se))
                for (var xe = 0; xe < Se.length; xe++)
                  ue(de, Se[xe], ve, Te, ke);
              else
                ve = Me(ve), de && de[ht] ? de.f.add(String(Se), ve, !0, f(Te) ? !!Te.capture : !!Te, ke) : ie(de, Se, ve, !0, Te, ke);
            })(D, q, te, ae, ge);
          else if (Array.isArray(q))
            for (var me = 0; me < q.length; me++)
              X(D, q[me], te, ae, ge);
          else
            te = Me(te), D && D[ht] ? D.f.add(String(q), te, !1, f(ae) ? !!ae.capture : !!ae, ge) : ie(D, q, te, !1, ae, ge);
        }
        function ie(D, q, te, ae, ge, me) {
          if (!q)
            throw Error("Invalid event type");
          var ue = f(ge) ? !!ge.capture : !!ge, de = le(D);
          if (de || (D[k] = de = new Be(D)), !(te = de.add(q, te, ae, ue, me)).proxy)
            if (ae = function() {
              var Se = ce, ve = St ? function(Te) {
                return Se.call(ve.src, ve.listener, Te);
              } : function(Te) {
                if (!(Te = Se.call(ve.src, ve.listener, Te)))
                  return Te;
              };
              return ve;
            }(), te.proxy = ae, ae.src = D, ae.listener = te, D.addEventListener)
              Mt || (ge = ue), ge === void 0 && (ge = !1), D.addEventListener(q.toString(), ae, ge);
            else if (D.attachEvent)
              D.attachEvent(he(q.toString()), ae);
            else {
              if (!D.addListener || !D.removeListener)
                throw Error("addEventListener and attachEvent are unavailable.");
              D.addListener(ae);
            }
        }
        function oe(D) {
          if (typeof D != "number" && D && !D.s) {
            var q = D.src;
            if (q && q[ht])
              Tt(q.f, D);
            else {
              var te = D.type, ae = D.proxy;
              q.removeEventListener ? q.removeEventListener(te, ae, D.capture) : q.detachEvent ? q.detachEvent(he(te), ae) : q.addListener && q.removeListener && q.removeListener(ae), (te = le(q)) ? (Tt(te, D), te.b == 0 && (te.src = null, q[k] = null)) : Et(D);
            }
          }
        }
        function he(D) {
          return D in W ? W[D] : W[D] = "on" + D;
        }
        function ye(D, q, te, ae) {
          var ge = !0;
          if ((D = le(D)) && (q = D.a[q.toString()]))
            for (q = q.concat(), D = 0; D < q.length; D++) {
              var me = q[D];
              me && me.capture == te && !me.s && (me = _e(me, ae), ge = ge && me !== !1);
            }
          return ge;
        }
        function _e(D, q) {
          var te = D.listener, ae = D.A || D.src;
          return D.v && oe(D), te.call(ae, q);
        }
        function ce(D, q) {
          if (D.s)
            return !0;
          if (!St) {
            var te = q || T("window.event");
            q = new rt(te, this);
            var ae = !0;
            if (!(0 > te.keyCode || te.returnValue != null)) {
              e: {
                var ge = !1;
                if (te.keyCode == 0)
                  try {
                    te.keyCode = -1;
                    break e;
                  } catch {
                    ge = !0;
                  }
                (ge || te.returnValue == null) && (te.returnValue = !0);
              }
              for (te = [], ge = q.a; ge; ge = ge.parentNode)
                te.push(ge);
              for (D = D.type, ge = te.length - 1; 0 <= ge; ge--) {
                q.a = te[ge];
                var me = ye(te[ge], D, !0, q);
                ae = ae && me;
              }
              for (ge = 0; ge < te.length; ge++)
                q.a = te[ge], me = ye(te[ge], D, !1, q), ae = ae && me;
            }
            return ae;
          }
          return _e(D, new rt(q, this));
        }
        function le(D) {
          return (D = D[k]) instanceof Be ? D : null;
        }
        var Re = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
        function Me(D) {
          return h(D) == "function" ? D : (D[Re] || (D[Re] = function(q) {
            return D.handleEvent(q);
          }), D[Re]);
        }
        function Ne() {
          at.call(this), this.f = new Be(this), this.N = this;
        }
        function Fe(D, q) {
          D = D.N;
          var te = q.type || q;
          if (typeof q == "string")
            q = new tt(q, D);
          else if (q instanceof tt)
            q.target = q.target || D;
          else {
            var ae = q;
            (function(ge, me) {
              for (var ue, de, Se = 1; Se < arguments.length; Se++) {
                for (ue in de = arguments[Se])
                  ge[ue] = de[ue];
                for (var ve = 0; ve < S.length; ve++)
                  ue = S[ve], Object.prototype.hasOwnProperty.call(de, ue) && (ge[ue] = de[ue]);
              }
            })(q = new tt(te, D), ae);
          }
          Ye(D = q.a = D, te, !0, q), Ye(D, te, !1, q);
        }
        function Ye(D, q, te, ae) {
          if (q = D.f.a[String(q)]) {
            q = q.concat();
            for (var ge = !0, me = 0; me < q.length; ++me) {
              var ue = q[me];
              if (ue && !ue.s && ue.capture == te) {
                var de = ue.listener, Se = ue.A || ue.src;
                ue.v && Tt(D.f, ue), ge = de.call(Se, ae) !== !1 && ge;
              }
            }
          }
        }
        function Ge(D, q, te) {
          if (h(D) == "function")
            te && (D = j(D, te));
          else {
            if (!D || typeof D.handleEvent != "function")
              throw Error("Invalid listener argument");
            D = j(D.handleEvent, D);
          }
          return 2147483647 < Number(q) ? -1 : d.setTimeout(D, q || 0);
        }
        function Ze(D, q, te) {
          this.reset(D, q, te, void 0, void 0);
        }
        B(Ne, at), Ne.prototype[ht] = !0, Ne.prototype.addEventListener = function(D, q, te, ae) {
          X(this, D, q, te, ae);
        }, Ne.prototype.removeEventListener = function(D, q, te, ae) {
          (function ge(me, ue, de, Se, ve) {
            if (Array.isArray(ue))
              for (var Te = 0; Te < ue.length; Te++)
                ge(me, ue[Te], de, Se, ve);
            else
              Se = f(Se) ? !!Se.capture : !!Se, de = Me(de), me && me[ht] ? (me = me.f, (ue = String(ue).toString()) in me.a && -1 < (de = pe(Te = me.a[ue], de, Se, ve)) && (Et(Te[de]), Array.prototype.splice.call(Te, de, 1), Te.length == 0 && (delete me.a[ue], me.b--))) : me && (me = le(me)) && (ue = me.a[ue.toString()], me = -1, ue && (me = pe(ue, de, Se, ve)), (de = -1 < me ? ue[me] : null) && oe(de));
          })(this, D, q, te, ae);
        }, Ze.prototype.a = null;
        function De(D) {
          this.f = D, this.b = this.c = this.a = null;
        }
        function Le(D, q) {
          this.name = D, this.value = q;
        }
        Ze.prototype.reset = function(D, q, te, ae, ge) {
          delete this.a;
        }, Le.prototype.toString = function() {
          return this.name;
        };
        var Ve = new Le("SEVERE", 1e3), $e = new Le("CONFIG", 700), Ke = new Le("FINE", 500);
        function Xe(D) {
          return D.c ? D.c : D.a ? Xe(D.a) : (function(q, te) {
            throw new w("Failure" + (q ? ": " + q : ""), Array.prototype.slice.call(arguments, 1));
          }("Root logger has no level set."), null);
        }
        De.prototype.log = function(D, q, te) {
          if (D.value >= Xe(this).value)
            for (h(q) == "function" && (q = q()), D = new Ze(D, String(q), this.f), te && (D.a = te), te = this; te; )
              te = te.a;
        };
        var ot, it = {}, lt = null;
        function Je(D, q) {
          D && D.log(Ke, q, void 0);
        }
        function It() {
        }
        function Lt(D) {
          var q;
          return (q = D.a) || (q = {}, Ft(D) && (q[0] = !0, q[1] = !0), q = D.a = q), q;
        }
        function Ut() {
        }
        function Bt(D) {
          return (D = Ft(D)) ? new ActiveXObject(D) : new XMLHttpRequest();
        }
        function Ft(D) {
          if (!D.b && typeof XMLHttpRequest > "u" && typeof ActiveXObject < "u") {
            for (var q = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], te = 0; te < q.length; te++) {
              var ae = q[te];
              try {
                return new ActiveXObject(ae), D.b = ae;
              } catch {
              }
            }
            throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
          }
          return D.b;
        }
        function pt(D, q) {
          this.b = {}, this.a = [], this.c = 0;
          var te = arguments.length;
          if (1 < te) {
            if (te % 2)
              throw Error("Uneven number of arguments");
            for (var ae = 0; ae < te; ae += 2)
              this.set(arguments[ae], arguments[ae + 1]);
          } else
            D && zt(this, D);
        }
        function Nt(D) {
          if (D.c != D.a.length) {
            for (var q = 0, te = 0; q < D.a.length; ) {
              var ae = D.a[q];
              bt(D.b, ae) && (D.a[te++] = ae), q++;
            }
            D.a.length = te;
          }
          if (D.c != D.a.length) {
            var ge = {};
            for (te = q = 0; q < D.a.length; )
              bt(ge, ae = D.a[q]) || (D.a[te++] = ae, ge[ae] = 1), q++;
            D.a.length = te;
          }
        }
        function zt(D, q) {
          if (q instanceof pt)
            for (var te = q.f(), ae = 0; ae < te.length; ae++)
              D.set(te[ae], q.get(te[ae]));
          else
            for (te in q)
              D.set(te, q[te]);
        }
        function bt(D, q) {
          return Object.prototype.hasOwnProperty.call(D, q);
        }
        It.prototype.a = null, B(Ut, It), ot = new Ut(), pt.prototype.f = function() {
          return Nt(this), this.a.concat();
        }, pt.prototype.get = function(D, q) {
          return bt(this.b, D) ? this.b[D] : q;
        }, pt.prototype.set = function(D, q) {
          bt(this.b, D) || (this.c++, this.a.push(D)), this.b[D] = q;
        }, pt.prototype.forEach = function(D, q) {
          for (var te = this.f(), ae = 0; ae < te.length; ae++) {
            var ge = te[ae], me = this.get(ge);
            D.call(q, me, ge, this);
          }
        };
        var Xt = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
        function ft(D) {
          Ne.call(this), this.headers = new pt(), this.D = D || null, this.c = !1, this.C = this.a = null, this.J = this.o = "", this.g = 0, this.i = "", this.h = this.I = this.m = this.G = !1, this.l = 0, this.u = null, this.j = Ht, this.B = this.H = !1;
        }
        B(ft, Ne);
        var Ht = "", Jt = ft.prototype, Qt = function D(q) {
          var te;
          if (lt || (lt = new De(""), it[""] = lt, lt.c = $e), !(te = it[q])) {
            te = new De(q);
            var ae = q.lastIndexOf("."), ge = q.substr(ae + 1);
            (ae = D(q.substr(0, ae))).b || (ae.b = {}), ae.b[ge] = te, te.a = ae, it[q] = te;
          }
          return te;
        }("goog.net.XhrIo");
        Jt.b = Qt;
        var en = /^https?$/i, tn = ["POST", "PUT"];
        function nn(D, q, te) {
          if (D.a)
            throw Error("[goog.net.XhrIo] Object is active with another request=" + D.o + "; newUri=" + q);
          D.o = q, D.i = "", D.g = 0, D.J = "POST", D.G = !1, D.c = !0, D.a = D.D ? Bt(D.D) : Bt(ot), D.C = D.D ? Lt(D.D) : Lt(ot), D.a.onreadystatechange = j(D.K, D);
          try {
            Je(D.b, gt(D, "Opening Xhr")), D.I = !0, D.a.open("POST", String(q), !0), D.I = !1;
          } catch (me) {
            return Je(D.b, gt(D, "Error opening Xhr: " + me.message)), void Wt(D, me);
          }
          q = te || "";
          var ae = function(me) {
            e: {
              for (var ue = rn, de = me.length, Se = typeof me == "string" ? me.split("") : me, ve = 0; ve < de; ve++)
                if (ve in Se && ue.call(void 0, Se[ve], ve, me)) {
                  ue = ve;
                  break e;
                }
              ue = -1;
            }
            return 0 > ue ? null : typeof me == "string" ? me.charAt(ue) : me[ue];
          }((te = new pt(D.headers)).f()), ge = d.FormData && q instanceof d.FormData;
          !(0 <= F(tn, "POST")) || ae || ge || te.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"), te.forEach(function(me, ue) {
            this.a.setRequestHeader(ue, me);
          }, D), D.j && (D.a.responseType = D.j), "withCredentials" in D.a && D.a.withCredentials !== D.H && (D.a.withCredentials = D.H);
          try {
            $t(D), 0 < D.l && (D.B = function(me) {
              return se && et(9) && typeof me.timeout == "number" && me.ontimeout !== void 0;
            }(D.a), Je(D.b, gt(D, "Will abort after " + D.l + "ms if incomplete, xhr2 " + D.B)), D.B ? (D.a.timeout = D.l, D.a.ontimeout = j(D.L, D)) : D.u = Ge(D.L, D.l, D)), Je(D.b, gt(D, "Sending request")), D.m = !0, D.a.send(q), D.m = !1;
          } catch (me) {
            Je(D.b, gt(D, "Send error: " + me.message)), Wt(D, me);
          }
        }
        function rn(D) {
          return D.toLowerCase() == "content-type";
        }
        function Wt(D, q) {
          D.c = !1, D.a && (D.h = !0, D.a.abort(), D.h = !1), D.i = q, D.g = 5, Vt(D), Dt(D);
        }
        function Vt(D) {
          D.G || (D.G = !0, Fe(D, "complete"), Fe(D, "error"));
        }
        function Gt(D) {
          if (D.c && c !== void 0) {
            if (D.C[1] && mt(D) == 4 && D.getStatus() == 2)
              Je(D.b, gt(D, "Local request error detected and ignored"));
            else if (D.m && mt(D) == 4)
              Ge(D.K, 0, D);
            else if (Fe(D, "readystatechange"), mt(D) == 4) {
              Je(D.b, gt(D, "Request complete")), D.c = !1;
              try {
                var q, te = D.getStatus();
                e:
                  switch (te) {
                    case 200:
                    case 201:
                    case 202:
                    case 204:
                    case 206:
                    case 304:
                    case 1223:
                      var ae = !0;
                      break e;
                    default:
                      ae = !1;
                  }
                if (!(q = ae)) {
                  var ge;
                  if (ge = te === 0) {
                    var me = String(D.o).match(Xt)[1] || null;
                    if (!me && d.self && d.self.location) {
                      var ue = d.self.location.protocol;
                      me = ue.substr(0, ue.length - 1);
                    }
                    ge = !en.test(me ? me.toLowerCase() : "");
                  }
                  q = ge;
                }
                if (q)
                  Fe(D, "complete"), Fe(D, "success");
                else {
                  D.g = 6;
                  try {
                    var de = 2 < mt(D) ? D.a.statusText : "";
                  } catch (Se) {
                    Je(D.b, "Can not get status: " + Se.message), de = "";
                  }
                  D.i = de + " [" + D.getStatus() + "]", Vt(D);
                }
              } finally {
                Dt(D);
              }
            }
          }
        }
        function Dt(D) {
          if (D.a) {
            $t(D);
            var q = D.a, te = D.C[0] ? b : null;
            D.a = null, D.C = null, Fe(D, "ready");
            try {
              q.onreadystatechange = te;
            } catch (ae) {
              (D = D.b) && D.log(Ve, "Problem encountered resetting onreadystatechange: " + ae.message, void 0);
            }
          }
        }
        function $t(D) {
          D.a && D.B && (D.a.ontimeout = null), D.u && (d.clearTimeout(D.u), D.u = null);
        }
        function mt(D) {
          return D.a ? D.a.readyState : 0;
        }
        function qt(D, q) {
          if (D.a && mt(D) == 4)
            return (D = D.a.getResponseHeader(q)) === null ? void 0 : D;
        }
        function gt(D, q) {
          return q + " [" + D.J + " " + D.o + " " + D.getStatus() + "]";
        }
        ft.prototype.L = function() {
          c !== void 0 && this.a && (this.i = "Timed out after " + this.l + "ms, aborting", this.g = 8, Je(this.b, gt(this, this.i)), Fe(this, "timeout"), this.abort(8));
        }, ft.prototype.abort = function(D) {
          this.a && this.c && (Je(this.b, gt(this, "Aborting")), this.c = !1, this.h = !0, this.a.abort(), this.h = !1, this.g = D || 7, Fe(this, "complete"), Fe(this, "abort"), Dt(this));
        }, ft.prototype.K = function() {
          this.F || (this.I || this.m || this.h ? Gt(this) : this.O());
        }, ft.prototype.O = function() {
          Gt(this);
        }, ft.prototype.getStatus = function() {
          try {
            return 2 < mt(this) ? this.a.status : -1;
          } catch {
            return -1;
          }
        };
        var Zt = {}, At = null;
        function on(D) {
          var q = D.length, te = 3 * q / 4;
          te % 3 ? te = Math.floor(te) : ee("=.", D[q - 1]) && (te = ee("=.", D[q - 2]) ? te - 2 : te - 1);
          var ae = new Uint8Array(te), ge = 0;
          return function(me, ue) {
            function de(He) {
              for (; Se < me.length; ) {
                var ze = me.charAt(Se++), We = At[ze];
                if (We != null)
                  return We;
                if (!/^[\s\xa0]*$/.test(ze))
                  throw Error("Unknown base64 encoding at char: " + ze);
              }
              return He;
            }
            Yt();
            for (var Se = 0; ; ) {
              var ve = de(-1), Te = de(0), ke = de(64), xe = de(64);
              if (xe === 64 && ve === -1)
                break;
              ue(ve << 2 | Te >> 4), ke != 64 && (ue(Te << 4 & 240 | ke >> 2), xe != 64 && ue(ke << 6 & 192 | xe));
            }
          }(D, function(me) {
            ae[ge++] = me;
          }), ae.subarray(0, ge);
        }
        function Yt() {
          if (!At) {
            At = {};
            for (var D = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), q = ["+/=", "+/", "-_=", "-_.", "-_"], te = 0; 5 > te; te++) {
              var ae = D.concat(q[te].split(""));
              Zt[te] = ae;
              for (var ge = 0; ge < ae.length; ge++) {
                var me = ae[ge];
                At[me] === void 0 && (At[me] = ge);
              }
            }
          }
        }
        var an = ["content-type", "grpc-status", "grpc-message"];
        function ut(D) {
          this.a = D.T, this.l = null, this.b = [], this.h = [], this.g = [], this.f = [], this.c = [], this.j = !1, this.i = 0, this.m = new x();
          var q = this;
          X(this.a, "readystatechange", function() {
            var te = q.a;
            if (te = te.a ? te.a.getResponseHeader("Content-Type") : null) {
              if ((te = te.toLowerCase()).lastIndexOf("application/grpc-web-text", 0) == 0) {
                te = q.a;
                try {
                  var ae = te.a ? te.a.responseText : "";
                } catch (ve) {
                  Je(te.b, "Can not get responseText: " + ve.message), ae = "";
                }
                if (ae = (te = ae || "").length - te.length % 4, (te = te.substr(q.i, ae - q.i)).length == 0)
                  return;
                q.i = ae, te = on(te);
              } else {
                if (te.lastIndexOf("application/grpc", 0) != 0)
                  return void vt(q, { code: 2, message: "Unknown Content-type received.", metadata: {} });
                te = new Uint8Array(function(ve) {
                  try {
                    if (!ve.a)
                      return null;
                    if ("response" in ve.a)
                      return ve.a.response;
                    switch (ve.j) {
                      case Ht:
                      case "text":
                        return ve.a.responseText;
                      case "arraybuffer":
                        if ("mozResponseArrayBuffer" in ve.a)
                          return ve.a.mozResponseArrayBuffer;
                    }
                    var Te = ve.b;
                    return Te && Te.log(Ve, "Response type " + ve.j + " is not supported on this browser", void 0), null;
                  } catch (ke) {
                    return Je(ve.b, "Can not get response: " + ke.message), null;
                  }
                }(q.a));
              }
              ae = null;
              try {
                ae = function(ve, Te) {
                  function ke(wt) {
                    je.f++, je.a = (je.a << 8) + wt, je.f == 4 && (je.b = N, je.g = 0, typeof Uint8Array < "u" ? je.c = new Uint8Array(je.a) : je.c = Array(je.a), je.a == 0 && He());
                  }
                  function xe(wt) {
                    je.c[je.g++] = wt, je.g == je.a && He();
                  }
                  function He() {
                    var wt = {};
                    wt[je.h] = je.c, je.i.push(wt), je.b = H;
                  }
                  var ze, We, je = ve, ct = 0;
                  for (ze = Te instanceof Uint8Array || Te instanceof Array ? Te : new Uint8Array(Te); ct < ze.length; ) {
                    switch (je.b) {
                      case P:
                        m(je, ze, ct, "stream already broken");
                        break;
                      case H:
                        (We = ze[ct]) == z || We == O ? je.h = We : m(je, ze, ct, "invalid frame byte"), je.b = L, je.a = 0, je.f = 0;
                        break;
                      case L:
                        ke(ze[ct]);
                        break;
                      case N:
                        xe(ze[ct]);
                        break;
                      default:
                        throw Error("unexpected parser state: " + je.b);
                    }
                    je.l++, ct++;
                  }
                  return ve = je.i, je.i = [], 0 < ve.length ? ve : null;
                }(q.m, te);
              } catch {
                vt(q, { code: 2, message: "Error in parsing response body", metadata: {} });
              }
              if (ae)
                for (te = 0; te < ae.length; te++) {
                  if (z in ae[te]) {
                    var ge = ae[te][z];
                    if (ge)
                      try {
                        var me = q.l(ge);
                        if (me) {
                          ge = q;
                          for (var ue = me, de = 0; de < ge.b.length; de++)
                            ge.b[de](ue);
                        }
                      } catch {
                        vt(q, { code: 2, message: "Error in response deserializer function.", metadata: {} });
                      }
                  }
                  if (O in ae[te] && 0 < ae[te][O].length) {
                    for (ge = "", ue = 0; ue < ae[te][O].length; ue++)
                      ge += String.fromCharCode(ae[te][O][ue]);
                    for (ge = ge.trim().split(`\r
`), ue = {}, de = 0; de < ge.length; de++) {
                      var Se = ge[de].indexOf(":");
                      ue[ge[de].substring(0, Se).trim()] = ge[de].substring(Se + 1).trim();
                    }
                    ge = ue, ue = 0, de = "", "grpc-status" in ge && (ue = ge["grpc-status"], delete ge["grpc-status"]), "grpc-message" in ge && (de = ge["grpc-message"], delete ge["grpc-message"]), vt(q, { code: Number(ue), message: de, metadata: ge });
                  }
                }
            }
          }), X(this.a, "complete", function() {
            var te = q.a.g, ae = "", ge = {}, me = function(de) {
              var Se = {};
              de = (de.a && mt(de) == 4 && de.a.getAllResponseHeaders() || "").split(`\r
`);
              for (var ve = 0; ve < de.length; ve++)
                if (!/^[\s\xa0]*$/.test(de[ve])) {
                  var Te = A(de[ve]), ke = Te[0];
                  if (typeof (Te = Te[1]) == "string") {
                    Te = Te.trim();
                    var xe = Se[ke] || [];
                    Se[ke] = xe, xe.push(Te);
                  }
                }
              return function(He, ze) {
                var We, je = {};
                for (We in He)
                  je[We] = ze.call(void 0, He[We], We, He);
                return je;
              }(Se, function(He) {
                return He.join(", ");
              });
            }(q.a);
            if (Object.keys(me).forEach(function(de) {
              an.includes(de) || (ge[de] = me[de]);
            }), function(de, Se) {
              for (var ve = 0; ve < de.g.length; ve++)
                de.g[ve](Se);
            }(q, ge), te != 0) {
              switch (te) {
                case 7:
                  var ue = 10;
                  break;
                case 8:
                  ue = 4;
                  break;
                case 6:
                  ue = function(de) {
                    switch (de) {
                      case 200:
                        return 0;
                      case 400:
                        return 3;
                      case 401:
                        return 16;
                      case 403:
                        return 7;
                      case 404:
                        return 5;
                      case 409:
                        return 10;
                      case 412:
                        return 9;
                      case 429:
                        return 8;
                      case 499:
                        return 1;
                      case 500:
                        return 2;
                      case 501:
                        return 12;
                      case 503:
                        return 14;
                      case 504:
                        return 4;
                      default:
                        return 2;
                    }
                  }(q.a.getStatus());
                  break;
                default:
                  ue = 14;
              }
              ue == 10 && q.j || vt(q, { code: ue, message: y(te), metadata: {} });
            } else
              te = !1, "grpc-status" in me && (ue = qt(q.a, "grpc-status"), "grpc-message" in me && (ae = qt(q.a, "grpc-message")), Number(ue) != 0 && (vt(q, { code: Number(ue), message: ae, metadata: me }), te = !0)), te || function(de) {
                for (var Se = 0; Se < de.c.length; Se++)
                  de.c[Se]();
              }(q);
          });
        }
        function Rt(D, q) {
          -1 < (q = D.indexOf(q)) && D.splice(q, 1);
        }
        function vt(D, q) {
          if (q.code != 0)
            for (var te = { code: q.code, message: decodeURIComponent(q.message || ""), metadata: q.metadata }, ae = 0; ae < D.f.length; ae++)
              D.f[ae](te);
          for (q = { code: q.code, details: decodeURIComponent(q.message || ""), metadata: q.metadata }, te = 0; te < D.h.length; te++)
            D.h[te](q);
        }
        function nt(D) {
          this.a = T("format", D) || "text", this.f = T("suppressCorsPreflight", D) || !1, this.c = T("withCredentials", D) || !1, this.b = T("streamInterceptors", D) || [], this.g = T("unaryInterceptors", D) || [];
        }
        function xt(D, q, te) {
          var ae = q.getMethodDescriptor(), ge = te + ae.name;
          (te = new ft()).H = D.c;
          var me = new ut({ T: te });
          if (me.l = ae.b, zt(te.headers, q.getMetadata()), D.a == "text" ? (te.headers.set("Content-Type", "application/grpc-web-text"), te.headers.set("Accept", "application/grpc-web-text")) : te.headers.set("Content-Type", "application/grpc-web+proto"), te.headers.set("X-User-Agent", "grpc-web-javascript/0.1"), te.headers.set("X-Grpc-Web", "1"), bt(te.headers.b, "deadline")) {
            var ue = te.headers.get("deadline");
            ue = Math.round(ue - (/* @__PURE__ */ new Date()).getTime());
            var de = te.headers;
            bt(de.b, "deadline") && (delete de.b.deadline, de.c--, de.a.length > 2 * de.c && Nt(de)), 1 / 0 === ue && (ue = 0), 0 < ue && te.headers.set("grpc-timeout", ue + "m");
          }
          if (D.f) {
            Nt(de = te.headers), ue = {};
            for (var Se = 0; Se < de.a.length; Se++) {
              var ve = de.a[Se];
              ue[ve] = de.b[ve];
            }
            (de = te.headers).b = {}, de.a.length = 0, de.c = 0;
            e: {
              for (Te in ue) {
                var Te = !1;
                break e;
              }
              Te = !0;
            }
            Te || (ue = function(He) {
              var ze = "";
              return function(We, je) {
                for (var ct in We)
                  je.call(void 0, We[ct], ct, We);
              }(He, function(We, je) {
                ze += je, ze += ":", ze += We, ze += `\r
`;
              }), ze;
            }(ue), typeof ge == "string" ? (Te = encodeURIComponent("$httpHeaders"), (Te += ue = ue != null ? "=" + encodeURIComponent(String(ue)) : "") && (0 > (ue = ge.indexOf("#")) && (ue = ge.length), 0 > (de = ge.indexOf("?")) || de > ue ? (de = ue, Se = "") : Se = ge.substring(de + 1, ue), ue = (ge = [ge.substr(0, de), Se, ge.substr(ue)])[1], ge[1] = Te ? ue ? ue + "&" + Te : Te : ue, ge = ge[0] + (ge[1] ? "?" + ge[1] : "") + ge[2])) : ge.a("$httpHeaders", ue));
          }
          for (ae = (q = (0, ae.a)(q.getRequestMessage())).length, Te = [0, 0, 0, 0], ue = new Uint8Array(5 + ae), de = 3; 0 <= de; de--)
            Te[de] = ae % 256, ae >>>= 8;
          if (ue.set(new Uint8Array(Te), 1), ue.set(q, 5), q = ue, D.a == "text") {
            var ke;
            for (D = q, ke === void 0 && (ke = 0), Yt(), ke = Zt[ke], q = [], ae = 0; ae < D.length; ae += 3) {
              ve = D[ae];
              var xe = (Te = ae + 1 < D.length) ? D[ae + 1] : 0;
              de = ve >> 2, ve = (3 & ve) << 4 | xe >> 4, xe = (15 & xe) << 2 | (Se = (ue = ae + 2 < D.length) ? D[ae + 2] : 0) >> 6, Se &= 63, ue || (Se = 64, Te || (xe = 64)), q.push(ke[de], ke[ve], ke[xe] || "", ke[Se] || "");
            }
            q = q.join("");
          } else
            D.a == "binary" && (te.j = "arraybuffer");
          return nn(te, ge, q), me;
        }
        function Kt(D, q, te) {
          var ae = null, ge = !1;
          D.on("data", function(me) {
            ae = me;
          }), D.on("error", function(me) {
            me.code == 0 || ge || (ge = !0, q(me, null));
          }), D.on("status", function(me) {
            me.code == 0 || ge ? te && q(null, null, me) : (ge = !0, q({ code: me.code, message: me.details, metadata: me.metadata }, null));
          }), te && D.on("metadata", function(me) {
            q(null, null, null, me);
          }), D.on("end", function() {
            ge || (ae == null ? q({ code: 2, message: "Incomplete response" }) : q(null, ae)), te && q(null, null);
          });
        }
        function Pt(D, q) {
          var te = D;
          return q.forEach(function(ae) {
            var ge = te;
            te = function(me) {
              return ae.intercept(me, ge);
            };
          }), te;
        }
        ut.prototype.on = function(D, q) {
          return D == "data" ? this.b.push(q) : D == "status" ? this.h.push(q) : D == "metadata" ? this.g.push(q) : D == "end" ? this.c.push(q) : D == "error" && this.f.push(q), this;
        }, ut.prototype.removeListener = function(D, q) {
          return D == "data" ? Rt(this.b, q) : D == "status" ? Rt(this.h, q) : D == "metadata" ? Rt(this.g, q) : D == "end" ? Rt(this.c, q) : D == "error" && Rt(this.f, q), this;
        }, ut.prototype.cancel = function() {
          this.j = !0, this.a.abort();
        }, ut.prototype.cancel = ut.prototype.cancel, ut.prototype.removeListener = ut.prototype.removeListener, ut.prototype.on = ut.prototype.on, nt.prototype.P = function(D, q, te, ae, ge) {
          var me = this;
          ae = Z(D, q, "unary", ae);
          var ue = D.substr(0, D.length - ae.name.length);
          return Kt(D = Pt(function(de) {
            return xt(me, de, ue);
          }, this.b).call(this, $(ae, q, te)), ge, !1), new _(D);
        }, nt.prototype.M = function(D, q, te, ae) {
          var ge = this;
          ae = Z(D, q, "unary", ae);
          var me = D.substr(0, D.length - ae.name.length);
          return Pt(function(ue) {
            return new Promise(function(de, Se) {
              var ve, Te, ke;
              Kt(xt(ge, ue, me), function(xe, He, ze, We) {
                xe ? Se(xe) : He ? ke = He : ze ? Te = ze : We ? ve = We : (xe = ue.getMethodDescriptor(), de(new p(ke, xe, He = (He = ve) === void 0 ? {} : He, Te === void 0 ? null : Te)));
              }, !0);
            });
          }, this.g).call(this, $(ae, q, te)).then(function(ue) {
            return ue.getResponseMessage();
          });
        }, nt.prototype.unaryCall = function(D, q, te, ae) {
          return this.M(D, q, te, ae);
        }, nt.prototype.R = function(D, q, te, ae) {
          var ge = this;
          ae = Z(D, q, "server_streaming", ae);
          var me = D.substr(0, D.length - ae.name.length);
          return Pt(function(ue) {
            return xt(ge, ue, me);
          }, this.b).call(this, $(ae, q, te));
        }, nt.prototype.serverStreaming = nt.prototype.R, nt.prototype.unaryCall = nt.prototype.unaryCall, nt.prototype.thenableCall = nt.prototype.M, nt.prototype.rpcCall = nt.prototype.P, e.exports.AbstractClientBase = { MethodInfo: function(D, q, te, ae, ge) {
          this.name = ae, this.b = ge, this.f = D, this.a = q, this.c = te;
        } }, e.exports.GrpcWebClientBase = nt, e.exports.StatusCode = { OK: 0, CANCELLED: 1, UNKNOWN: 2, INVALID_ARGUMENT: 3, DEADLINE_EXCEEDED: 4, NOT_FOUND: 5, ALREADY_EXISTS: 6, PERMISSION_DENIED: 7, UNAUTHENTICATED: 16, RESOURCE_EXHAUSTED: 8, FAILED_PRECONDITION: 9, ABORTED: 10, OUT_OF_RANGE: 11, UNIMPLEMENTED: 12, INTERNAL: 13, UNAVAILABLE: 14, DATA_LOSS: 15 }, e.exports.MethodDescriptor = M, e.exports.MethodType = { UNARY: "unary", SERVER_STREAMING: "server_streaming" };
      }).call(this, n(6));
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.isAsyncIterable = t.isAsyncGenerator = t.isAsync = void 0;
      var r, o = n(152), l = (r = o) && r.__esModule ? r : { default: r };
      function u(s) {
        return s[Symbol.toStringTag] === "AsyncFunction";
      }
      t.default = function(s) {
        if (typeof s != "function")
          throw new Error("expected a function");
        return u(s) ? (0, l.default)(s) : s;
      }, t.isAsync = u, t.isAsyncGenerator = function(s) {
        return s[Symbol.toStringTag] === "AsyncGenerator";
      }, t.isAsyncIterable = function(s) {
        return typeof s[Symbol.asyncIterator] == "function";
      };
    }, function(e, t, n) {
      var r = {};
      function o(u, s, g) {
        g || (g = Error);
        var c = function(d) {
          var T, b;
          function h(f, v, E) {
            return d.call(this, function(j, B, I) {
              return typeof s == "string" ? s : s(j, B, I);
            }(f, v, E)) || this;
          }
          return b = d, (T = h).prototype = Object.create(b.prototype), T.prototype.constructor = T, T.__proto__ = b, h;
        }(g);
        c.prototype.name = g.name, c.prototype.code = u, r[u] = c;
      }
      function l(u, s) {
        if (Array.isArray(u)) {
          var g = u.length;
          return u = u.map(function(c) {
            return String(c);
          }), g > 2 ? "one of ".concat(s, " ").concat(u.slice(0, g - 1).join(", "), ", or ") + u[g - 1] : g === 2 ? "one of ".concat(s, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(s, " ").concat(u[0]);
        }
        return "of ".concat(s, " ").concat(String(u));
      }
      o("ERR_INVALID_OPT_VALUE", function(u, s) {
        return 'The value "' + s + '" is invalid for option "' + u + '"';
      }, TypeError), o("ERR_INVALID_ARG_TYPE", function(u, s, g) {
        var c, d, T;
        if (typeof s == "string" && (d = "not ", s.substr(0, d.length) === d) ? (c = "must not be", s = s.replace(/^not /, "")) : c = "must be", function(h, f, v) {
          return (v === void 0 || v > h.length) && (v = h.length), h.substring(v - f.length, v) === f;
        }(u, " argument"))
          T = "The ".concat(u, " ").concat(c, " ").concat(l(s, "type"));
        else {
          var b = function(h, f, v) {
            return typeof v != "number" && (v = 0), !(v + f.length > h.length) && h.indexOf(f, v) !== -1;
          }(u, ".") ? "property" : "argument";
          T = 'The "'.concat(u, '" ').concat(b, " ").concat(c, " ").concat(l(s, "type"));
        }
        return T += ". Received type ".concat(typeof g);
      }, TypeError), o("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), o("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
        return "The " + u + " method is not implemented";
      }), o("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), o("ERR_STREAM_DESTROYED", function(u) {
        return "Cannot call " + u + " after a stream was destroyed";
      }), o("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), o("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), o("ERR_STREAM_WRITE_AFTER_END", "write after end"), o("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), o("ERR_UNKNOWN_ENCODING", function(u) {
        return "Unknown encoding: " + u;
      }, TypeError), o("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e.exports.codes = r;
    }, function(e, t, n) {
      (function(r) {
        var o = Object.keys || function(h) {
          var f = [];
          for (var v in h)
            f.push(v);
          return f;
        };
        e.exports = d;
        var l = n(77), u = n(81);
        n(7)(d, l);
        for (var s = o(u.prototype), g = 0; g < s.length; g++) {
          var c = s[g];
          d.prototype[c] || (d.prototype[c] = u.prototype[c]);
        }
        function d(h) {
          if (!(this instanceof d))
            return new d(h);
          l.call(this, h), u.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", T)));
        }
        function T() {
          this._writableState.ended || r.nextTick(b, this);
        }
        function b(h) {
          h.end();
        }
        Object.defineProperty(d.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(d.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(d.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(d.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(h) {
          this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = h, this._writableState.destroyed = h);
        } });
      }).call(this, n(2));
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return u;
      });
      var r = n(40), o = n(4);
      const l = { "app-id": ["app-id must match formant/*"] };
      class u extends r.a {
        constructor(g, c = {}) {
          super(g, Object.assign({ validateHeaders: (d) => `${d.get("app-id")}`.startsWith("formant/") ? {} : l }, c)), this.endpoint = g;
        }
        getHeaders() {
          return Object.assign(Object.assign({}, u.headers), { "App-ID": `formant/${o.a}`, "App-Version": o.j });
        }
      }
      u.headers = {};
    }, function(e, t, n) {
      n(227), e.exports = { encode: (r) => new TextEncoder().encode(r), decode: (r) => new TextDecoder().decode(r) };
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r, o = r.length) {
        if (!o)
          throw new Error("arity is undefined");
        return function(...l) {
          return typeof l[o - 1] == "function" ? r.apply(this, l) : new Promise((u, s) => {
            l[o - 1] = (g, ...c) => {
              if (g)
                return s(g);
              u(c.length > 1 ? c : c[0]);
            }, r.apply(this, l);
          });
        };
      }, e.exports = t.default;
    }, function(e, t, n) {
      (t = e.exports = n(69)).Stream = t, t.Readable = t, t.Writable = n(48), t.Duplex = n(23), t.Transform = n(72), t.PassThrough = n(165);
    }, function(e, t, n) {
      (t = e.exports = n(77)).Stream = t, t.Readable = t, t.Writable = n(81), t.Duplex = n(27), t.Transform = n(82), t.PassThrough = n(184), t.finished = n(49), t.pipeline = n(185);
    }, function(e, t, n) {
      e.exports = function(r) {
        return r;
      };
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return o;
      });
      const r = ["password", "secret", "token", "key", "buffer"];
      function o(l, u = /* @__PURE__ */ new Set()) {
        return u.has(l) ? "[ RECURSIVE ]" : !(s = l) || typeof s != "object" && typeof s != "function" ? l : (u.add(l), Object.keys(l).reduce((g, c) => (g[c] = r.some((d) => c.toLowerCase().includes(d.toLowerCase())) ? "[ REDACTED ]" : o(l[c], u), g), {}));
        var s;
      }
    }, function(e, t) {
      e.exports = r, r.default = r, r.stable = l, r.stableStringify = l;
      var n = [];
      function r(u, s, g) {
        (function T(b, h, f, v) {
          var E;
          if (typeof b == "object" && b !== null) {
            for (E = 0; E < f.length; E++)
              if (f[E] === b)
                return v[h] = "[Circular]", void n.push([v, h, b]);
            if (f.push(b), Array.isArray(b))
              for (E = 0; E < b.length; E++)
                T(b[E], E, f, b);
            else {
              var j = Object.keys(b);
              for (E = 0; E < j.length; E++) {
                var B = j[E];
                T(b[B], B, f, b);
              }
            }
            f.pop();
          }
        })(u, "", [], void 0);
        for (var c = JSON.stringify(u, s, g); n.length !== 0; ) {
          var d = n.pop();
          d[0][d[1]] = d[2];
        }
        return c;
      }
      function o(u, s) {
        return u < s ? -1 : u > s ? 1 : 0;
      }
      function l(u, s, g) {
        for (var c = function b(h, f, v, E) {
          var j;
          if (typeof h == "object" && h !== null) {
            for (j = 0; j < v.length; j++)
              if (v[j] === h)
                return E[f] = "[Circular]", void n.push([E, f, h]);
            if (typeof h.toJSON == "function")
              return;
            if (v.push(h), Array.isArray(h))
              for (j = 0; j < h.length; j++)
                b(h[j], j, v, h);
            else {
              var B = {}, I = Object.keys(h).sort(o);
              for (j = 0; j < I.length; j++) {
                var R = I[j];
                b(h[R], R, v, h), B[R] = h[R];
              }
              if (E === void 0)
                return B;
              n.push([E, f, h]), E[f] = B;
            }
            v.pop();
          }
        }(u, "", [], void 0) || u, d = JSON.stringify(c, s, g); n.length !== 0; ) {
          var T = n.pop();
          T[0][T[1]] = T[2];
        }
        return d;
      }
    }, function(e, t, n) {
      var r = n(16), o = Object.keys || function(f) {
        var v = [];
        for (var E in f)
          v.push(E);
        return v;
      };
      e.exports = T;
      var l = Object.create(n(17));
      l.inherits = n(7);
      var u = n(143), s = n(62);
      l.inherits(T, u);
      for (var g = o(s.prototype), c = 0; c < g.length; c++) {
        var d = g[c];
        T.prototype[d] || (T.prototype[d] = s.prototype[d]);
      }
      function T(f) {
        if (!(this instanceof T))
          return new T(f);
        u.call(this, f), s.call(this, f), f && f.readable === !1 && (this.readable = !1), f && f.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, f && f.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", b);
      }
      function b() {
        this.allowHalfOpen || this._writableState.ended || r.nextTick(h, this);
      }
      function h(f) {
        f.end();
      }
      Object.defineProperty(T.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(T.prototype, "destroyed", { get: function() {
        return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(f) {
        this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = f, this._writableState.destroyed = f);
      } }), T.prototype._destroy = function(f, v) {
        this.push(null), this.end(), r.nextTick(v, f);
      };
    }, function(e, t, n) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      function o(s, g) {
        return Object.prototype.hasOwnProperty.call(s, g);
      }
      t.assign = function(s) {
        for (var g = Array.prototype.slice.call(arguments, 1); g.length; ) {
          var c = g.shift();
          if (c) {
            if (typeof c != "object")
              throw new TypeError(c + "must be non-object");
            for (var d in c)
              o(c, d) && (s[d] = c[d]);
          }
        }
        return s;
      }, t.shrinkBuf = function(s, g) {
        return s.length === g ? s : s.subarray ? s.subarray(0, g) : (s.length = g, s);
      };
      var l = { arraySet: function(s, g, c, d, T) {
        if (g.subarray && s.subarray)
          s.set(g.subarray(c, c + d), T);
        else
          for (var b = 0; b < d; b++)
            s[T + b] = g[c + b];
      }, flattenChunks: function(s) {
        var g, c, d, T, b, h;
        for (d = 0, g = 0, c = s.length; g < c; g++)
          d += s[g].length;
        for (h = new Uint8Array(d), T = 0, g = 0, c = s.length; g < c; g++)
          b = s[g], h.set(b, T), T += b.length;
        return h;
      } }, u = { arraySet: function(s, g, c, d, T) {
        for (var b = 0; b < d; b++)
          s[T + b] = g[c + b];
      }, flattenChunks: function(s) {
        return [].concat.apply([], s);
      } };
      t.setTyped = function(s) {
        s ? (t.Buf8 = Uint8Array, t.Buf16 = Uint16Array, t.Buf32 = Int32Array, t.assign(t, l)) : (t.Buf8 = Array, t.Buf16 = Array, t.Buf32 = Array, t.assign(t, u));
      }, t.setTyped(r);
    }, function(e, t, n) {
      e.exports = n(186);
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return o;
      });
      var r = n(229);
      const o = Object(r.a)();
    }, function(e, t, n) {
      n.d(t, "a", function() {
        return j;
      });
      var r = n(1), o = n(100), l = n.n(o), u = n(101), s = n.n(u);
      class g extends Error {
        constructor(I, R, p) {
          super(`Connection failure: ${I.message}`), this.cause = I, this.url = R, this.retryable = p;
        }
      }
      var c = n(10);
      class d extends Error {
        constructor(I, R) {
          super(`Invalid headers (${JSON.stringify(I)}) for response: ${R.message}`), this.validationErrors = I, this.responseError = R;
        }
      }
      var T = n(8), b = n(0), h = n(11), f = function(B, I, R, p) {
        return new (R || (R = Promise))(function(M, $) {
          function Z(C) {
            try {
              y(p.next(C));
            } catch (w) {
              $(w);
            }
          }
          function _(C) {
            try {
              y(p.throw(C));
            } catch (w) {
              $(w);
            }
          }
          function y(C) {
            var w;
            C.done ? M(C.value) : (w = C.value, w instanceof R ? w : new R(function(x) {
              x(w);
            })).then(Z, _);
          }
          y((p = p.apply(B, I || [])).next());
        });
      }, v = function(B, I) {
        var R = {};
        for (var p in B)
          Object.prototype.hasOwnProperty.call(B, p) && I.indexOf(p) < 0 && (R[p] = B[p]);
        if (B != null && typeof Object.getOwnPropertySymbols == "function") {
          var M = 0;
          for (p = Object.getOwnPropertySymbols(B); M < p.length; M++)
            I.indexOf(p[M]) < 0 && Object.prototype.propertyIsEnumerable.call(B, p[M]) && (R[p[M]] = B[p[M]]);
        }
        return R;
      };
      const E = /* @__PURE__ */ new Set(["GET", "HEAD", "PUT", "QUERY", "DELETE", "OPTIONS", "TRACE"]);
      class j {
        constructor(I, R = {}) {
          if (this.endpoint = I, this.validateHeaders = (p) => R.validateHeaders ? R.validateHeaders(p) : {}, this.verbose = R.verbose !== !1, R.retries !== void 0 && !(R.retries >= 0))
            throw new Error("retries must be positive or zero");
          if (this.configuredRetries = R.retries, R.timeoutMs !== void 0 && !(R.timeoutMs > 0))
            throw new Error("timeoutMs must be positive");
          if (this.timeoutMs = R.timeoutMs, R.maxBackoffDelayMs !== void 0 && !(R.maxBackoffDelayMs > 0))
            throw new Error("maxBackoffDelayMs must be positive");
          this.maxBackoffDelayMs = R.maxBackoffDelayMs || 30 * r.a.second;
        }
        getRetries() {
          return this.configuredRetries !== void 0 ? this.configuredRetries : this.getConstructor().retries;
        }
        getHeaders() {
          return {};
        }
        fetch(I, R = {}) {
          return f(this, void 0, void 0, function* () {
            return (yield this.fetchVerbose(I, R)).body;
          });
        }
        fetchVerbose(I, R = {}) {
          return f(this, void 0, void 0, function* () {
            let p = 100 * r.a.millisecond, M = 0;
            const $ = this.timeoutMs !== void 0 ? (/* @__PURE__ */ new Date()).getTime() + this.timeoutMs : void 0, Z = $ ? () => Math.max($ - (/* @__PURE__ */ new Date()).getTime(), 0) : void 0;
            for (; ; )
              try {
                return yield this.doFetch(I, R, Z);
              } catch (_) {
                const y = _, C = Object(h.a)(y, g);
                if ((Z == null ? void 0 : Z()) === 0 || M === this.getRetries() || !C.retryable)
                  throw C;
                M++, p = Math.min(...Z ? [Z()] : [], p * (2 + 0.1 * (Math.random() - 0.5)), this.maxBackoffDelayMs), yield Object(T.a)(p), this.verbose && b.a.warn(`Connection failure, retrying. Error: ${y.cause.message}`, { url: y.url, error: y.cause, attempt: M });
              }
          });
        }
        doFetch(I, R, p) {
          return f(this, void 0, void 0, function* () {
            const { token: M, json: $, allowUnsafeRetries: Z } = R, _ = v(R, ["token", "json", "allowUnsafeRetries"]), y = (_.method || "GET").toUpperCase(), C = this.endpoint !== void 0 ? `${this.endpoint}${I ? `/${I}` : ""}` : I, w = new l.a();
            let x;
            if (p) {
              const H = p();
              H > 0 ? x = setTimeout(() => {
                w.abort();
              }, H) : w.abort();
            }
            try {
              let H;
              yield Promise.race([this.getConstructor().waitForConnectivity(), new Promise((F) => {
                H = setTimeout(F, p ? Math.min(r.a.minute, p()) : r.a.minute);
              })]), H && clearTimeout(H);
              const L = yield s()(C, Object.assign(Object.assign({}, _), { headers: Object.assign(Object.assign(Object.assign(Object.assign({}, $ !== !1 ? { "Content-Type": "application/json" } : {}), this.getHeaders()), _.headers || {}), M !== void 0 ? { Authorization: `Bearer ${M}` } : {}), signal: w.signal })), N = L.headers.get("content-type") || "", P = N && N.startsWith("application/json"), z = P ? yield L.json() : yield L.text(), O = () => new c.a(y, C, L.status, z, z && z.validationErrors || {}, L.headers);
              if (!L.ok)
                throw this.verbose && b.a[L.status >= 500 ? "warn" : "info"]("Response error", { method: y, url: C, statusCode: L.status }), O();
              const m = this.validateHeaders(L.headers);
              if (Object.keys(m).length !== 0)
                throw new d(m, O());
              if (L.status === 204)
                return { body: void 0, headers: L.headers };
              if ($ && !P)
                throw new Error(`Response is not JSON: ${JSON.stringify(z)}`);
              return { body: z, headers: L.headers };
            } catch (H) {
              const L = H, N = Z || E.has(y);
              if (L.message === "Network request failed")
                throw new g(L, C, N);
              if (L.type === "system" && ["EAI_AGAIN", "ECONNREFUSED", "EHOSTUNREACH", "ENOTFOUND"].find((m) => m === L.code))
                throw new g(L, C, !0);
              if (L.type === "system" && ["ETIMEDOUT", "ECONNRESET", "ESOCKETTIMEDOUT", "EPIPE"].find((m) => m === L.code))
                throw new g(L, C, N);
              if (L.name === "AbortError")
                throw new g(L, C, N);
              const P = Object(h.a)(L, c.a), { statusCode: z } = P;
              if (z === 408 || z === 429 || z === 502 || z === 503 || z === 504)
                throw this.verbose && !N && b.a.warn("Potentially unsafe retry"), new g(L, C, !0);
              const O = this.validateHeaders(P.headers);
              throw Object.keys(O).length !== 0 ? new d(O, P) : (yield this.getConstructor().onResponseError(P), L);
            } finally {
              x && clearTimeout(x);
            }
          });
        }
        getConstructor() {
          return Object.getPrototypeOf(this).constructor;
        }
      }
      j.retries = 8, j.waitForConnectivity = () => f(void 0, void 0, void 0, function* () {
      }), j.onResponseError = () => f(void 0, void 0, void 0, function* () {
      });
    }, function(e, t, n) {
      function r(T, b) {
        if (!(T instanceof b))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(T, b) {
        for (var h = 0; h < b.length; h++) {
          var f = b[h];
          f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(T, f.key, f);
        }
      }
      var l = n(59), u = n(3), s = u.LEVEL, g = u.MESSAGE;
      l.enabled = !0;
      var c = /\s+/, d = function() {
        function T() {
          var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          r(this, T), v.colors && this.addColors(v.colors), this.options = v;
        }
        var b, h, f;
        return b = T, f = [{ key: "addColors", value: function(v) {
          var E = Object.keys(v).reduce(function(j, B) {
            return j[B] = c.test(v[B]) ? v[B].split(c) : v[B], j;
          }, {});
          return T.allColors = Object.assign({}, T.allColors || {}, E), T.allColors;
        } }], (h = [{ key: "addColors", value: function(v) {
          return T.addColors(v);
        } }, { key: "colorize", value: function(v, E, j) {
          if (j === void 0 && (j = E), !Array.isArray(T.allColors[v]))
            return l[T.allColors[v]](j);
          for (var B = 0, I = T.allColors[v].length; B < I; B++)
            j = l[T.allColors[v][B]](j);
          return j;
        } }, { key: "transform", value: function(v, E) {
          return E.all && typeof v[g] == "string" && (v[g] = this.colorize(v[s], v.level, v[g])), (E.level || E.all || !E.message) && (v.level = this.colorize(v[s], v.level)), (E.all || E.message) && (v.message = this.colorize(v[s], v.level, v.message)), v;
        } }]) && o(b.prototype, h), f && o(b, f), T;
      }();
      e.exports = function(T) {
        return new d(T);
      }, e.exports.Colorizer = e.exports.Format = d;
    }, function(e, t) {
      var n = {}.toString;
      e.exports = Array.isArray || function(r) {
        return n.call(r) == "[object Array]";
      };
    }, function(e, t, n) {
      (function(r) {
        function o(l) {
          try {
            if (!r.localStorage)
              return !1;
          } catch {
            return !1;
          }
          var u = r.localStorage[l];
          return u != null && String(u).toLowerCase() === "true";
        }
        e.exports = function(l, u) {
          if (o("noDeprecation"))
            return l;
          var s = !1;
          return function() {
            if (!s) {
              if (o("throwDeprecation"))
                throw new Error(u);
              o("traceDeprecation") ? console.trace(u) : console.warn(u), s = !0;
            }
            return l.apply(this, arguments);
          };
        };
      }).call(this, n(6));
    }, function(e, t, n) {
      var r = n(5), o = r.Buffer;
      function l(s, g) {
        for (var c in s)
          g[c] = s[c];
      }
      function u(s, g, c) {
        return o(s, g, c);
      }
      o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = r : (l(r, t), t.Buffer = u), l(o, u), u.from = function(s, g, c) {
        if (typeof s == "number")
          throw new TypeError("Argument must not be a number");
        return o(s, g, c);
      }, u.alloc = function(s, g, c) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        var d = o(s);
        return g !== void 0 ? typeof c == "string" ? d.fill(g, c) : d.fill(g) : d.fill(0), d;
      }, u.allocUnsafe = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return o(s);
      }, u.allocUnsafeSlow = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return r.SlowBuffer(s);
      };
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        return r && typeof r.length == "number" && r.length >= 0 && r.length % 1 == 0;
      }, e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = {}, e.exports = t.default;
    }, function(e, t, n) {
      var r = n(5), o = r.Buffer;
      function l(s, g) {
        for (var c in s)
          g[c] = s[c];
      }
      function u(s, g, c) {
        return o(s, g, c);
      }
      o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = r : (l(r, t), t.Buffer = u), l(o, u), u.from = function(s, g, c) {
        if (typeof s == "number")
          throw new TypeError("Argument must not be a number");
        return o(s, g, c);
      }, u.alloc = function(s, g, c) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        var d = o(s);
        return g !== void 0 ? typeof c == "string" ? d.fill(g, c) : d.fill(g) : d.fill(0), d;
      }, u.allocUnsafe = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return o(s);
      }, u.allocUnsafeSlow = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return r.SlowBuffer(s);
      };
    }, function(e, t, n) {
      (function(r, o, l) {
        var u = n(16);
        function s(y) {
          var C = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(w, x, H) {
              var L = w.entry;
              for (w.entry = null; L; ) {
                var N = L.callback;
                x.pendingcb--, N(H), L = L.next;
              }
              x.corkedRequestsFree ? x.corkedRequestsFree.next = w : x.corkedRequestsFree = w;
            })(C, y);
          };
        }
        e.exports = I;
        var g, c = !r.browser && ["v0.10", "v0.9."].indexOf(r.version.slice(0, 5)) > -1 ? o : u.nextTick;
        I.WritableState = B;
        var d = n(17);
        d.inherits = n(7);
        var T = { deprecate: n(43) }, b = n(70), h = n(47).Buffer, f = l.Uint8Array || function() {
        }, v, E = n(71);
        function j() {
        }
        function B(y, C) {
          g = g || n(23), y = y || {};
          var w = C instanceof g;
          this.objectMode = !!y.objectMode, w && (this.objectMode = this.objectMode || !!y.writableObjectMode);
          var x = y.highWaterMark, H = y.writableHighWaterMark, L = this.objectMode ? 16 : 16384;
          this.highWaterMark = x || x === 0 ? x : w && (H || H === 0) ? H : L, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var N = y.decodeStrings === !1;
          this.decodeStrings = !N, this.defaultEncoding = y.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(P) {
            (function(z, O) {
              var m = z._writableState, F = m.sync, V = m.writecb;
              if (function(ee) {
                ee.writing = !1, ee.writecb = null, ee.length -= ee.writelen, ee.writelen = 0;
              }(m), O)
                (function(ee, ne, Y, G, S) {
                  --ne.pendingcb, Y ? (u.nextTick(S, G), u.nextTick(_, ee, ne), ee._writableState.errorEmitted = !0, ee.emit("error", G)) : (S(G), ee._writableState.errorEmitted = !0, ee.emit("error", G), _(ee, ne));
                })(z, m, F, O, V);
              else {
                var Q = $(m);
                Q || m.corked || m.bufferProcessing || !m.bufferedRequest || M(z, m), F ? c(p, z, m, Q, V) : p(z, m, Q, V);
              }
            })(C, P);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
        }
        function I(y) {
          if (g = g || n(23), !(v.call(I, this) || this instanceof g))
            return new I(y);
          this._writableState = new B(y, this), this.writable = !0, y && (typeof y.write == "function" && (this._write = y.write), typeof y.writev == "function" && (this._writev = y.writev), typeof y.destroy == "function" && (this._destroy = y.destroy), typeof y.final == "function" && (this._final = y.final)), b.call(this);
        }
        function R(y, C, w, x, H, L, N) {
          C.writelen = x, C.writecb = N, C.writing = !0, C.sync = !0, w ? y._writev(H, C.onwrite) : y._write(H, L, C.onwrite), C.sync = !1;
        }
        function p(y, C, w, x) {
          w || function(H, L) {
            L.length === 0 && L.needDrain && (L.needDrain = !1, H.emit("drain"));
          }(y, C), C.pendingcb--, x(), _(y, C);
        }
        function M(y, C) {
          C.bufferProcessing = !0;
          var w = C.bufferedRequest;
          if (y._writev && w && w.next) {
            var x = C.bufferedRequestCount, H = new Array(x), L = C.corkedRequestsFree;
            L.entry = w;
            for (var N = 0, P = !0; w; )
              H[N] = w, w.isBuf || (P = !1), w = w.next, N += 1;
            H.allBuffers = P, R(y, C, !0, C.length, H, "", L.finish), C.pendingcb++, C.lastBufferedRequest = null, L.next ? (C.corkedRequestsFree = L.next, L.next = null) : C.corkedRequestsFree = new s(C), C.bufferedRequestCount = 0;
          } else {
            for (; w; ) {
              var z = w.chunk, O = w.encoding, m = w.callback;
              if (R(y, C, !1, C.objectMode ? 1 : z.length, z, O, m), w = w.next, C.bufferedRequestCount--, C.writing)
                break;
            }
            w === null && (C.lastBufferedRequest = null);
          }
          C.bufferedRequest = w, C.bufferProcessing = !1;
        }
        function $(y) {
          return y.ending && y.length === 0 && y.bufferedRequest === null && !y.finished && !y.writing;
        }
        function Z(y, C) {
          y._final(function(w) {
            C.pendingcb--, w && y.emit("error", w), C.prefinished = !0, y.emit("prefinish"), _(y, C);
          });
        }
        function _(y, C) {
          var w = $(C);
          return w && (function(x, H) {
            H.prefinished || H.finalCalled || (typeof x._final == "function" ? (H.pendingcb++, H.finalCalled = !0, u.nextTick(Z, x, H)) : (H.prefinished = !0, x.emit("prefinish")));
          }(y, C), C.pendingcb === 0 && (C.finished = !0, y.emit("finish"))), w;
        }
        d.inherits(I, b), B.prototype.getBuffer = function() {
          for (var y = this.bufferedRequest, C = []; y; )
            C.push(y), y = y.next;
          return C;
        }, function() {
          try {
            Object.defineProperty(B.prototype, "buffer", { get: T.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (v = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: function(y) {
          return !!v.call(this, y) || this === I && y && y._writableState instanceof B;
        } })) : v = function(y) {
          return y instanceof this;
        }, I.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        }, I.prototype.write = function(y, C, w) {
          var x, H = this._writableState, L = !1, N = !H.objectMode && (x = y, h.isBuffer(x) || x instanceof f);
          return N && !h.isBuffer(y) && (y = function(P) {
            return h.from(P);
          }(y)), typeof C == "function" && (w = C, C = null), N ? C = "buffer" : C || (C = H.defaultEncoding), typeof w != "function" && (w = j), H.ended ? function(P, z) {
            var O = new Error("write after end");
            P.emit("error", O), u.nextTick(z, O);
          }(this, w) : (N || function(P, z, O, m) {
            var F = !0, V = !1;
            return O === null ? V = new TypeError("May not write null values to stream") : typeof O == "string" || O === void 0 || z.objectMode || (V = new TypeError("Invalid non-string/buffer chunk")), V && (P.emit("error", V), u.nextTick(m, V), F = !1), F;
          }(this, H, y, w)) && (H.pendingcb++, L = function(P, z, O, m, F, V) {
            if (!O) {
              var Q = function(G, S, A) {
                return G.objectMode || G.decodeStrings === !1 || typeof S != "string" || (S = h.from(S, A)), S;
              }(z, m, F);
              m !== Q && (O = !0, F = "buffer", m = Q);
            }
            var ee = z.objectMode ? 1 : m.length;
            z.length += ee;
            var ne = z.length < z.highWaterMark;
            if (ne || (z.needDrain = !0), z.writing || z.corked) {
              var Y = z.lastBufferedRequest;
              z.lastBufferedRequest = { chunk: m, encoding: F, isBuf: O, callback: V, next: null }, Y ? Y.next = z.lastBufferedRequest : z.bufferedRequest = z.lastBufferedRequest, z.bufferedRequestCount += 1;
            } else
              R(P, z, !1, ee, m, F, V);
            return ne;
          }(this, H, N, y, C, w)), L;
        }, I.prototype.cork = function() {
          this._writableState.corked++;
        }, I.prototype.uncork = function() {
          var y = this._writableState;
          y.corked && (y.corked--, y.writing || y.corked || y.finished || y.bufferProcessing || !y.bufferedRequest || M(this, y));
        }, I.prototype.setDefaultEncoding = function(y) {
          if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + y);
          return this._writableState.defaultEncoding = y, this;
        }, Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), I.prototype._write = function(y, C, w) {
          w(new Error("_write() is not implemented"));
        }, I.prototype._writev = null, I.prototype.end = function(y, C, w) {
          var x = this._writableState;
          typeof y == "function" ? (w = y, y = null, C = null) : typeof C == "function" && (w = C, C = null), y != null && this.write(y, C), x.corked && (x.corked = 1, this.uncork()), x.ending || x.finished || function(H, L, N) {
            L.ending = !0, _(H, L), N && (L.finished ? u.nextTick(N) : H.once("finish", N)), L.ended = !0, H.writable = !1;
          }(this, x, w);
        }, Object.defineProperty(I.prototype, "destroyed", { get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(y) {
          this._writableState && (this._writableState.destroyed = y);
        } }), I.prototype.destroy = E.destroy, I.prototype._undestroy = E.undestroy, I.prototype._destroy = function(y, C) {
          this.end(), C(y);
        };
      }).call(this, n(2), n(15).setImmediate, n(6));
    }, function(e, t, n) {
      var r = n(26).codes.ERR_STREAM_PREMATURE_CLOSE;
      function o() {
      }
      e.exports = function l(u, s, g) {
        if (typeof s == "function")
          return l(u, null, s);
        s || (s = {}), g = function(I) {
          var R = !1;
          return function() {
            if (!R) {
              R = !0;
              for (var p = arguments.length, M = new Array(p), $ = 0; $ < p; $++)
                M[$] = arguments[$];
              I.apply(this, M);
            }
          };
        }(g || o);
        var c = s.readable || s.readable !== !1 && u.readable, d = s.writable || s.writable !== !1 && u.writable, T = function() {
          u.writable || h();
        }, b = u._writableState && u._writableState.finished, h = function() {
          d = !1, b = !0, c || g.call(u);
        }, f = u._readableState && u._readableState.endEmitted, v = function() {
          c = !1, f = !0, d || g.call(u);
        }, E = function(I) {
          g.call(u, I);
        }, j = function() {
          var I;
          return c && !f ? (u._readableState && u._readableState.ended || (I = new r()), g.call(u, I)) : d && !b ? (u._writableState && u._writableState.ended || (I = new r()), g.call(u, I)) : void 0;
        }, B = function() {
          u.req.on("finish", h);
        };
        return function(I) {
          return I.setHeader && typeof I.abort == "function";
        }(u) ? (u.on("complete", h), u.on("abort", j), u.req ? B() : u.on("request", B)) : d && !u._writableState && (u.on("end", T), u.on("close", T)), u.on("end", v), u.on("finish", h), s.error !== !1 && u.on("error", E), u.on("close", j), function() {
          u.removeListener("complete", h), u.removeListener("abort", j), u.removeListener("request", B), u.req && u.req.removeListener("finish", h), u.removeListener("end", T), u.removeListener("close", T), u.removeListener("finish", h), u.removeListener("end", v), u.removeListener("error", E), u.removeListener("close", j);
        };
      };
    }, function(e, t, n) {
      var r = n(58), o = n(3).configs;
      t.cli = r.levels(o.cli), t.npm = r.levels(o.npm), t.syslog = r.levels(o.syslog), t.addColors = r.levels;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = s(n(203)), o = s(n(204)), l = s(n(25)), u = s(n(30));
      function s(g) {
        return g && g.__esModule ? g : { default: g };
      }
      t.default = (0, u.default)(function(g, c, d) {
        return (0, r.default)(g, (0, o.default)((0, l.default)(c)), d);
      }, 3), e.exports = t.default;
    }, function(e, t, n) {
      class r extends Error {
        constructor(l, ...u) {
          super(`env-var: ${l}`, ...u), Error.captureStackTrace && Error.captureStackTrace(this, r), this.name = "EnvVarError";
        }
      }
      e.exports = r;
    }, function(e, t, n) {
      e.exports = function(r) {
        const o = parseInt(r, 10);
        if (isNaN(o) || o.toString(10) !== r)
          throw new Error("should be a valid integer");
        return o;
      };
    }, function(e, t, n) {
      e.exports = function(r) {
        const o = parseFloat(r);
        if (isNaN(o) || o.toString() !== r)
          throw new Error("should be a valid float");
        return o;
      };
    }, function(e, t, n) {
      e.exports = function(r) {
        try {
          return JSON.parse(r);
        } catch {
          throw new Error("should be valid (parseable) JSON");
        }
      };
    }, function(e, t, n) {
      (function(r) {
        function o(s, g) {
          for (var c = 0, d = s.length - 1; d >= 0; d--) {
            var T = s[d];
            T === "." ? s.splice(d, 1) : T === ".." ? (s.splice(d, 1), c++) : c && (s.splice(d, 1), c--);
          }
          if (g)
            for (; c--; c)
              s.unshift("..");
          return s;
        }
        function l(s, g) {
          if (s.filter)
            return s.filter(g);
          for (var c = [], d = 0; d < s.length; d++)
            g(s[d], d, s) && c.push(s[d]);
          return c;
        }
        t.resolve = function() {
          for (var s = "", g = !1, c = arguments.length - 1; c >= -1 && !g; c--) {
            var d = c >= 0 ? arguments[c] : r.cwd();
            if (typeof d != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            d && (s = d + "/" + s, g = d.charAt(0) === "/");
          }
          return (g ? "/" : "") + (s = o(l(s.split("/"), function(T) {
            return !!T;
          }), !g).join("/")) || ".";
        }, t.normalize = function(s) {
          var g = t.isAbsolute(s), c = u(s, -1) === "/";
          return (s = o(l(s.split("/"), function(d) {
            return !!d;
          }), !g).join("/")) || g || (s = "."), s && c && (s += "/"), (g ? "/" : "") + s;
        }, t.isAbsolute = function(s) {
          return s.charAt(0) === "/";
        }, t.join = function() {
          var s = Array.prototype.slice.call(arguments, 0);
          return t.normalize(l(s, function(g, c) {
            if (typeof g != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return g;
          }).join("/"));
        }, t.relative = function(s, g) {
          function c(E) {
            for (var j = 0; j < E.length && E[j] === ""; j++)
              ;
            for (var B = E.length - 1; B >= 0 && E[B] === ""; B--)
              ;
            return j > B ? [] : E.slice(j, B - j + 1);
          }
          s = t.resolve(s).substr(1), g = t.resolve(g).substr(1);
          for (var d = c(s.split("/")), T = c(g.split("/")), b = Math.min(d.length, T.length), h = b, f = 0; f < b; f++)
            if (d[f] !== T[f]) {
              h = f;
              break;
            }
          var v = [];
          for (f = h; f < d.length; f++)
            v.push("..");
          return (v = v.concat(T.slice(h))).join("/");
        }, t.sep = "/", t.delimiter = ":", t.dirname = function(s) {
          if (typeof s != "string" && (s += ""), s.length === 0)
            return ".";
          for (var g = s.charCodeAt(0), c = g === 47, d = -1, T = !0, b = s.length - 1; b >= 1; --b)
            if ((g = s.charCodeAt(b)) === 47) {
              if (!T) {
                d = b;
                break;
              }
            } else
              T = !1;
          return d === -1 ? c ? "/" : "." : c && d === 1 ? "/" : s.slice(0, d);
        }, t.basename = function(s, g) {
          var c = function(d) {
            typeof d != "string" && (d += "");
            var T, b = 0, h = -1, f = !0;
            for (T = d.length - 1; T >= 0; --T)
              if (d.charCodeAt(T) === 47) {
                if (!f) {
                  b = T + 1;
                  break;
                }
              } else
                h === -1 && (f = !1, h = T + 1);
            return h === -1 ? "" : d.slice(b, h);
          }(s);
          return g && c.substr(-1 * g.length) === g && (c = c.substr(0, c.length - g.length)), c;
        }, t.extname = function(s) {
          typeof s != "string" && (s += "");
          for (var g = -1, c = 0, d = -1, T = !0, b = 0, h = s.length - 1; h >= 0; --h) {
            var f = s.charCodeAt(h);
            if (f !== 47)
              d === -1 && (T = !1, d = h + 1), f === 46 ? g === -1 ? g = h : b !== 1 && (b = 1) : g !== -1 && (b = -1);
            else if (!T) {
              c = h + 1;
              break;
            }
          }
          return g === -1 || d === -1 || b === 0 || b === 1 && g === d - 1 && g === c + 1 ? "" : s.slice(g, d);
        };
        var u = "ab".substr(-1) === "b" ? function(s, g, c) {
          return s.substr(g, c);
        } : function(s, g, c) {
          return g < 0 && (g = s.length + g), s.substr(g, c);
        };
      }).call(this, n(2));
    }, , function(e, t, n) {
      var r = t.format = n(12);
      t.levels = n(105), Object.defineProperty(r, "align", { value: n(122) }), Object.defineProperty(r, "cli", { value: n(123) }), Object.defineProperty(r, "combine", { value: n(124) }), Object.defineProperty(r, "colorize", { value: n(41) }), Object.defineProperty(r, "json", { value: n(125) }), Object.defineProperty(r, "label", { value: n(128) }), Object.defineProperty(r, "logstash", { value: n(129) }), Object.defineProperty(r, "metadata", { value: n(130) }), Object.defineProperty(r, "padLevels", { value: n(60) }), Object.defineProperty(r, "prettyPrint", { value: n(131) }), Object.defineProperty(r, "printf", { value: n(132) }), Object.defineProperty(r, "simple", { value: n(133) }), Object.defineProperty(r, "splat", { value: n(134) }), Object.defineProperty(r, "timestamp", { value: n(135) }), Object.defineProperty(r, "uncolorize", { value: n(137) });
    }, function(e, t, n) {
      var r = n(106);
      e.exports = r;
    }, function(e, t, n) {
      function r(b) {
        return function(h) {
          if (Array.isArray(h))
            return o(h);
        }(b) || function(h) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(h))
            return Array.from(h);
        }(b) || function(h, f) {
          if (h) {
            if (typeof h == "string")
              return o(h, f);
            var v = Object.prototype.toString.call(h).slice(8, -1);
            if (v === "Object" && h.constructor && (v = h.constructor.name), v === "Map" || v === "Set")
              return Array.from(h);
            if (v === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(v))
              return o(h, f);
          }
        }(b) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function o(b, h) {
        (h == null || h > b.length) && (h = b.length);
        for (var f = 0, v = new Array(h); f < h; f++)
          v[f] = b[f];
        return v;
      }
      function l(b, h) {
        if (!(b instanceof h))
          throw new TypeError("Cannot call a class as a function");
      }
      function u(b, h) {
        for (var f = 0; f < h.length; f++) {
          var v = h[f];
          v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(b, v.key, v);
        }
      }
      var s = n(3), g = s.configs, c = s.LEVEL, d = s.MESSAGE, T = function() {
        function b() {
          var E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { levels: g.npm.levels };
          l(this, b), this.paddings = b.paddingForLevels(E.levels, E.filler), this.options = E;
        }
        var h, f, v;
        return h = b, v = [{ key: "getLongestLevel", value: function(E) {
          var j = Object.keys(E).map(function(B) {
            return B.length;
          });
          return Math.max.apply(Math, r(j));
        } }, { key: "paddingForLevel", value: function(E, j, B) {
          var I = B + 1 - E.length, R = Math.floor(I / j.length);
          return "".concat(j).concat(j.repeat(R)).slice(0, I);
        } }, { key: "paddingForLevels", value: function(E) {
          var j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ", B = b.getLongestLevel(E);
          return Object.keys(E).reduce(function(I, R) {
            return I[R] = b.paddingForLevel(R, j, B), I;
          }, {});
        } }], (f = [{ key: "transform", value: function(E, j) {
          return E.message = "".concat(this.paddings[E[c]]).concat(E.message), E[d] && (E[d] = "".concat(this.paddings[E[c]]).concat(E[d])), E;
        } }]) && u(h.prototype, f), v && u(h, v), b;
      }();
      e.exports = function(b) {
        return new T(b);
      }, e.exports.Padder = e.exports.Format = T;
    }, function(e, t, n) {
      var r = n(13).format;
      t.warn = { deprecated: function(o) {
        return function() {
          throw new Error(r("{ %s } was removed in winston@3.0.0.", o));
        };
      }, useFormat: function(o) {
        return function() {
          throw new Error([r("{ %s } was removed in winston@3.0.0.", o), "Use a custom winston.format = winston.format(function) instead."].join(`
`));
        };
      }, forFunctions: function(o, l, u) {
        u.forEach(function(s) {
          o[s] = t.warn[l](s);
        });
      }, moved: function(o, l, u) {
        function s() {
          return function() {
            throw new Error([r("winston.%s was moved in winston@3.0.0.", u), r("Use a winston.%s instead.", l)].join(`
`));
          };
        }
        Object.defineProperty(o, u, { get: s, set: s });
      }, forProperties: function(o, l, u) {
        u.forEach(function(s) {
          var g = t.warn[l](s);
          Object.defineProperty(o, s, { get: g, set: g });
        });
      } };
    }, function(e, t, n) {
      (function(r, o, l) {
        var u = n(16);
        function s(y) {
          var C = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(w, x, H) {
              var L = w.entry;
              for (w.entry = null; L; ) {
                var N = L.callback;
                x.pendingcb--, N(H), L = L.next;
              }
              x.corkedRequestsFree ? x.corkedRequestsFree.next = w : x.corkedRequestsFree = w;
            })(C, y);
          };
        }
        e.exports = I;
        var g, c = !r.browser && ["v0.10", "v0.9."].indexOf(r.version.slice(0, 5)) > -1 ? o : u.nextTick;
        I.WritableState = B;
        var d = Object.create(n(17));
        d.inherits = n(7);
        var T = { deprecate: n(43) }, b = n(63), h = n(44).Buffer, f = l.Uint8Array || function() {
        }, v, E = n(64);
        function j() {
        }
        function B(y, C) {
          g = g || n(36), y = y || {};
          var w = C instanceof g;
          this.objectMode = !!y.objectMode, w && (this.objectMode = this.objectMode || !!y.writableObjectMode);
          var x = y.highWaterMark, H = y.writableHighWaterMark, L = this.objectMode ? 16 : 16384;
          this.highWaterMark = x || x === 0 ? x : w && (H || H === 0) ? H : L, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var N = y.decodeStrings === !1;
          this.decodeStrings = !N, this.defaultEncoding = y.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(P) {
            (function(z, O) {
              var m = z._writableState, F = m.sync, V = m.writecb;
              if (function(ee) {
                ee.writing = !1, ee.writecb = null, ee.length -= ee.writelen, ee.writelen = 0;
              }(m), O)
                (function(ee, ne, Y, G, S) {
                  --ne.pendingcb, Y ? (u.nextTick(S, G), u.nextTick(_, ee, ne), ee._writableState.errorEmitted = !0, ee.emit("error", G)) : (S(G), ee._writableState.errorEmitted = !0, ee.emit("error", G), _(ee, ne));
                })(z, m, F, O, V);
              else {
                var Q = $(m);
                Q || m.corked || m.bufferProcessing || !m.bufferedRequest || M(z, m), F ? c(p, z, m, Q, V) : p(z, m, Q, V);
              }
            })(C, P);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
        }
        function I(y) {
          if (g = g || n(36), !(v.call(I, this) || this instanceof g))
            return new I(y);
          this._writableState = new B(y, this), this.writable = !0, y && (typeof y.write == "function" && (this._write = y.write), typeof y.writev == "function" && (this._writev = y.writev), typeof y.destroy == "function" && (this._destroy = y.destroy), typeof y.final == "function" && (this._final = y.final)), b.call(this);
        }
        function R(y, C, w, x, H, L, N) {
          C.writelen = x, C.writecb = N, C.writing = !0, C.sync = !0, w ? y._writev(H, C.onwrite) : y._write(H, L, C.onwrite), C.sync = !1;
        }
        function p(y, C, w, x) {
          w || function(H, L) {
            L.length === 0 && L.needDrain && (L.needDrain = !1, H.emit("drain"));
          }(y, C), C.pendingcb--, x(), _(y, C);
        }
        function M(y, C) {
          C.bufferProcessing = !0;
          var w = C.bufferedRequest;
          if (y._writev && w && w.next) {
            var x = C.bufferedRequestCount, H = new Array(x), L = C.corkedRequestsFree;
            L.entry = w;
            for (var N = 0, P = !0; w; )
              H[N] = w, w.isBuf || (P = !1), w = w.next, N += 1;
            H.allBuffers = P, R(y, C, !0, C.length, H, "", L.finish), C.pendingcb++, C.lastBufferedRequest = null, L.next ? (C.corkedRequestsFree = L.next, L.next = null) : C.corkedRequestsFree = new s(C), C.bufferedRequestCount = 0;
          } else {
            for (; w; ) {
              var z = w.chunk, O = w.encoding, m = w.callback;
              if (R(y, C, !1, C.objectMode ? 1 : z.length, z, O, m), w = w.next, C.bufferedRequestCount--, C.writing)
                break;
            }
            w === null && (C.lastBufferedRequest = null);
          }
          C.bufferedRequest = w, C.bufferProcessing = !1;
        }
        function $(y) {
          return y.ending && y.length === 0 && y.bufferedRequest === null && !y.finished && !y.writing;
        }
        function Z(y, C) {
          y._final(function(w) {
            C.pendingcb--, w && y.emit("error", w), C.prefinished = !0, y.emit("prefinish"), _(y, C);
          });
        }
        function _(y, C) {
          var w = $(C);
          return w && (function(x, H) {
            H.prefinished || H.finalCalled || (typeof x._final == "function" ? (H.pendingcb++, H.finalCalled = !0, u.nextTick(Z, x, H)) : (H.prefinished = !0, x.emit("prefinish")));
          }(y, C), C.pendingcb === 0 && (C.finished = !0, y.emit("finish"))), w;
        }
        d.inherits(I, b), B.prototype.getBuffer = function() {
          for (var y = this.bufferedRequest, C = []; y; )
            C.push(y), y = y.next;
          return C;
        }, function() {
          try {
            Object.defineProperty(B.prototype, "buffer", { get: T.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (v = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: function(y) {
          return !!v.call(this, y) || this === I && y && y._writableState instanceof B;
        } })) : v = function(y) {
          return y instanceof this;
        }, I.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        }, I.prototype.write = function(y, C, w) {
          var x, H = this._writableState, L = !1, N = !H.objectMode && (x = y, h.isBuffer(x) || x instanceof f);
          return N && !h.isBuffer(y) && (y = function(P) {
            return h.from(P);
          }(y)), typeof C == "function" && (w = C, C = null), N ? C = "buffer" : C || (C = H.defaultEncoding), typeof w != "function" && (w = j), H.ended ? function(P, z) {
            var O = new Error("write after end");
            P.emit("error", O), u.nextTick(z, O);
          }(this, w) : (N || function(P, z, O, m) {
            var F = !0, V = !1;
            return O === null ? V = new TypeError("May not write null values to stream") : typeof O == "string" || O === void 0 || z.objectMode || (V = new TypeError("Invalid non-string/buffer chunk")), V && (P.emit("error", V), u.nextTick(m, V), F = !1), F;
          }(this, H, y, w)) && (H.pendingcb++, L = function(P, z, O, m, F, V) {
            if (!O) {
              var Q = function(G, S, A) {
                return G.objectMode || G.decodeStrings === !1 || typeof S != "string" || (S = h.from(S, A)), S;
              }(z, m, F);
              m !== Q && (O = !0, F = "buffer", m = Q);
            }
            var ee = z.objectMode ? 1 : m.length;
            z.length += ee;
            var ne = z.length < z.highWaterMark;
            if (ne || (z.needDrain = !0), z.writing || z.corked) {
              var Y = z.lastBufferedRequest;
              z.lastBufferedRequest = { chunk: m, encoding: F, isBuf: O, callback: V, next: null }, Y ? Y.next = z.lastBufferedRequest : z.bufferedRequest = z.lastBufferedRequest, z.bufferedRequestCount += 1;
            } else
              R(P, z, !1, ee, m, F, V);
            return ne;
          }(this, H, N, y, C, w)), L;
        }, I.prototype.cork = function() {
          this._writableState.corked++;
        }, I.prototype.uncork = function() {
          var y = this._writableState;
          y.corked && (y.corked--, y.writing || y.corked || y.finished || y.bufferProcessing || !y.bufferedRequest || M(this, y));
        }, I.prototype.setDefaultEncoding = function(y) {
          if (typeof y == "string" && (y = y.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((y + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + y);
          return this._writableState.defaultEncoding = y, this;
        }, Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), I.prototype._write = function(y, C, w) {
          w(new Error("_write() is not implemented"));
        }, I.prototype._writev = null, I.prototype.end = function(y, C, w) {
          var x = this._writableState;
          typeof y == "function" ? (w = y, y = null, C = null) : typeof C == "function" && (w = C, C = null), y != null && this.write(y, C), x.corked && (x.corked = 1, this.uncork()), x.ending || x.finished || function(H, L, N) {
            L.ending = !0, _(H, L), N && (L.finished ? u.nextTick(N) : H.once("finish", N)), L.ended = !0, H.writable = !1;
          }(this, x, w);
        }, Object.defineProperty(I.prototype, "destroyed", { get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(y) {
          this._writableState && (this._writableState.destroyed = y);
        } }), I.prototype.destroy = E.destroy, I.prototype._undestroy = E.undestroy, I.prototype._destroy = function(y, C) {
          this.end(), C(y);
        };
      }).call(this, n(2), n(15).setImmediate, n(6));
    }, function(e, t, n) {
      e.exports = n(21).EventEmitter;
    }, function(e, t, n) {
      var r = n(16);
      function o(l, u) {
        l.emit("error", u);
      }
      e.exports = { destroy: function(l, u) {
        var s = this, g = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
        return g || c ? (u ? u(l) : !l || this._writableState && this._writableState.errorEmitted || r.nextTick(o, this, l), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(l || null, function(d) {
          !u && d ? (r.nextTick(o, s, d), s._writableState && (s._writableState.errorEmitted = !0)) : u && u(d);
        }), this);
      }, undestroy: function() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
      } };
    }, function(e, t) {
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = u(n(156)), o = u(n(25)), l = u(n(30));
      function u(s) {
        return s && s.__esModule ? s : { default: s };
      }
      t.default = (0, l.default)(function(s, g, c, d) {
        return (0, r.default)(g)(s, (0, o.default)(c), d);
      }, 4), e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        function o(...l) {
          if (r !== null) {
            var u = r;
            r = null, u.apply(this, l);
          }
        }
        return Object.assign(o, r), o;
      }, e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        return function(...o) {
          if (r === null)
            throw new Error("Callback was already called.");
          var l = r;
          r = null, l.apply(this, o);
        };
      }, e.exports = t.default;
    }, function(e, t, n) {
      (function(r, o) {
        var l = n(16);
        e.exports = R;
        var u, s = n(42);
        R.ReadableState = I, n(21).EventEmitter;
        var g = function(O, m) {
          return O.listeners(m).length;
        }, c = n(70), d = n(47).Buffer, T = r.Uint8Array || function() {
        }, b = n(17);
        b.inherits = n(7);
        var h = n(162), f = void 0;
        f = h && h.debuglog ? h.debuglog("stream") : function() {
        };
        var v, E = n(163), j = n(71);
        b.inherits(R, c);
        var B = ["error", "close", "destroy", "pause", "resume"];
        function I(O, m) {
          O = O || {};
          var F = m instanceof (u = u || n(23));
          this.objectMode = !!O.objectMode, F && (this.objectMode = this.objectMode || !!O.readableObjectMode);
          var V = O.highWaterMark, Q = O.readableHighWaterMark, ee = this.objectMode ? 16 : 16384;
          this.highWaterMark = V || V === 0 ? V : F && (Q || Q === 0) ? Q : ee, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new E(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = O.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, O.encoding && (v || (v = n(22).StringDecoder), this.decoder = new v(O.encoding), this.encoding = O.encoding);
        }
        function R(O) {
          if (u = u || n(23), !(this instanceof R))
            return new R(O);
          this._readableState = new I(O, this), this.readable = !0, O && (typeof O.read == "function" && (this._read = O.read), typeof O.destroy == "function" && (this._destroy = O.destroy)), c.call(this);
        }
        function p(O, m, F, V, Q) {
          var ee, ne = O._readableState;
          return m === null ? (ne.reading = !1, function(Y, G) {
            if (!G.ended) {
              if (G.decoder) {
                var S = G.decoder.end();
                S && S.length && (G.buffer.push(S), G.length += G.objectMode ? 1 : S.length);
              }
              G.ended = !0, Z(Y);
            }
          }(O, ne)) : (Q || (ee = function(Y, G) {
            var S;
            A = G, d.isBuffer(A) || A instanceof T || typeof G == "string" || G === void 0 || Y.objectMode || (S = new TypeError("Invalid non-string/buffer chunk"));
            var A;
            return S;
          }(ne, m)), ee ? O.emit("error", ee) : ne.objectMode || m && m.length > 0 ? (typeof m == "string" || ne.objectMode || Object.getPrototypeOf(m) === d.prototype || (m = function(Y) {
            return d.from(Y);
          }(m)), V ? ne.endEmitted ? O.emit("error", new Error("stream.unshift() after end event")) : M(O, ne, m, !0) : ne.ended ? O.emit("error", new Error("stream.push() after EOF")) : (ne.reading = !1, ne.decoder && !F ? (m = ne.decoder.write(m), ne.objectMode || m.length !== 0 ? M(O, ne, m, !1) : y(O, ne)) : M(O, ne, m, !1))) : V || (ne.reading = !1)), function(Y) {
            return !Y.ended && (Y.needReadable || Y.length < Y.highWaterMark || Y.length === 0);
          }(ne);
        }
        function M(O, m, F, V) {
          m.flowing && m.length === 0 && !m.sync ? (O.emit("data", F), O.read(0)) : (m.length += m.objectMode ? 1 : F.length, V ? m.buffer.unshift(F) : m.buffer.push(F), m.needReadable && Z(O)), y(O, m);
        }
        Object.defineProperty(R.prototype, "destroyed", { get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(O) {
          this._readableState && (this._readableState.destroyed = O);
        } }), R.prototype.destroy = j.destroy, R.prototype._undestroy = j.undestroy, R.prototype._destroy = function(O, m) {
          this.push(null), m(O);
        }, R.prototype.push = function(O, m) {
          var F, V = this._readableState;
          return V.objectMode ? F = !0 : typeof O == "string" && ((m = m || V.defaultEncoding) !== V.encoding && (O = d.from(O, m), m = ""), F = !0), p(this, O, m, !1, F);
        }, R.prototype.unshift = function(O) {
          return p(this, O, null, !0, !1);
        }, R.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        }, R.prototype.setEncoding = function(O) {
          return v || (v = n(22).StringDecoder), this._readableState.decoder = new v(O), this._readableState.encoding = O, this;
        };
        function $(O, m) {
          return O <= 0 || m.length === 0 && m.ended ? 0 : m.objectMode ? 1 : O != O ? m.flowing && m.length ? m.buffer.head.data.length : m.length : (O > m.highWaterMark && (m.highWaterMark = function(F) {
            return F >= 8388608 ? F = 8388608 : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
          }(O)), O <= m.length ? O : m.ended ? m.length : (m.needReadable = !0, 0));
        }
        function Z(O) {
          var m = O._readableState;
          m.needReadable = !1, m.emittedReadable || (f("emitReadable", m.flowing), m.emittedReadable = !0, m.sync ? l.nextTick(_, O) : _(O));
        }
        function _(O) {
          f("emit readable"), O.emit("readable"), H(O);
        }
        function y(O, m) {
          m.readingMore || (m.readingMore = !0, l.nextTick(C, O, m));
        }
        function C(O, m) {
          for (var F = m.length; !m.reading && !m.flowing && !m.ended && m.length < m.highWaterMark && (f("maybeReadMore read 0"), O.read(0), F !== m.length); )
            F = m.length;
          m.readingMore = !1;
        }
        function w(O) {
          f("readable nexttick read 0"), O.read(0);
        }
        function x(O, m) {
          m.reading || (f("resume read 0"), O.read(0)), m.resumeScheduled = !1, m.awaitDrain = 0, O.emit("resume"), H(O), m.flowing && !m.reading && O.read(0);
        }
        function H(O) {
          var m = O._readableState;
          for (f("flow", m.flowing); m.flowing && O.read() !== null; )
            ;
        }
        function L(O, m) {
          return m.length === 0 ? null : (m.objectMode ? F = m.buffer.shift() : !O || O >= m.length ? (F = m.decoder ? m.buffer.join("") : m.buffer.length === 1 ? m.buffer.head.data : m.buffer.concat(m.length), m.buffer.clear()) : F = function(V, Q, ee) {
            var ne;
            return V < Q.head.data.length ? (ne = Q.head.data.slice(0, V), Q.head.data = Q.head.data.slice(V)) : ne = V === Q.head.data.length ? Q.shift() : ee ? function(Y, G) {
              var S = G.head, A = 1, U = S.data;
              for (Y -= U.length; S = S.next; ) {
                var J = S.data, K = Y > J.length ? J.length : Y;
                if (K === J.length ? U += J : U += J.slice(0, Y), (Y -= K) === 0) {
                  K === J.length ? (++A, S.next ? G.head = S.next : G.head = G.tail = null) : (G.head = S, S.data = J.slice(K));
                  break;
                }
                ++A;
              }
              return G.length -= A, U;
            }(V, Q) : function(Y, G) {
              var S = d.allocUnsafe(Y), A = G.head, U = 1;
              for (A.data.copy(S), Y -= A.data.length; A = A.next; ) {
                var J = A.data, K = Y > J.length ? J.length : Y;
                if (J.copy(S, S.length - Y, 0, K), (Y -= K) === 0) {
                  K === J.length ? (++U, A.next ? G.head = A.next : G.head = G.tail = null) : (G.head = A, A.data = J.slice(K));
                  break;
                }
                ++U;
              }
              return G.length -= U, S;
            }(V, Q), ne;
          }(O, m.buffer, m.decoder), F);
          var F;
        }
        function N(O) {
          var m = O._readableState;
          if (m.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          m.endEmitted || (m.ended = !0, l.nextTick(P, m, O));
        }
        function P(O, m) {
          O.endEmitted || O.length !== 0 || (O.endEmitted = !0, m.readable = !1, m.emit("end"));
        }
        function z(O, m) {
          for (var F = 0, V = O.length; F < V; F++)
            if (O[F] === m)
              return F;
          return -1;
        }
        R.prototype.read = function(O) {
          f("read", O), O = parseInt(O, 10);
          var m = this._readableState, F = O;
          if (O !== 0 && (m.emittedReadable = !1), O === 0 && m.needReadable && (m.length >= m.highWaterMark || m.ended))
            return f("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? N(this) : Z(this), null;
          if ((O = $(O, m)) === 0 && m.ended)
            return m.length === 0 && N(this), null;
          var V, Q = m.needReadable;
          return f("need readable", Q), (m.length === 0 || m.length - O < m.highWaterMark) && f("length less than watermark", Q = !0), m.ended || m.reading ? f("reading or ended", Q = !1) : Q && (f("do read"), m.reading = !0, m.sync = !0, m.length === 0 && (m.needReadable = !0), this._read(m.highWaterMark), m.sync = !1, m.reading || (O = $(F, m))), (V = O > 0 ? L(O, m) : null) === null ? (m.needReadable = !0, O = 0) : m.length -= O, m.length === 0 && (m.ended || (m.needReadable = !0), F !== O && m.ended && N(this)), V !== null && this.emit("data", V), V;
        }, R.prototype._read = function(O) {
          this.emit("error", new Error("_read() is not implemented"));
        }, R.prototype.pipe = function(O, m) {
          var F = this, V = this._readableState;
          switch (V.pipesCount) {
            case 0:
              V.pipes = O;
              break;
            case 1:
              V.pipes = [V.pipes, O];
              break;
            default:
              V.pipes.push(O);
          }
          V.pipesCount += 1, f("pipe count=%d opts=%j", V.pipesCount, m);
          var Q = (!m || m.end !== !1) && O !== o.stdout && O !== o.stderr ? ne : re;
          function ee(se, fe) {
            f("onunpipe"), se === F && fe && fe.hasUnpiped === !1 && (fe.hasUnpiped = !0, f("cleanup"), O.removeListener("close", J), O.removeListener("finish", K), O.removeListener("drain", Y), O.removeListener("error", U), O.removeListener("unpipe", ee), F.removeListener("end", ne), F.removeListener("end", re), F.removeListener("data", A), G = !0, !V.awaitDrain || O._writableState && !O._writableState.needDrain || Y());
          }
          function ne() {
            f("onend"), O.end();
          }
          V.endEmitted ? l.nextTick(Q) : F.once("end", Q), O.on("unpipe", ee);
          var Y = function(se) {
            return function() {
              var fe = se._readableState;
              f("pipeOnDrain", fe.awaitDrain), fe.awaitDrain && fe.awaitDrain--, fe.awaitDrain === 0 && g(se, "data") && (fe.flowing = !0, H(se));
            };
          }(F);
          O.on("drain", Y);
          var G = !1, S = !1;
          function A(se) {
            f("ondata"), S = !1, O.write(se) !== !1 || S || ((V.pipesCount === 1 && V.pipes === O || V.pipesCount > 1 && z(V.pipes, O) !== -1) && !G && (f("false write response, pause", F._readableState.awaitDrain), F._readableState.awaitDrain++, S = !0), F.pause());
          }
          function U(se) {
            f("onerror", se), re(), O.removeListener("error", U), g(O, "error") === 0 && O.emit("error", se);
          }
          function J() {
            O.removeListener("finish", K), re();
          }
          function K() {
            f("onfinish"), O.removeListener("close", J), re();
          }
          function re() {
            f("unpipe"), F.unpipe(O);
          }
          return F.on("data", A), function(se, fe, we) {
            if (typeof se.prependListener == "function")
              return se.prependListener(fe, we);
            se._events && se._events[fe] ? s(se._events[fe]) ? se._events[fe].unshift(we) : se._events[fe] = [we, se._events[fe]] : se.on(fe, we);
          }(O, "error", U), O.once("close", J), O.once("finish", K), O.emit("pipe", F), V.flowing || (f("pipe resume"), F.resume()), O;
        }, R.prototype.unpipe = function(O) {
          var m = this._readableState, F = { hasUnpiped: !1 };
          if (m.pipesCount === 0)
            return this;
          if (m.pipesCount === 1)
            return O && O !== m.pipes || (O || (O = m.pipes), m.pipes = null, m.pipesCount = 0, m.flowing = !1, O && O.emit("unpipe", this, F)), this;
          if (!O) {
            var V = m.pipes, Q = m.pipesCount;
            m.pipes = null, m.pipesCount = 0, m.flowing = !1;
            for (var ee = 0; ee < Q; ee++)
              V[ee].emit("unpipe", this, F);
            return this;
          }
          var ne = z(m.pipes, O);
          return ne === -1 || (m.pipes.splice(ne, 1), m.pipesCount -= 1, m.pipesCount === 1 && (m.pipes = m.pipes[0]), O.emit("unpipe", this, F)), this;
        }, R.prototype.on = function(O, m) {
          var F = c.prototype.on.call(this, O, m);
          if (O === "data")
            this._readableState.flowing !== !1 && this.resume();
          else if (O === "readable") {
            var V = this._readableState;
            V.endEmitted || V.readableListening || (V.readableListening = V.needReadable = !0, V.emittedReadable = !1, V.reading ? V.length && Z(this) : l.nextTick(w, this));
          }
          return F;
        }, R.prototype.addListener = R.prototype.on, R.prototype.resume = function() {
          var O = this._readableState;
          return O.flowing || (f("resume"), O.flowing = !0, function(m, F) {
            F.resumeScheduled || (F.resumeScheduled = !0, l.nextTick(x, m, F));
          }(this, O)), this;
        }, R.prototype.pause = function() {
          return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        }, R.prototype.wrap = function(O) {
          var m = this, F = this._readableState, V = !1;
          for (var Q in O.on("end", function() {
            if (f("wrapped end"), F.decoder && !F.ended) {
              var ne = F.decoder.end();
              ne && ne.length && m.push(ne);
            }
            m.push(null);
          }), O.on("data", function(ne) {
            f("wrapped data"), F.decoder && (ne = F.decoder.write(ne)), F.objectMode && ne == null || (F.objectMode || ne && ne.length) && (m.push(ne) || (V = !0, O.pause()));
          }), O)
            this[Q] === void 0 && typeof O[Q] == "function" && (this[Q] = function(ne) {
              return function() {
                return O[ne].apply(O, arguments);
              };
            }(Q));
          for (var ee = 0; ee < B.length; ee++)
            O.on(B[ee], this.emit.bind(this, B[ee]));
          return this._read = function(ne) {
            f("wrapped _read", ne), V && (V = !1, O.resume());
          }, this;
        }, Object.defineProperty(R.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
          return this._readableState.highWaterMark;
        } }), R._fromList = L;
      }).call(this, n(6), n(2));
    }, function(e, t, n) {
      e.exports = n(21).EventEmitter;
    }, function(e, t, n) {
      var r = n(16);
      function o(l, u) {
        l.emit("error", u);
      }
      e.exports = { destroy: function(l, u) {
        var s = this, g = this._readableState && this._readableState.destroyed, c = this._writableState && this._writableState.destroyed;
        return g || c ? (u ? u(l) : !l || this._writableState && this._writableState.errorEmitted || r.nextTick(o, this, l), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(l || null, function(d) {
          !u && d ? (r.nextTick(o, s, d), s._writableState && (s._writableState.errorEmitted = !0)) : u && u(d);
        }), this);
      }, undestroy: function() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
      } };
    }, function(e, t, n) {
      e.exports = u;
      var r = n(23), o = n(17);
      function l(c, d) {
        var T = this._transformState;
        T.transforming = !1;
        var b = T.writecb;
        if (!b)
          return this.emit("error", new Error("write callback called multiple times"));
        T.writechunk = null, T.writecb = null, d != null && this.push(d), b(c);
        var h = this._readableState;
        h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
      }
      function u(c) {
        if (!(this instanceof u))
          return new u(c);
        r.call(this, c), this._transformState = { afterTransform: l.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, c && (typeof c.transform == "function" && (this._transform = c.transform), typeof c.flush == "function" && (this._flush = c.flush)), this.on("prefinish", s);
      }
      function s() {
        var c = this;
        typeof this._flush == "function" ? this._flush(function(d, T) {
          g(c, d, T);
        }) : g(this, null, null);
      }
      function g(c, d, T) {
        if (d)
          return c.emit("error", d);
        if (T != null && c.push(T), c._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (c._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return c.push(null);
      }
      o.inherits = n(7), o.inherits(u, r), u.prototype.push = function(c, d) {
        return this._transformState.needTransform = !1, r.prototype.push.call(this, c, d);
      }, u.prototype._transform = function(c, d, T) {
        throw new Error("_transform() is not implemented");
      }, u.prototype._write = function(c, d, T) {
        var b = this._transformState;
        if (b.writecb = T, b.writechunk = c, b.writeencoding = d, !b.transforming) {
          var h = this._readableState;
          (b.needTransform || h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
        }
      }, u.prototype._read = function(c) {
        var d = this._transformState;
        d.writechunk !== null && d.writecb && !d.transforming ? (d.transforming = !0, this._transform(d.writechunk, d.writeencoding, d.afterTransform)) : d.needTransform = !0;
      }, u.prototype._destroy = function(c, d) {
        var T = this;
        r.prototype._destroy.call(this, c, function(b) {
          d(b), T.emit("close");
        });
      };
    }, function(e, t, n) {
      e.exports = n(48);
    }, function(e, t, n) {
      (function(r) {
        var o = n(170);
        function l(_, y) {
          if (_ === y)
            return 0;
          for (var C = _.length, w = y.length, x = 0, H = Math.min(C, w); x < H; ++x)
            if (_[x] !== y[x]) {
              C = _[x], w = y[x];
              break;
            }
          return C < w ? -1 : w < C ? 1 : 0;
        }
        function u(_) {
          return r.Buffer && typeof r.Buffer.isBuffer == "function" ? r.Buffer.isBuffer(_) : !(_ == null || !_._isBuffer);
        }
        var s = n(13), g = Object.prototype.hasOwnProperty, c = Array.prototype.slice, d = function() {
        }.name === "foo";
        function T(_) {
          return Object.prototype.toString.call(_);
        }
        function b(_) {
          return !u(_) && typeof r.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(_) : !!_ && (_ instanceof DataView || !!(_.buffer && _.buffer instanceof ArrayBuffer)));
        }
        var h = e.exports = I, f = /\s*function\s+([^\(\s]*)\s*/;
        function v(_) {
          if (s.isFunction(_)) {
            if (d)
              return _.name;
            var y = _.toString().match(f);
            return y && y[1];
          }
        }
        function E(_, y) {
          return typeof _ == "string" ? _.length < y ? _ : _.slice(0, y) : _;
        }
        function j(_) {
          if (d || !s.isFunction(_))
            return s.inspect(_);
          var y = v(_);
          return "[Function" + (y ? ": " + y : "") + "]";
        }
        function B(_, y, C, w, x) {
          throw new h.AssertionError({ message: C, actual: _, expected: y, operator: w, stackStartFunction: x });
        }
        function I(_, y) {
          _ || B(_, !0, y, "==", h.ok);
        }
        function R(_, y, C, w) {
          if (_ === y)
            return !0;
          if (u(_) && u(y))
            return l(_, y) === 0;
          if (s.isDate(_) && s.isDate(y))
            return _.getTime() === y.getTime();
          if (s.isRegExp(_) && s.isRegExp(y))
            return _.source === y.source && _.global === y.global && _.multiline === y.multiline && _.lastIndex === y.lastIndex && _.ignoreCase === y.ignoreCase;
          if (_ !== null && typeof _ == "object" || y !== null && typeof y == "object") {
            if (b(_) && b(y) && T(_) === T(y) && !(_ instanceof Float32Array || _ instanceof Float64Array))
              return l(new Uint8Array(_.buffer), new Uint8Array(y.buffer)) === 0;
            if (u(_) !== u(y))
              return !1;
            var x = (w = w || { actual: [], expected: [] }).actual.indexOf(_);
            return x !== -1 && x === w.expected.indexOf(y) || (w.actual.push(_), w.expected.push(y), function(H, L, N, P) {
              if (H == null || L == null)
                return !1;
              if (s.isPrimitive(H) || s.isPrimitive(L))
                return H === L;
              if (N && Object.getPrototypeOf(H) !== Object.getPrototypeOf(L))
                return !1;
              var z = p(H), O = p(L);
              if (z && !O || !z && O)
                return !1;
              if (z)
                return H = c.call(H), L = c.call(L), R(H, L, N);
              var m, F, V = Z(H), Q = Z(L);
              if (V.length !== Q.length)
                return !1;
              for (V.sort(), Q.sort(), F = V.length - 1; F >= 0; F--)
                if (V[F] !== Q[F])
                  return !1;
              for (F = V.length - 1; F >= 0; F--)
                if (m = V[F], !R(H[m], L[m], N, P))
                  return !1;
              return !0;
            }(_, y, C, w));
          }
          return C ? _ === y : _ == y;
        }
        function p(_) {
          return Object.prototype.toString.call(_) == "[object Arguments]";
        }
        function M(_, y) {
          if (!_ || !y)
            return !1;
          if (Object.prototype.toString.call(y) == "[object RegExp]")
            return y.test(_);
          try {
            if (_ instanceof y)
              return !0;
          } catch {
          }
          return !Error.isPrototypeOf(y) && y.call({}, _) === !0;
        }
        function $(_, y, C, w) {
          var x;
          if (typeof y != "function")
            throw new TypeError('"block" argument must be a function');
          typeof C == "string" && (w = C, C = null), x = function(N) {
            var P;
            try {
              N();
            } catch (z) {
              P = z;
            }
            return P;
          }(y), w = (C && C.name ? " (" + C.name + ")." : ".") + (w ? " " + w : "."), _ && !x && B(x, C, "Missing expected exception" + w);
          var H = typeof w == "string", L = !_ && x && !C;
          if ((!_ && s.isError(x) && H && M(x, C) || L) && B(x, C, "Got unwanted exception" + w), _ && x && C && !M(x, C) || !_ && x)
            throw x;
        }
        h.AssertionError = function(_) {
          this.name = "AssertionError", this.actual = _.actual, this.expected = _.expected, this.operator = _.operator, _.message ? (this.message = _.message, this.generatedMessage = !1) : (this.message = function(N) {
            return E(j(N.actual), 128) + " " + N.operator + " " + E(j(N.expected), 128);
          }(this), this.generatedMessage = !0);
          var y = _.stackStartFunction || B;
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, y);
          else {
            var C = new Error();
            if (C.stack) {
              var w = C.stack, x = v(y), H = w.indexOf(`
` + x);
              if (H >= 0) {
                var L = w.indexOf(`
`, H + 1);
                w = w.substring(L + 1);
              }
              this.stack = w;
            }
          }
        }, s.inherits(h.AssertionError, Error), h.fail = B, h.ok = I, h.equal = function(_, y, C) {
          _ != y && B(_, y, C, "==", h.equal);
        }, h.notEqual = function(_, y, C) {
          _ == y && B(_, y, C, "!=", h.notEqual);
        }, h.deepEqual = function(_, y, C) {
          R(_, y, !1) || B(_, y, C, "deepEqual", h.deepEqual);
        }, h.deepStrictEqual = function(_, y, C) {
          R(_, y, !0) || B(_, y, C, "deepStrictEqual", h.deepStrictEqual);
        }, h.notDeepEqual = function(_, y, C) {
          R(_, y, !1) && B(_, y, C, "notDeepEqual", h.notDeepEqual);
        }, h.notDeepStrictEqual = function _(y, C, w) {
          R(y, C, !0) && B(y, C, w, "notDeepStrictEqual", _);
        }, h.strictEqual = function(_, y, C) {
          _ !== y && B(_, y, C, "===", h.strictEqual);
        }, h.notStrictEqual = function(_, y, C) {
          _ === y && B(_, y, C, "!==", h.notStrictEqual);
        }, h.throws = function(_, y, C) {
          $(!0, _, y, C);
        }, h.doesNotThrow = function(_, y, C) {
          $(!1, _, y, C);
        }, h.ifError = function(_) {
          if (_)
            throw _;
        }, h.strict = o(function _(y, C) {
          y || B(y, !0, C, "==", _);
        }, h, { equal: h.strictEqual, deepEqual: h.deepStrictEqual, notEqual: h.notStrictEqual, notDeepEqual: h.notDeepStrictEqual }), h.strict.strict = h.strict;
        var Z = Object.keys || function(_) {
          var y = [];
          for (var C in _)
            g.call(_, C) && y.push(C);
          return y;
        };
      }).call(this, n(6));
    }, function(e, t, n) {
      e.exports = function(r, o, l, u) {
        for (var s = 65535 & r | 0, g = r >>> 16 & 65535 | 0, c = 0; l !== 0; ) {
          l -= c = l > 2e3 ? 2e3 : l;
          do
            g = g + (s = s + o[u++] | 0) | 0;
          while (--c);
          s %= 65521, g %= 65521;
        }
        return s | g << 16 | 0;
      };
    }, function(e, t, n) {
      var r = function() {
        for (var o, l = [], u = 0; u < 256; u++) {
          o = u;
          for (var s = 0; s < 8; s++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          l[u] = o;
        }
        return l;
      }();
      e.exports = function(o, l, u, s) {
        var g = r, c = s + u;
        o ^= -1;
        for (var d = s; d < c; d++)
          o = o >>> 8 ^ g[255 & (o ^ l[d])];
        return -1 ^ o;
      };
    }, function(e, t, n) {
      (function(r, o) {
        var l;
        e.exports = y, y.ReadableState = _, n(21).EventEmitter;
        var u = function(Y, G) {
          return Y.listeners(G).length;
        }, s = n(78), g = n(5).Buffer, c = r.Uint8Array || function() {
        }, d, T = n(179);
        d = T && T.debuglog ? T.debuglog("stream") : function() {
        };
        var b, h, f, v = n(180), E = n(79), j = n(80).getHighWaterMark, B = n(26).codes, I = B.ERR_INVALID_ARG_TYPE, R = B.ERR_STREAM_PUSH_AFTER_EOF, p = B.ERR_METHOD_NOT_IMPLEMENTED, M = B.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        n(7)(y, s);
        var $ = E.errorOrDestroy, Z = ["error", "close", "destroy", "pause", "resume"];
        function _(Y, G, S) {
          l = l || n(27), Y = Y || {}, typeof S != "boolean" && (S = G instanceof l), this.objectMode = !!Y.objectMode, S && (this.objectMode = this.objectMode || !!Y.readableObjectMode), this.highWaterMark = j(this, Y, "readableHighWaterMark", S), this.buffer = new v(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Y.emitClose !== !1, this.autoDestroy = !!Y.autoDestroy, this.destroyed = !1, this.defaultEncoding = Y.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Y.encoding && (b || (b = n(22).StringDecoder), this.decoder = new b(Y.encoding), this.encoding = Y.encoding);
        }
        function y(Y) {
          if (l = l || n(27), !(this instanceof y))
            return new y(Y);
          var G = this instanceof l;
          this._readableState = new _(Y, this, G), this.readable = !0, Y && (typeof Y.read == "function" && (this._read = Y.read), typeof Y.destroy == "function" && (this._destroy = Y.destroy)), s.call(this);
        }
        function C(Y, G, S, A, U) {
          d("readableAddChunk", G);
          var J, K = Y._readableState;
          if (G === null)
            K.reading = !1, function(re, se) {
              if (d("onEofChunk"), !se.ended) {
                if (se.decoder) {
                  var fe = se.decoder.end();
                  fe && fe.length && (se.buffer.push(fe), se.length += se.objectMode ? 1 : fe.length);
                }
                se.ended = !0, se.sync ? H(re) : (se.needReadable = !1, se.emittedReadable || (se.emittedReadable = !0, L(re)));
              }
            }(Y, K);
          else if (U || (J = function(re, se) {
            var fe;
            we = se, g.isBuffer(we) || we instanceof c || typeof se == "string" || se === void 0 || re.objectMode || (fe = new I("chunk", ["string", "Buffer", "Uint8Array"], se));
            var we;
            return fe;
          }(K, G)), J)
            $(Y, J);
          else if (K.objectMode || G && G.length > 0)
            if (typeof G == "string" || K.objectMode || Object.getPrototypeOf(G) === g.prototype || (G = function(re) {
              return g.from(re);
            }(G)), A)
              K.endEmitted ? $(Y, new M()) : w(Y, K, G, !0);
            else if (K.ended)
              $(Y, new R());
            else {
              if (K.destroyed)
                return !1;
              K.reading = !1, K.decoder && !S ? (G = K.decoder.write(G), K.objectMode || G.length !== 0 ? w(Y, K, G, !1) : N(Y, K)) : w(Y, K, G, !1);
            }
          else
            A || (K.reading = !1, N(Y, K));
          return !K.ended && (K.length < K.highWaterMark || K.length === 0);
        }
        function w(Y, G, S, A) {
          G.flowing && G.length === 0 && !G.sync ? (G.awaitDrain = 0, Y.emit("data", S)) : (G.length += G.objectMode ? 1 : S.length, A ? G.buffer.unshift(S) : G.buffer.push(S), G.needReadable && H(Y)), N(Y, G);
        }
        Object.defineProperty(y.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(Y) {
          this._readableState && (this._readableState.destroyed = Y);
        } }), y.prototype.destroy = E.destroy, y.prototype._undestroy = E.undestroy, y.prototype._destroy = function(Y, G) {
          G(Y);
        }, y.prototype.push = function(Y, G) {
          var S, A = this._readableState;
          return A.objectMode ? S = !0 : typeof Y == "string" && ((G = G || A.defaultEncoding) !== A.encoding && (Y = g.from(Y, G), G = ""), S = !0), C(this, Y, G, !1, S);
        }, y.prototype.unshift = function(Y) {
          return C(this, Y, null, !0, !1);
        }, y.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        }, y.prototype.setEncoding = function(Y) {
          b || (b = n(22).StringDecoder);
          var G = new b(Y);
          this._readableState.decoder = G, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var S = this._readableState.buffer.head, A = ""; S !== null; )
            A += G.write(S.data), S = S.next;
          return this._readableState.buffer.clear(), A !== "" && this._readableState.buffer.push(A), this._readableState.length = A.length, this;
        };
        function x(Y, G) {
          return Y <= 0 || G.length === 0 && G.ended ? 0 : G.objectMode ? 1 : Y != Y ? G.flowing && G.length ? G.buffer.head.data.length : G.length : (Y > G.highWaterMark && (G.highWaterMark = function(S) {
            return S >= 1073741824 ? S = 1073741824 : (S--, S |= S >>> 1, S |= S >>> 2, S |= S >>> 4, S |= S >>> 8, S |= S >>> 16, S++), S;
          }(Y)), Y <= G.length ? Y : G.ended ? G.length : (G.needReadable = !0, 0));
        }
        function H(Y) {
          var G = Y._readableState;
          d("emitReadable", G.needReadable, G.emittedReadable), G.needReadable = !1, G.emittedReadable || (d("emitReadable", G.flowing), G.emittedReadable = !0, o.nextTick(L, Y));
        }
        function L(Y) {
          var G = Y._readableState;
          d("emitReadable_", G.destroyed, G.length, G.ended), G.destroyed || !G.length && !G.ended || (Y.emit("readable"), G.emittedReadable = !1), G.needReadable = !G.flowing && !G.ended && G.length <= G.highWaterMark, F(Y);
        }
        function N(Y, G) {
          G.readingMore || (G.readingMore = !0, o.nextTick(P, Y, G));
        }
        function P(Y, G) {
          for (; !G.reading && !G.ended && (G.length < G.highWaterMark || G.flowing && G.length === 0); ) {
            var S = G.length;
            if (d("maybeReadMore read 0"), Y.read(0), S === G.length)
              break;
          }
          G.readingMore = !1;
        }
        function z(Y) {
          var G = Y._readableState;
          G.readableListening = Y.listenerCount("readable") > 0, G.resumeScheduled && !G.paused ? G.flowing = !0 : Y.listenerCount("data") > 0 && Y.resume();
        }
        function O(Y) {
          d("readable nexttick read 0"), Y.read(0);
        }
        function m(Y, G) {
          d("resume", G.reading), G.reading || Y.read(0), G.resumeScheduled = !1, Y.emit("resume"), F(Y), G.flowing && !G.reading && Y.read(0);
        }
        function F(Y) {
          var G = Y._readableState;
          for (d("flow", G.flowing); G.flowing && Y.read() !== null; )
            ;
        }
        function V(Y, G) {
          return G.length === 0 ? null : (G.objectMode ? S = G.buffer.shift() : !Y || Y >= G.length ? (S = G.decoder ? G.buffer.join("") : G.buffer.length === 1 ? G.buffer.first() : G.buffer.concat(G.length), G.buffer.clear()) : S = G.buffer.consume(Y, G.decoder), S);
          var S;
        }
        function Q(Y) {
          var G = Y._readableState;
          d("endReadable", G.endEmitted), G.endEmitted || (G.ended = !0, o.nextTick(ee, G, Y));
        }
        function ee(Y, G) {
          if (d("endReadableNT", Y.endEmitted, Y.length), !Y.endEmitted && Y.length === 0 && (Y.endEmitted = !0, G.readable = !1, G.emit("end"), Y.autoDestroy)) {
            var S = G._writableState;
            (!S || S.autoDestroy && S.finished) && G.destroy();
          }
        }
        function ne(Y, G) {
          for (var S = 0, A = Y.length; S < A; S++)
            if (Y[S] === G)
              return S;
          return -1;
        }
        y.prototype.read = function(Y) {
          d("read", Y), Y = parseInt(Y, 10);
          var G = this._readableState, S = Y;
          if (Y !== 0 && (G.emittedReadable = !1), Y === 0 && G.needReadable && ((G.highWaterMark !== 0 ? G.length >= G.highWaterMark : G.length > 0) || G.ended))
            return d("read: emitReadable", G.length, G.ended), G.length === 0 && G.ended ? Q(this) : H(this), null;
          if ((Y = x(Y, G)) === 0 && G.ended)
            return G.length === 0 && Q(this), null;
          var A, U = G.needReadable;
          return d("need readable", U), (G.length === 0 || G.length - Y < G.highWaterMark) && d("length less than watermark", U = !0), G.ended || G.reading ? d("reading or ended", U = !1) : U && (d("do read"), G.reading = !0, G.sync = !0, G.length === 0 && (G.needReadable = !0), this._read(G.highWaterMark), G.sync = !1, G.reading || (Y = x(S, G))), (A = Y > 0 ? V(Y, G) : null) === null ? (G.needReadable = G.length <= G.highWaterMark, Y = 0) : (G.length -= Y, G.awaitDrain = 0), G.length === 0 && (G.ended || (G.needReadable = !0), S !== Y && G.ended && Q(this)), A !== null && this.emit("data", A), A;
        }, y.prototype._read = function(Y) {
          $(this, new p("_read()"));
        }, y.prototype.pipe = function(Y, G) {
          var S = this, A = this._readableState;
          switch (A.pipesCount) {
            case 0:
              A.pipes = Y;
              break;
            case 1:
              A.pipes = [A.pipes, Y];
              break;
            default:
              A.pipes.push(Y);
          }
          A.pipesCount += 1, d("pipe count=%d opts=%j", A.pipesCount, G);
          var U = (!G || G.end !== !1) && Y !== o.stdout && Y !== o.stderr ? K : Ce;
          function J(Ae, Oe) {
            d("onunpipe"), Ae === S && Oe && Oe.hasUnpiped === !1 && (Oe.hasUnpiped = !0, d("cleanup"), Y.removeListener("close", Ie), Y.removeListener("finish", Ee), Y.removeListener("drain", re), Y.removeListener("error", we), Y.removeListener("unpipe", J), S.removeListener("end", K), S.removeListener("end", Ce), S.removeListener("data", fe), se = !0, !A.awaitDrain || Y._writableState && !Y._writableState.needDrain || re());
          }
          function K() {
            d("onend"), Y.end();
          }
          A.endEmitted ? o.nextTick(U) : S.once("end", U), Y.on("unpipe", J);
          var re = function(Ae) {
            return function() {
              var Oe = Ae._readableState;
              d("pipeOnDrain", Oe.awaitDrain), Oe.awaitDrain && Oe.awaitDrain--, Oe.awaitDrain === 0 && u(Ae, "data") && (Oe.flowing = !0, F(Ae));
            };
          }(S);
          Y.on("drain", re);
          var se = !1;
          function fe(Ae) {
            d("ondata");
            var Oe = Y.write(Ae);
            d("dest.write", Oe), Oe === !1 && ((A.pipesCount === 1 && A.pipes === Y || A.pipesCount > 1 && ne(A.pipes, Y) !== -1) && !se && (d("false write response, pause", A.awaitDrain), A.awaitDrain++), S.pause());
          }
          function we(Ae) {
            d("onerror", Ae), Ce(), Y.removeListener("error", we), u(Y, "error") === 0 && $(Y, Ae);
          }
          function Ie() {
            Y.removeListener("finish", Ee), Ce();
          }
          function Ee() {
            d("onfinish"), Y.removeListener("close", Ie), Ce();
          }
          function Ce() {
            d("unpipe"), S.unpipe(Y);
          }
          return S.on("data", fe), function(Ae, Oe, Pe) {
            if (typeof Ae.prependListener == "function")
              return Ae.prependListener(Oe, Pe);
            Ae._events && Ae._events[Oe] ? Array.isArray(Ae._events[Oe]) ? Ae._events[Oe].unshift(Pe) : Ae._events[Oe] = [Pe, Ae._events[Oe]] : Ae.on(Oe, Pe);
          }(Y, "error", we), Y.once("close", Ie), Y.once("finish", Ee), Y.emit("pipe", S), A.flowing || (d("pipe resume"), S.resume()), Y;
        }, y.prototype.unpipe = function(Y) {
          var G = this._readableState, S = { hasUnpiped: !1 };
          if (G.pipesCount === 0)
            return this;
          if (G.pipesCount === 1)
            return Y && Y !== G.pipes || (Y || (Y = G.pipes), G.pipes = null, G.pipesCount = 0, G.flowing = !1, Y && Y.emit("unpipe", this, S)), this;
          if (!Y) {
            var A = G.pipes, U = G.pipesCount;
            G.pipes = null, G.pipesCount = 0, G.flowing = !1;
            for (var J = 0; J < U; J++)
              A[J].emit("unpipe", this, { hasUnpiped: !1 });
            return this;
          }
          var K = ne(G.pipes, Y);
          return K === -1 || (G.pipes.splice(K, 1), G.pipesCount -= 1, G.pipesCount === 1 && (G.pipes = G.pipes[0]), Y.emit("unpipe", this, S)), this;
        }, y.prototype.on = function(Y, G) {
          var S = s.prototype.on.call(this, Y, G), A = this._readableState;
          return Y === "data" ? (A.readableListening = this.listenerCount("readable") > 0, A.flowing !== !1 && this.resume()) : Y === "readable" && (A.endEmitted || A.readableListening || (A.readableListening = A.needReadable = !0, A.flowing = !1, A.emittedReadable = !1, d("on readable", A.length, A.reading), A.length ? H(this) : A.reading || o.nextTick(O, this))), S;
        }, y.prototype.addListener = y.prototype.on, y.prototype.removeListener = function(Y, G) {
          var S = s.prototype.removeListener.call(this, Y, G);
          return Y === "readable" && o.nextTick(z, this), S;
        }, y.prototype.removeAllListeners = function(Y) {
          var G = s.prototype.removeAllListeners.apply(this, arguments);
          return Y !== "readable" && Y !== void 0 || o.nextTick(z, this), G;
        }, y.prototype.resume = function() {
          var Y = this._readableState;
          return Y.flowing || (d("resume"), Y.flowing = !Y.readableListening, function(G, S) {
            S.resumeScheduled || (S.resumeScheduled = !0, o.nextTick(m, G, S));
          }(this, Y)), Y.paused = !1, this;
        }, y.prototype.pause = function() {
          return d("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
        }, y.prototype.wrap = function(Y) {
          var G = this, S = this._readableState, A = !1;
          for (var U in Y.on("end", function() {
            if (d("wrapped end"), S.decoder && !S.ended) {
              var K = S.decoder.end();
              K && K.length && G.push(K);
            }
            G.push(null);
          }), Y.on("data", function(K) {
            d("wrapped data"), S.decoder && (K = S.decoder.write(K)), S.objectMode && K == null || (S.objectMode || K && K.length) && (G.push(K) || (A = !0, Y.pause()));
          }), Y)
            this[U] === void 0 && typeof Y[U] == "function" && (this[U] = function(K) {
              return function() {
                return Y[K].apply(Y, arguments);
              };
            }(U));
          for (var J = 0; J < Z.length; J++)
            Y.on(Z[J], this.emit.bind(this, Z[J]));
          return this._read = function(K) {
            d("wrapped _read", K), A && (A = !1, Y.resume());
          }, this;
        }, typeof Symbol == "function" && (y.prototype[Symbol.asyncIterator] = function() {
          return h === void 0 && (h = n(182)), h(this);
        }), Object.defineProperty(y.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(y.prototype, "readableBuffer", { enumerable: !1, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(y.prototype, "readableFlowing", { enumerable: !1, get: function() {
          return this._readableState.flowing;
        }, set: function(Y) {
          this._readableState && (this._readableState.flowing = Y);
        } }), y._fromList = V, Object.defineProperty(y.prototype, "readableLength", { enumerable: !1, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (y.from = function(Y, G) {
          return f === void 0 && (f = n(183)), f(y, Y, G);
        });
      }).call(this, n(6), n(2));
    }, function(e, t, n) {
      e.exports = n(21).EventEmitter;
    }, function(e, t, n) {
      (function(r) {
        function o(s, g) {
          u(s, g), l(s);
        }
        function l(s) {
          s._writableState && !s._writableState.emitClose || s._readableState && !s._readableState.emitClose || s.emit("close");
        }
        function u(s, g) {
          s.emit("error", g);
        }
        e.exports = { destroy: function(s, g) {
          var c = this, d = this._readableState && this._readableState.destroyed, T = this._writableState && this._writableState.destroyed;
          return d || T ? (g ? g(s) : s && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, r.nextTick(u, this, s)) : r.nextTick(u, this, s)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(s || null, function(b) {
            !g && b ? c._writableState ? c._writableState.errorEmitted ? r.nextTick(l, c) : (c._writableState.errorEmitted = !0, r.nextTick(o, c, b)) : r.nextTick(o, c, b) : g ? (r.nextTick(l, c), g(b)) : r.nextTick(l, c);
          }), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }, errorOrDestroy: function(s, g) {
          var c = s._readableState, d = s._writableState;
          c && c.autoDestroy || d && d.autoDestroy ? s.destroy(g) : s.emit("error", g);
        } };
      }).call(this, n(2));
    }, function(e, t, n) {
      var r = n(26).codes.ERR_INVALID_OPT_VALUE;
      e.exports = { getHighWaterMark: function(o, l, u, s) {
        var g = function(c, d, T) {
          return c.highWaterMark != null ? c.highWaterMark : d ? c[T] : null;
        }(l, s, u);
        if (g != null) {
          if (!isFinite(g) || Math.floor(g) !== g || g < 0)
            throw new r(s ? u : "highWaterMark", g);
          return Math.floor(g);
        }
        return o.objectMode ? 16 : 16384;
      } };
    }, function(e, t, n) {
      (function(r, o) {
        function l(P) {
          var z = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(O, m, F) {
              var V = O.entry;
              for (O.entry = null; V; ) {
                var Q = V.callback;
                m.pendingcb--, Q(F), V = V.next;
              }
              m.corkedRequestsFree.next = O;
            })(z, P);
          };
        }
        var u;
        e.exports = y, y.WritableState = _;
        var s = { deprecate: n(43) }, g = n(78), c = n(5).Buffer, d = r.Uint8Array || function() {
        }, T, b = n(79), h = n(80).getHighWaterMark, f = n(26).codes, v = f.ERR_INVALID_ARG_TYPE, E = f.ERR_METHOD_NOT_IMPLEMENTED, j = f.ERR_MULTIPLE_CALLBACK, B = f.ERR_STREAM_CANNOT_PIPE, I = f.ERR_STREAM_DESTROYED, R = f.ERR_STREAM_NULL_VALUES, p = f.ERR_STREAM_WRITE_AFTER_END, M = f.ERR_UNKNOWN_ENCODING, $ = b.errorOrDestroy;
        function Z() {
        }
        function _(P, z, O) {
          u = u || n(27), P = P || {}, typeof O != "boolean" && (O = z instanceof u), this.objectMode = !!P.objectMode, O && (this.objectMode = this.objectMode || !!P.writableObjectMode), this.highWaterMark = h(this, P, "writableHighWaterMark", O), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var m = P.decodeStrings === !1;
          this.decodeStrings = !m, this.defaultEncoding = P.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(F) {
            (function(V, Q) {
              var ee = V._writableState, ne = ee.sync, Y = ee.writecb;
              if (typeof Y != "function")
                throw new j();
              if (function(S) {
                S.writing = !1, S.writecb = null, S.length -= S.writelen, S.writelen = 0;
              }(ee), Q)
                (function(S, A, U, J, K) {
                  --A.pendingcb, U ? (o.nextTick(K, J), o.nextTick(N, S, A), S._writableState.errorEmitted = !0, $(S, J)) : (K(J), S._writableState.errorEmitted = !0, $(S, J), N(S, A));
                })(V, ee, ne, Q, Y);
              else {
                var G = H(ee) || V.destroyed;
                G || ee.corked || ee.bufferProcessing || !ee.bufferedRequest || x(V, ee), ne ? o.nextTick(w, V, ee, G, Y) : w(V, ee, G, Y);
              }
            })(z, F);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = P.emitClose !== !1, this.autoDestroy = !!P.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new l(this);
        }
        function y(P) {
          var z = this instanceof (u = u || n(27));
          if (!z && !T.call(y, this))
            return new y(P);
          this._writableState = new _(P, this, z), this.writable = !0, P && (typeof P.write == "function" && (this._write = P.write), typeof P.writev == "function" && (this._writev = P.writev), typeof P.destroy == "function" && (this._destroy = P.destroy), typeof P.final == "function" && (this._final = P.final)), g.call(this);
        }
        function C(P, z, O, m, F, V, Q) {
          z.writelen = m, z.writecb = Q, z.writing = !0, z.sync = !0, z.destroyed ? z.onwrite(new I("write")) : O ? P._writev(F, z.onwrite) : P._write(F, V, z.onwrite), z.sync = !1;
        }
        function w(P, z, O, m) {
          O || function(F, V) {
            V.length === 0 && V.needDrain && (V.needDrain = !1, F.emit("drain"));
          }(P, z), z.pendingcb--, m(), N(P, z);
        }
        function x(P, z) {
          z.bufferProcessing = !0;
          var O = z.bufferedRequest;
          if (P._writev && O && O.next) {
            var m = z.bufferedRequestCount, F = new Array(m), V = z.corkedRequestsFree;
            V.entry = O;
            for (var Q = 0, ee = !0; O; )
              F[Q] = O, O.isBuf || (ee = !1), O = O.next, Q += 1;
            F.allBuffers = ee, C(P, z, !0, z.length, F, "", V.finish), z.pendingcb++, z.lastBufferedRequest = null, V.next ? (z.corkedRequestsFree = V.next, V.next = null) : z.corkedRequestsFree = new l(z), z.bufferedRequestCount = 0;
          } else {
            for (; O; ) {
              var ne = O.chunk, Y = O.encoding, G = O.callback;
              if (C(P, z, !1, z.objectMode ? 1 : ne.length, ne, Y, G), O = O.next, z.bufferedRequestCount--, z.writing)
                break;
            }
            O === null && (z.lastBufferedRequest = null);
          }
          z.bufferedRequest = O, z.bufferProcessing = !1;
        }
        function H(P) {
          return P.ending && P.length === 0 && P.bufferedRequest === null && !P.finished && !P.writing;
        }
        function L(P, z) {
          P._final(function(O) {
            z.pendingcb--, O && $(P, O), z.prefinished = !0, P.emit("prefinish"), N(P, z);
          });
        }
        function N(P, z) {
          var O = H(z);
          if (O && (function(F, V) {
            V.prefinished || V.finalCalled || (typeof F._final != "function" || V.destroyed ? (V.prefinished = !0, F.emit("prefinish")) : (V.pendingcb++, V.finalCalled = !0, o.nextTick(L, F, V)));
          }(P, z), z.pendingcb === 0 && (z.finished = !0, P.emit("finish"), z.autoDestroy))) {
            var m = P._readableState;
            (!m || m.autoDestroy && m.endEmitted) && P.destroy();
          }
          return O;
        }
        n(7)(y, g), _.prototype.getBuffer = function() {
          for (var P = this.bufferedRequest, z = []; P; )
            z.push(P), P = P.next;
          return z;
        }, function() {
          try {
            Object.defineProperty(_.prototype, "buffer", { get: s.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (T = Function.prototype[Symbol.hasInstance], Object.defineProperty(y, Symbol.hasInstance, { value: function(P) {
          return !!T.call(this, P) || this === y && P && P._writableState instanceof _;
        } })) : T = function(P) {
          return P instanceof this;
        }, y.prototype.pipe = function() {
          $(this, new B());
        }, y.prototype.write = function(P, z, O) {
          var m, F = this._writableState, V = !1, Q = !F.objectMode && (m = P, c.isBuffer(m) || m instanceof d);
          return Q && !c.isBuffer(P) && (P = function(ee) {
            return c.from(ee);
          }(P)), typeof z == "function" && (O = z, z = null), Q ? z = "buffer" : z || (z = F.defaultEncoding), typeof O != "function" && (O = Z), F.ending ? function(ee, ne) {
            var Y = new p();
            $(ee, Y), o.nextTick(ne, Y);
          }(this, O) : (Q || function(ee, ne, Y, G) {
            var S;
            return Y === null ? S = new R() : typeof Y == "string" || ne.objectMode || (S = new v("chunk", ["string", "Buffer"], Y)), !S || ($(ee, S), o.nextTick(G, S), !1);
          }(this, F, P, O)) && (F.pendingcb++, V = function(ee, ne, Y, G, S, A) {
            if (!Y) {
              var U = function(se, fe, we) {
                return se.objectMode || se.decodeStrings === !1 || typeof fe != "string" || (fe = c.from(fe, we)), fe;
              }(ne, G, S);
              G !== U && (Y = !0, S = "buffer", G = U);
            }
            var J = ne.objectMode ? 1 : G.length;
            ne.length += J;
            var K = ne.length < ne.highWaterMark;
            if (K || (ne.needDrain = !0), ne.writing || ne.corked) {
              var re = ne.lastBufferedRequest;
              ne.lastBufferedRequest = { chunk: G, encoding: S, isBuf: Y, callback: A, next: null }, re ? re.next = ne.lastBufferedRequest : ne.bufferedRequest = ne.lastBufferedRequest, ne.bufferedRequestCount += 1;
            } else
              C(ee, ne, !1, J, G, S, A);
            return K;
          }(this, F, Q, P, z, O)), V;
        }, y.prototype.cork = function() {
          this._writableState.corked++;
        }, y.prototype.uncork = function() {
          var P = this._writableState;
          P.corked && (P.corked--, P.writing || P.corked || P.bufferProcessing || !P.bufferedRequest || x(this, P));
        }, y.prototype.setDefaultEncoding = function(P) {
          if (typeof P == "string" && (P = P.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((P + "").toLowerCase()) > -1))
            throw new M(P);
          return this._writableState.defaultEncoding = P, this;
        }, Object.defineProperty(y.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(y.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), y.prototype._write = function(P, z, O) {
          O(new E("_write()"));
        }, y.prototype._writev = null, y.prototype.end = function(P, z, O) {
          var m = this._writableState;
          return typeof P == "function" ? (O = P, P = null, z = null) : typeof z == "function" && (O = z, z = null), P != null && this.write(P, z), m.corked && (m.corked = 1, this.uncork()), m.ending || function(F, V, Q) {
            V.ending = !0, N(F, V), Q && (V.finished ? o.nextTick(Q) : F.once("finish", Q)), V.ended = !0, F.writable = !1;
          }(this, m, O), this;
        }, Object.defineProperty(y.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(y.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(P) {
          this._writableState && (this._writableState.destroyed = P);
        } }), y.prototype.destroy = b.destroy, y.prototype._undestroy = b.undestroy, y.prototype._destroy = function(P, z) {
          z(P);
        };
      }).call(this, n(6), n(2));
    }, function(e, t, n) {
      e.exports = d;
      var r = n(26).codes, o = r.ERR_METHOD_NOT_IMPLEMENTED, l = r.ERR_MULTIPLE_CALLBACK, u = r.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = r.ERR_TRANSFORM_WITH_LENGTH_0, g = n(27);
      function c(h, f) {
        var v = this._transformState;
        v.transforming = !1;
        var E = v.writecb;
        if (E === null)
          return this.emit("error", new l());
        v.writechunk = null, v.writecb = null, f != null && this.push(f), E(h);
        var j = this._readableState;
        j.reading = !1, (j.needReadable || j.length < j.highWaterMark) && this._read(j.highWaterMark);
      }
      function d(h) {
        if (!(this instanceof d))
          return new d(h);
        g.call(this, h), this._transformState = { afterTransform: c.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", T);
      }
      function T() {
        var h = this;
        typeof this._flush != "function" || this._readableState.destroyed ? b(this, null, null) : this._flush(function(f, v) {
          b(h, f, v);
        });
      }
      function b(h, f, v) {
        if (f)
          return h.emit("error", f);
        if (v != null && h.push(v), h._writableState.length)
          throw new s();
        if (h._transformState.transforming)
          throw new u();
        return h.push(null);
      }
      n(7)(d, g), d.prototype.push = function(h, f) {
        return this._transformState.needTransform = !1, g.prototype.push.call(this, h, f);
      }, d.prototype._transform = function(h, f, v) {
        v(new o("_transform()"));
      }, d.prototype._write = function(h, f, v) {
        var E = this._transformState;
        if (E.writecb = v, E.writechunk = h, E.writeencoding = f, !E.transforming) {
          var j = this._readableState;
          (E.needTransform || j.needReadable || j.length < j.highWaterMark) && this._read(j.highWaterMark);
        }
      }, d.prototype._read = function(h) {
        var f = this._transformState;
        f.writechunk === null || f.transforming ? f.needTransform = !0 : (f.transforming = !0, this._transform(f.writechunk, f.writeencoding, f.afterTransform));
      }, d.prototype._destroy = function(h, f) {
        g.prototype._destroy.call(this, h, function(v) {
          f(v);
        });
      };
    }, function(e, t, n) {
      (function(r) {
        var o = n(190), l = n(85), u = n(192), s = n(193), g = n(86), c = t;
        c.request = function(d, T) {
          d = typeof d == "string" ? g.parse(d) : u(d);
          var b = r.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", h = d.protocol || b, f = d.hostname || d.host, v = d.port, E = d.path || "/";
          f && f.indexOf(":") !== -1 && (f = "[" + f + "]"), d.url = (f ? h + "//" + f : "") + (v ? ":" + v : "") + E, d.method = (d.method || "GET").toUpperCase(), d.headers = d.headers || {};
          var j = new o(d);
          return T && j.on("response", T), j;
        }, c.get = function(d, T) {
          var b = c.request(d, T);
          return b.end(), b;
        }, c.ClientRequest = o, c.IncomingMessage = l.IncomingMessage, c.Agent = function() {
        }, c.Agent.defaultMaxSockets = 4, c.globalAgent = new c.Agent(), c.STATUS_CODES = s, c.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
      }).call(this, n(6));
    }, function(e, t, n) {
      (function(r) {
        t.fetch = c(r.fetch) && c(r.ReadableStream), t.writableStream = c(r.WritableStream), t.abortController = c(r.AbortController), t.blobConstructor = !1;
        try {
          new Blob([new ArrayBuffer(1)]), t.blobConstructor = !0;
        } catch {
        }
        var o;
        function l() {
          if (o !== void 0)
            return o;
          if (r.XMLHttpRequest) {
            o = new r.XMLHttpRequest();
            try {
              o.open("GET", r.XDomainRequest ? "/" : "https://example.com");
            } catch {
              o = null;
            }
          } else
            o = null;
          return o;
        }
        function u(d) {
          var T = l();
          if (!T)
            return !1;
          try {
            return T.responseType = d, T.responseType === d;
          } catch {
          }
          return !1;
        }
        var s = r.ArrayBuffer !== void 0, g = s && c(r.ArrayBuffer.prototype.slice);
        function c(d) {
          return typeof d == "function";
        }
        t.arraybuffer = t.fetch || s && u("arraybuffer"), t.msstream = !t.fetch && g && u("ms-stream"), t.mozchunkedarraybuffer = !t.fetch && s && u("moz-chunked-arraybuffer"), t.overrideMimeType = t.fetch || !!l() && c(l().overrideMimeType), t.vbArray = c(r.VBArray), o = null;
      }).call(this, n(6));
    }, function(e, t, n) {
      (function(r, o, l) {
        var u = n(84), s = n(7), g = n(31), c = t.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, d = t.IncomingMessage = function(T, b, h, f) {
          var v = this;
          if (g.Readable.call(v), v._mode = h, v.headers = {}, v.rawHeaders = [], v.trailers = {}, v.rawTrailers = [], v.on("end", function() {
            r.nextTick(function() {
              v.emit("close");
            });
          }), h === "fetch") {
            if (v._fetchResponse = b, v.url = b.url, v.statusCode = b.status, v.statusMessage = b.statusText, b.headers.forEach(function(R, p) {
              v.headers[p.toLowerCase()] = R, v.rawHeaders.push(p, R);
            }), u.writableStream) {
              var E = new WritableStream({ write: function(R) {
                return new Promise(function(p, M) {
                  v._destroyed ? M() : v.push(new o(R)) ? p() : v._resumeFetch = p;
                });
              }, close: function() {
                l.clearTimeout(f), v._destroyed || v.push(null);
              }, abort: function(R) {
                v._destroyed || v.emit("error", R);
              } });
              try {
                return void b.body.pipeTo(E).catch(function(R) {
                  l.clearTimeout(f), v._destroyed || v.emit("error", R);
                });
              } catch {
              }
            }
            var j = b.body.getReader();
            (function R() {
              j.read().then(function(p) {
                if (!v._destroyed) {
                  if (p.done)
                    return l.clearTimeout(f), void v.push(null);
                  v.push(new o(p.value)), R();
                }
              }).catch(function(p) {
                l.clearTimeout(f), v._destroyed || v.emit("error", p);
              });
            })();
          } else if (v._xhr = T, v._pos = 0, v.url = T.responseURL, v.statusCode = T.status, v.statusMessage = T.statusText, T.getAllResponseHeaders().split(/\r?\n/).forEach(function(R) {
            var p = R.match(/^([^:]+):\s*(.*)/);
            if (p) {
              var M = p[1].toLowerCase();
              M === "set-cookie" ? (v.headers[M] === void 0 && (v.headers[M] = []), v.headers[M].push(p[2])) : v.headers[M] !== void 0 ? v.headers[M] += ", " + p[2] : v.headers[M] = p[2], v.rawHeaders.push(p[1], p[2]);
            }
          }), v._charset = "x-user-defined", !u.overrideMimeType) {
            var B = v.rawHeaders["mime-type"];
            if (B) {
              var I = B.match(/;\s*charset=([^;])(;|$)/);
              I && (v._charset = I[1].toLowerCase());
            }
            v._charset || (v._charset = "utf-8");
          }
        };
        s(d, g.Readable), d.prototype._read = function() {
          var T = this._resumeFetch;
          T && (this._resumeFetch = null, T());
        }, d.prototype._onXHRProgress = function() {
          var T = this, b = T._xhr, h = null;
          switch (T._mode) {
            case "text:vbarray":
              if (b.readyState !== c.DONE)
                break;
              try {
                h = new l.VBArray(b.responseBody).toArray();
              } catch {
              }
              if (h !== null) {
                T.push(new o(h));
                break;
              }
            case "text":
              try {
                h = b.responseText;
              } catch {
                T._mode = "text:vbarray";
                break;
              }
              if (h.length > T._pos) {
                var f = h.substr(T._pos);
                if (T._charset === "x-user-defined") {
                  for (var v = new o(f.length), E = 0; E < f.length; E++)
                    v[E] = 255 & f.charCodeAt(E);
                  T.push(v);
                } else
                  T.push(f, T._charset);
                T._pos = h.length;
              }
              break;
            case "arraybuffer":
              if (b.readyState !== c.DONE || !b.response)
                break;
              h = b.response, T.push(new o(new Uint8Array(h)));
              break;
            case "moz-chunked-arraybuffer":
              if (h = b.response, b.readyState !== c.LOADING || !h)
                break;
              T.push(new o(new Uint8Array(h)));
              break;
            case "ms-stream":
              if (h = b.response, b.readyState !== c.LOADING)
                break;
              var j = new l.MSStreamReader();
              j.onprogress = function() {
                j.result.byteLength > T._pos && (T.push(new o(new Uint8Array(j.result.slice(T._pos)))), T._pos = j.result.byteLength);
              }, j.onload = function() {
                T.push(null);
              }, j.readAsArrayBuffer(h);
          }
          T._xhr.readyState === c.DONE && T._mode !== "ms-stream" && T.push(null);
        };
      }).call(this, n(2), n(5).Buffer, n(6));
    }, function(e, t, n) {
      var r = n(194), o = n(196);
      function l() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      t.parse = I, t.resolve = function(R, p) {
        return I(R, !1, !0).resolve(p);
      }, t.resolveObject = function(R, p) {
        return R ? I(R, !1, !0).resolveObject(p) : p;
      }, t.format = function(R) {
        return o.isString(R) && (R = I(R)), R instanceof l ? R.format() : l.prototype.format.call(R);
      }, t.Url = l;
      var u = /^([a-z0-9.+-]+:)/i, s = /:[0-9]*$/, g = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, c = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), d = ["'"].concat(c), T = ["%", "/", "?", ";", "#"].concat(d), b = ["/", "?", "#"], h = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, v = { javascript: !0, "javascript:": !0 }, E = { javascript: !0, "javascript:": !0 }, j = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, B = n(197);
      function I(R, p, M) {
        if (R && o.isObject(R) && R instanceof l)
          return R;
        var $ = new l();
        return $.parse(R, p, M), $;
      }
      l.prototype.parse = function(R, p, M) {
        if (!o.isString(R))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof R);
        var $ = R.indexOf("?"), Z = $ !== -1 && $ < R.indexOf("#") ? "?" : "#", _ = R.split(Z);
        _[0] = _[0].replace(/\\/g, "/");
        var y = R = _.join(Z);
        if (y = y.trim(), !M && R.split("#").length === 1) {
          var C = g.exec(y);
          if (C)
            return this.path = y, this.href = y, this.pathname = C[1], C[2] ? (this.search = C[2], this.query = p ? B.parse(this.search.substr(1)) : this.search.substr(1)) : p && (this.search = "", this.query = {}), this;
        }
        var w = u.exec(y);
        if (w) {
          var x = (w = w[0]).toLowerCase();
          this.protocol = x, y = y.substr(w.length);
        }
        if (M || w || y.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var H = y.substr(0, 2) === "//";
          !H || w && E[w] || (y = y.substr(2), this.slashes = !0);
        }
        if (!E[w] && (H || w && !j[w])) {
          for (var L, N, P = -1, z = 0; z < b.length; z++)
            (O = y.indexOf(b[z])) !== -1 && (P === -1 || O < P) && (P = O);
          for ((N = P === -1 ? y.lastIndexOf("@") : y.lastIndexOf("@", P)) !== -1 && (L = y.slice(0, N), y = y.slice(N + 1), this.auth = decodeURIComponent(L)), P = -1, z = 0; z < T.length; z++) {
            var O;
            (O = y.indexOf(T[z])) !== -1 && (P === -1 || O < P) && (P = O);
          }
          P === -1 && (P = y.length), this.host = y.slice(0, P), y = y.slice(P), this.parseHost(), this.hostname = this.hostname || "";
          var m = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!m)
            for (var F = this.hostname.split(/\./), V = (z = 0, F.length); z < V; z++) {
              var Q = F[z];
              if (Q && !Q.match(h)) {
                for (var ee = "", ne = 0, Y = Q.length; ne < Y; ne++)
                  Q.charCodeAt(ne) > 127 ? ee += "x" : ee += Q[ne];
                if (!ee.match(h)) {
                  var G = F.slice(0, z), S = F.slice(z + 1), A = Q.match(f);
                  A && (G.push(A[1]), S.unshift(A[2])), S.length && (y = "/" + S.join(".") + y), this.hostname = G.join(".");
                  break;
                }
              }
            }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m || (this.hostname = r.toASCII(this.hostname));
          var U = this.port ? ":" + this.port : "", J = this.hostname || "";
          this.host = J + U, this.href += this.host, m && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), y[0] !== "/" && (y = "/" + y));
        }
        if (!v[x])
          for (z = 0, V = d.length; z < V; z++) {
            var K = d[z];
            if (y.indexOf(K) !== -1) {
              var re = encodeURIComponent(K);
              re === K && (re = escape(K)), y = y.split(K).join(re);
            }
          }
        var se = y.indexOf("#");
        se !== -1 && (this.hash = y.substr(se), y = y.slice(0, se));
        var fe = y.indexOf("?");
        if (fe !== -1 ? (this.search = y.substr(fe), this.query = y.substr(fe + 1), p && (this.query = B.parse(this.query)), y = y.slice(0, fe)) : p && (this.search = "", this.query = {}), y && (this.pathname = y), j[x] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          U = this.pathname || "";
          var we = this.search || "";
          this.path = U + we;
        }
        return this.href = this.format(), this;
      }, l.prototype.format = function() {
        var R = this.auth || "";
        R && (R = (R = encodeURIComponent(R)).replace(/%3A/i, ":"), R += "@");
        var p = this.protocol || "", M = this.pathname || "", $ = this.hash || "", Z = !1, _ = "";
        this.host ? Z = R + this.host : this.hostname && (Z = R + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Z += ":" + this.port)), this.query && o.isObject(this.query) && Object.keys(this.query).length && (_ = B.stringify(this.query));
        var y = this.search || _ && "?" + _ || "";
        return p && p.substr(-1) !== ":" && (p += ":"), this.slashes || (!p || j[p]) && Z !== !1 ? (Z = "//" + (Z || ""), M && M.charAt(0) !== "/" && (M = "/" + M)) : Z || (Z = ""), $ && $.charAt(0) !== "#" && ($ = "#" + $), y && y.charAt(0) !== "?" && (y = "?" + y), p + Z + (M = M.replace(/[?#]/g, function(C) {
          return encodeURIComponent(C);
        })) + (y = y.replace("#", "%23")) + $;
      }, l.prototype.resolve = function(R) {
        return this.resolveObject(I(R, !1, !0)).format();
      }, l.prototype.resolveObject = function(R) {
        if (o.isString(R)) {
          var p = new l();
          p.parse(R, !1, !0), R = p;
        }
        for (var M = new l(), $ = Object.keys(this), Z = 0; Z < $.length; Z++) {
          var _ = $[Z];
          M[_] = this[_];
        }
        if (M.hash = R.hash, R.href === "")
          return M.href = M.format(), M;
        if (R.slashes && !R.protocol) {
          for (var y = Object.keys(R), C = 0; C < y.length; C++) {
            var w = y[C];
            w !== "protocol" && (M[w] = R[w]);
          }
          return j[M.protocol] && M.hostname && !M.pathname && (M.path = M.pathname = "/"), M.href = M.format(), M;
        }
        if (R.protocol && R.protocol !== M.protocol) {
          if (!j[R.protocol]) {
            for (var x = Object.keys(R), H = 0; H < x.length; H++) {
              var L = x[H];
              M[L] = R[L];
            }
            return M.href = M.format(), M;
          }
          if (M.protocol = R.protocol, R.host || E[R.protocol])
            M.pathname = R.pathname;
          else {
            for (var N = (R.pathname || "").split("/"); N.length && !(R.host = N.shift()); )
              ;
            R.host || (R.host = ""), R.hostname || (R.hostname = ""), N[0] !== "" && N.unshift(""), N.length < 2 && N.unshift(""), M.pathname = N.join("/");
          }
          if (M.search = R.search, M.query = R.query, M.host = R.host || "", M.auth = R.auth, M.hostname = R.hostname || R.host, M.port = R.port, M.pathname || M.search) {
            var P = M.pathname || "", z = M.search || "";
            M.path = P + z;
          }
          return M.slashes = M.slashes || R.slashes, M.href = M.format(), M;
        }
        var O = M.pathname && M.pathname.charAt(0) === "/", m = R.host || R.pathname && R.pathname.charAt(0) === "/", F = m || O || M.host && R.pathname, V = F, Q = M.pathname && M.pathname.split("/") || [], ee = (N = R.pathname && R.pathname.split("/") || [], M.protocol && !j[M.protocol]);
        if (ee && (M.hostname = "", M.port = null, M.host && (Q[0] === "" ? Q[0] = M.host : Q.unshift(M.host)), M.host = "", R.protocol && (R.hostname = null, R.port = null, R.host && (N[0] === "" ? N[0] = R.host : N.unshift(R.host)), R.host = null), F = F && (N[0] === "" || Q[0] === "")), m)
          M.host = R.host || R.host === "" ? R.host : M.host, M.hostname = R.hostname || R.hostname === "" ? R.hostname : M.hostname, M.search = R.search, M.query = R.query, Q = N;
        else if (N.length)
          Q || (Q = []), Q.pop(), Q = Q.concat(N), M.search = R.search, M.query = R.query;
        else if (!o.isNullOrUndefined(R.search))
          return ee && (M.hostname = M.host = Q.shift(), (A = !!(M.host && M.host.indexOf("@") > 0) && M.host.split("@")) && (M.auth = A.shift(), M.host = M.hostname = A.shift())), M.search = R.search, M.query = R.query, o.isNull(M.pathname) && o.isNull(M.search) || (M.path = (M.pathname ? M.pathname : "") + (M.search ? M.search : "")), M.href = M.format(), M;
        if (!Q.length)
          return M.pathname = null, M.search ? M.path = "/" + M.search : M.path = null, M.href = M.format(), M;
        for (var ne = Q.slice(-1)[0], Y = (M.host || R.host || Q.length > 1) && (ne === "." || ne === "..") || ne === "", G = 0, S = Q.length; S >= 0; S--)
          (ne = Q[S]) === "." ? Q.splice(S, 1) : ne === ".." ? (Q.splice(S, 1), G++) : G && (Q.splice(S, 1), G--);
        if (!F && !V)
          for (; G--; G)
            Q.unshift("..");
        !F || Q[0] === "" || Q[0] && Q[0].charAt(0) === "/" || Q.unshift(""), Y && Q.join("/").substr(-1) !== "/" && Q.push("");
        var A, U = Q[0] === "" || Q[0] && Q[0].charAt(0) === "/";
        return ee && (M.hostname = M.host = U ? "" : Q.length ? Q.shift() : "", (A = !!(M.host && M.host.indexOf("@") > 0) && M.host.split("@")) && (M.auth = A.shift(), M.host = M.hostname = A.shift())), (F = F || M.host && Q.length) && !U && Q.unshift(""), Q.length ? M.pathname = Q.join("/") : (M.pathname = null, M.path = null), o.isNull(M.pathname) && o.isNull(M.search) || (M.path = (M.pathname ? M.pathname : "") + (M.search ? M.search : "")), M.auth = R.auth || M.auth, M.slashes = M.slashes || R.slashes, M.href = M.format(), M;
      }, l.prototype.parseHost = function() {
        var R = this.host, p = s.exec(R);
        p && ((p = p[0]) !== ":" && (this.port = p.substr(1)), R = R.substr(0, R.length - p.length)), R && (this.hostname = R);
      };
    }, function(e, t, n) {
      const r = (o) => o !== null && typeof o == "object" && typeof o.pipe == "function";
      r.writable = (o) => r(o) && o.writable !== !1 && typeof o._write == "function" && typeof o._writableState == "object", r.readable = (o) => r(o) && o.readable !== !1 && typeof o._read == "function" && typeof o._readableState == "object", r.duplex = (o) => r.writable(o) && r.readable(o), r.transform = (o) => r.duplex(o) && typeof o._transform == "function" && typeof o._transformState == "object", e.exports = r;
    }, function(e, t, n) {
      function r(v) {
        return (r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
          return typeof E;
        } : function(E) {
          return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
        })(v);
      }
      function o(v, E) {
        if (!(v instanceof E))
          throw new TypeError("Cannot call a class as a function");
      }
      function l(v, E) {
        if (typeof E != "function" && E !== null)
          throw new TypeError("Super expression must either be null or a function");
        v.prototype = Object.create(E && E.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), E && u(v, E);
      }
      function u(v, E) {
        return (u = Object.setPrototypeOf || function(j, B) {
          return j.__proto__ = B, j;
        })(v, E);
      }
      function s(v) {
        var E = function() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
            return !1;
          if (typeof Proxy == "function")
            return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }();
        return function() {
          var j, B = c(v);
          if (E) {
            var I = c(this).constructor;
            j = Reflect.construct(B, arguments, I);
          } else
            j = B.apply(this, arguments);
          return g(this, j);
        };
      }
      function g(v, E) {
        return !E || r(E) !== "object" && typeof E != "function" ? function(j) {
          if (j === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return j;
        }(v) : E;
      }
      function c(v) {
        return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(E) {
          return E.__proto__ || Object.getPrototypeOf(E);
        })(v);
      }
      var d = n(3).LEVEL, T = n(50), b = n(202), h = n(38)("winston:create-logger");
      function f(v) {
        return "is" + v.charAt(0).toUpperCase() + v.slice(1) + "Enabled";
      }
      e.exports = function() {
        var v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        v.levels = v.levels || T.npm.levels;
        var E = function(B) {
          l(R, B);
          var I = s(R);
          function R(p) {
            return o(this, R), I.call(this, p);
          }
          return R;
        }(b), j = new E(v);
        return Object.keys(v.levels).forEach(function(B) {
          h('Define prototype method for "%s"', B), B !== "log" ? (E.prototype[B] = function() {
            for (var I = this || j, R = arguments.length, p = new Array(R), M = 0; M < R; M++)
              p[M] = arguments[M];
            if (p.length === 1) {
              var $ = p[0], Z = $ && $.message && $ || { message: $ };
              return Z.level = Z[d] = B, I._addDefaultMeta(Z), I.write(Z), this || j;
            }
            return p.length === 0 ? (I.log(B, ""), I) : I.log.apply(I, [B].concat(p));
          }, E.prototype[f(B)] = function() {
            return (this || j).isLevelEnabled(B);
          }) : console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
        }), j;
      };
    }, function(e, t, n) {
      (function(r) {
        function o(T, b) {
          for (var h = 0; h < b.length; h++) {
            var f = b[h];
            f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(T, f.key, f);
          }
        }
        var l = n(18), u = n(51), s = n(38)("winston:exception"), g = n(90), c = n(91), d = n(92);
        e.exports = function() {
          function T(f) {
            if (function(v, E) {
              if (!(v instanceof E))
                throw new TypeError("Cannot call a class as a function");
            }(this, T), !f)
              throw new Error("Logger is required to handle exceptions");
            this.logger = f, this.handlers = /* @__PURE__ */ new Map();
          }
          var b, h;
          return b = T, (h = [{ key: "handle", value: function() {
            for (var f = this, v = arguments.length, E = new Array(v), j = 0; j < v; j++)
              E[j] = arguments[j];
            E.forEach(function(B) {
              if (Array.isArray(B))
                return B.forEach(function(I) {
                  return f._addHandler(I);
                });
              f._addHandler(B);
            }), this.catcher || (this.catcher = this._uncaughtException.bind(this), r.on("uncaughtException", this.catcher));
          } }, { key: "unhandle", value: function() {
            var f = this;
            this.catcher && (r.removeListener("uncaughtException", this.catcher), this.catcher = !1, Array.from(this.handlers.values()).forEach(function(v) {
              return f.logger.unpipe(v);
            }));
          } }, { key: "getAllInfo", value: function(f) {
            var v = f.message;
            return v || typeof f != "string" || (v = f), { error: f, level: "error", message: ["uncaughtException: ".concat(v || "(no error message)"), f.stack || "  No stack trace"].join(`
`), stack: f.stack, exception: !0, date: (/* @__PURE__ */ new Date()).toString(), process: this.getProcessInfo(), os: this.getOsInfo(), trace: this.getTrace(f) };
          } }, { key: "getProcessInfo", value: function() {
            return { pid: r.pid, uid: r.getuid ? r.getuid() : null, gid: r.getgid ? r.getgid() : null, cwd: r.cwd(), execPath: r.execPath, version: r.version, argv: r.argv, memoryUsage: r.memoryUsage() };
          } }, { key: "getOsInfo", value: function() {
            return { loadavg: l.loadavg(), uptime: l.uptime() };
          } }, { key: "getTrace", value: function(f) {
            return (f ? c.parse(f) : c.get()).map(function(v) {
              return { column: v.getColumnNumber(), file: v.getFileName(), function: v.getFunctionName(), line: v.getLineNumber(), method: v.getMethodName(), native: v.isNative() };
            });
          } }, { key: "_addHandler", value: function(f) {
            if (!this.handlers.has(f)) {
              f.handleExceptions = !0;
              var v = new d(f);
              this.handlers.set(f, v), this.logger.pipe(v);
            }
          } }, { key: "_uncaughtException", value: function(f) {
            var v, E = this.getAllInfo(f), j = this._getExceptionHandlers(), B = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(f) : this.logger.exitOnError;
            function I() {
              s("doExit", B), s("process._exiting", r._exiting), B && !r._exiting && (v && clearTimeout(v), r.exit(1));
            }
            if (!j.length && B && (console.warn("winston: exitOnError cannot be true with no exception handlers."), console.warn("winston: not exiting process."), B = !1), !j || j.length === 0)
              return r.nextTick(I);
            u(j, function(R, p) {
              var M = g(p), $ = R.transport || R;
              function Z(_) {
                return function() {
                  s(_), M();
                };
              }
              $._ending = !0, $.once("finish", Z("finished")), $.once("error", Z("error"));
            }, function() {
              return B && I();
            }), this.logger.log(E), B && (v = setTimeout(I, 3e3));
          } }, { key: "_getExceptionHandlers", value: function() {
            return this.logger.transports.filter(function(f) {
              return (f.transport || f).handleExceptions;
            });
          } }]) && o(b.prototype, h), T;
        }();
      }).call(this, n(2));
    }, function(e, t, n) {
      var r = n(205);
      e.exports = function(o) {
        var l, u = 0;
        function s() {
          return u || (u = 1, l = o.apply(this, arguments), o = null), l;
        }
        return s.displayName = r(o), s;
      };
    }, function(e, t) {
      function n(r) {
        for (var o in r)
          this[o] = r[o];
      }
      t.get = function(r) {
        var o = Error.stackTraceLimit;
        Error.stackTraceLimit = 1 / 0;
        var l = {}, u = Error.prepareStackTrace;
        Error.prepareStackTrace = function(g, c) {
          return c;
        }, Error.captureStackTrace(l, r || t.get);
        var s = l.stack;
        return Error.prepareStackTrace = u, Error.stackTraceLimit = o, s;
      }, t.parse = function(r) {
        if (!r.stack)
          return [];
        var o = this;
        return r.stack.split(`
`).slice(1).map(function(l) {
          if (l.match(/^\s*[-]{4,}$/))
            return o._createParsedCallSite({ fileName: l, lineNumber: null, functionName: null, typeName: null, methodName: null, columnNumber: null, native: null });
          var u = l.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
          if (u) {
            var s = null, g = null, c = null, d = null, T = null, b = u[5] === "native";
            if (u[1]) {
              var h = (c = u[1]).lastIndexOf(".");
              if (c[h - 1] == "." && h--, h > 0) {
                s = c.substr(0, h), g = c.substr(h + 1);
                var f = s.indexOf(".Module");
                f > 0 && (c = c.substr(f + 1), s = s.substr(0, f));
              }
              d = null;
            }
            g && (d = s, T = g), g === "<anonymous>" && (T = null, c = null);
            var v = { fileName: u[2] || null, lineNumber: parseInt(u[3], 10) || null, functionName: c, typeName: d, methodName: T, columnNumber: parseInt(u[4], 10) || null, native: b };
            return o._createParsedCallSite(v);
          }
        }).filter(function(l) {
          return !!l;
        });
      }, ["this", "typeName", "functionName", "methodName", "fileName", "lineNumber", "columnNumber", "function", "evalOrigin"].forEach(function(r) {
        n.prototype[r] = null, n.prototype["get" + r[0].toUpperCase() + r.substr(1)] = function() {
          return this[r];
        };
      }), ["topLevel", "eval", "native", "constructor"].forEach(function(r) {
        n.prototype[r] = !1, n.prototype["is" + r[0].toUpperCase() + r.substr(1)] = function() {
          return this[r];
        };
      }), t._createParsedCallSite = function(r) {
        return new n(r);
      };
    }, function(e, t, n) {
      function r(d) {
        return (r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
          return typeof T;
        } : function(T) {
          return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
        })(d);
      }
      function o(d, T) {
        for (var b = 0; b < T.length; b++) {
          var h = T[b];
          h.enumerable = h.enumerable || !1, h.configurable = !0, "value" in h && (h.writable = !0), Object.defineProperty(d, h.key, h);
        }
      }
      function l(d, T) {
        return (l = Object.setPrototypeOf || function(b, h) {
          return b.__proto__ = h, b;
        })(d, T);
      }
      function u(d) {
        var T = function() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
            return !1;
          if (typeof Proxy == "function")
            return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }();
        return function() {
          var b, h = g(d);
          if (T) {
            var f = g(this).constructor;
            b = Reflect.construct(h, arguments, f);
          } else
            b = h.apply(this, arguments);
          return s(this, b);
        };
      }
      function s(d, T) {
        return !T || r(T) !== "object" && typeof T != "function" ? function(b) {
          if (b === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return b;
        }(d) : T;
      }
      function g(d) {
        return (g = Object.setPrototypeOf ? Object.getPrototypeOf : function(T) {
          return T.__proto__ || Object.getPrototypeOf(T);
        })(d);
      }
      var c = n(32).Writable;
      e.exports = function(d) {
        (function(v, E) {
          if (typeof E != "function" && E !== null)
            throw new TypeError("Super expression must either be null or a function");
          v.prototype = Object.create(E && E.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), E && l(v, E);
        })(f, d);
        var T, b, h = u(f);
        function f(v) {
          var E;
          if (function(j, B) {
            if (!(j instanceof B))
              throw new TypeError("Cannot call a class as a function");
          }(this, f), E = h.call(this, { objectMode: !0 }), !v)
            throw new Error("ExceptionStream requires a TransportStream instance.");
          return E.handleExceptions = !0, E.transport = v, E;
        }
        return T = f, (b = [{ key: "_write", value: function(v, E, j) {
          return v.exception ? this.transport.log(v, j) : (j(), !0);
        } }]) && o(T.prototype, b), f;
      }(c);
    }, function(e, t, n) {
      (function(r) {
        function o(T, b) {
          for (var h = 0; h < b.length; h++) {
            var f = b[h];
            f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(T, f.key, f);
          }
        }
        var l = n(18), u = n(51), s = n(38)("winston:rejection"), g = n(90), c = n(91), d = n(92);
        e.exports = function() {
          function T(f) {
            if (function(v, E) {
              if (!(v instanceof E))
                throw new TypeError("Cannot call a class as a function");
            }(this, T), !f)
              throw new Error("Logger is required to handle rejections");
            this.logger = f, this.handlers = /* @__PURE__ */ new Map();
          }
          var b, h;
          return b = T, (h = [{ key: "handle", value: function() {
            for (var f = this, v = arguments.length, E = new Array(v), j = 0; j < v; j++)
              E[j] = arguments[j];
            E.forEach(function(B) {
              if (Array.isArray(B))
                return B.forEach(function(I) {
                  return f._addHandler(I);
                });
              f._addHandler(B);
            }), this.catcher || (this.catcher = this._unhandledRejection.bind(this), r.on("unhandledRejection", this.catcher));
          } }, { key: "unhandle", value: function() {
            var f = this;
            this.catcher && (r.removeListener("unhandledRejection", this.catcher), this.catcher = !1, Array.from(this.handlers.values()).forEach(function(v) {
              return f.logger.unpipe(v);
            }));
          } }, { key: "getAllInfo", value: function(f) {
            var v = f.message;
            return v || typeof f != "string" || (v = f), { error: f, level: "error", message: ["unhandledRejection: ".concat(v || "(no error message)"), f.stack || "  No stack trace"].join(`
`), stack: f.stack, exception: !0, date: (/* @__PURE__ */ new Date()).toString(), process: this.getProcessInfo(), os: this.getOsInfo(), trace: this.getTrace(f) };
          } }, { key: "getProcessInfo", value: function() {
            return { pid: r.pid, uid: r.getuid ? r.getuid() : null, gid: r.getgid ? r.getgid() : null, cwd: r.cwd(), execPath: r.execPath, version: r.version, argv: r.argv, memoryUsage: r.memoryUsage() };
          } }, { key: "getOsInfo", value: function() {
            return { loadavg: l.loadavg(), uptime: l.uptime() };
          } }, { key: "getTrace", value: function(f) {
            return (f ? c.parse(f) : c.get()).map(function(v) {
              return { column: v.getColumnNumber(), file: v.getFileName(), function: v.getFunctionName(), line: v.getLineNumber(), method: v.getMethodName(), native: v.isNative() };
            });
          } }, { key: "_addHandler", value: function(f) {
            if (!this.handlers.has(f)) {
              f.handleRejections = !0;
              var v = new d(f);
              this.handlers.set(f, v), this.logger.pipe(v);
            }
          } }, { key: "_unhandledRejection", value: function(f) {
            var v, E = this.getAllInfo(f), j = this._getRejectionHandlers(), B = typeof this.logger.exitOnError == "function" ? this.logger.exitOnError(f) : this.logger.exitOnError;
            function I() {
              s("doExit", B), s("process._exiting", r._exiting), B && !r._exiting && (v && clearTimeout(v), r.exit(1));
            }
            if (!j.length && B && (console.warn("winston: exitOnError cannot be true with no rejection handlers."), console.warn("winston: not exiting process."), B = !1), !j || j.length === 0)
              return r.nextTick(I);
            u(j, function(R, p) {
              var M = g(p), $ = R.transport || R;
              function Z(_) {
                return function() {
                  s(_), M();
                };
              }
              $._ending = !0, $.once("finish", Z("finished")), $.once("error", Z("error"));
            }, function() {
              return B && I();
            }), this.logger.log(E), B && (v = setTimeout(I, 3e3));
          } }, { key: "_getRejectionHandlers", value: function() {
            return this.logger.transports.filter(function(f) {
              return (f.transport || f).handleRejections;
            });
          } }]) && o(b.prototype, h), T;
        }();
      }).call(this, n(2));
    }, function(e, t, n) {
      e.exports = { asArray: n(212), asBoolStrict: n(213), asBool: n(214), asPortNumber: n(215), asEnum: n(216), asFloatNegative: n(217), asFloatPositive: n(218), asFloat: n(54), asIntNegative: n(219), asIntPositive: n(95), asInt: n(53), asJsonArray: n(220), asJsonObject: n(221), asJson: n(55), asRegExp: n(222), asString: n(33), asUrlObject: n(96), asUrlString: n(223), asEmailString: n(224) };
    }, function(e, t, n) {
      const r = n(53);
      e.exports = function(o) {
        const l = r(o);
        if (l < 0)
          throw new Error("should be a positive integer");
        return l;
      };
    }, function(e, t, n) {
      const r = n(33);
      e.exports = function(o) {
        const l = r(o);
        try {
          return new URL(l);
        } catch {
          throw new Error("should be a valid URL");
        }
      };
    }, function(e, t, n) {
      const r = {};
      r.web = n(24), n(98);
      const o = { v1: {} };
      o.v1.signaling = {}, o.v1.signaling.api = n(9), o.v1.signaling.api.SignalingClient = function(h, f, v) {
        v || (v = {}), v.format = "text", this.client_ = new r.web.GrpcWebClientBase(v), this.hostname_ = h;
      }, o.v1.signaling.api.SignalingPromiseClient = function(h, f, v) {
        v || (v = {}), v.format = "text", this.client_ = new r.web.GrpcWebClientBase(v), this.hostname_ = h;
      };
      const l = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/GetHealth", r.web.MethodType.UNARY, o.v1.signaling.api.GetHealthRequest, o.v1.signaling.api.GetHealthResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetHealthResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.GetHealthResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetHealthResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.getHealth = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/GetHealth", h, f || {}, l, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.getHealth = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/GetHealth", h, f || {}, l);
      };
      const u = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/CreatePeer", r.web.MethodType.UNARY, o.v1.signaling.api.CreatePeerRequest, o.v1.signaling.api.CreatePeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.CreatePeerResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.CreatePeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.CreatePeerResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.createPeer = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/CreatePeer", h, f || {}, u, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.createPeer = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/CreatePeer", h, f || {}, u);
      };
      const s = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/DeletePeer", r.web.MethodType.UNARY, o.v1.signaling.api.DeletePeerRequest, o.v1.signaling.api.DeletePeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.DeletePeerResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.DeletePeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.DeletePeerResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.deletePeer = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/DeletePeer", h, f || {}, s, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.deletePeer = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/DeletePeer", h, f || {}, s);
      };
      const g = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/RefreshPeer", r.web.MethodType.UNARY, o.v1.signaling.api.RefreshPeerRequest, o.v1.signaling.api.RefreshPeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.RefreshPeerResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.RefreshPeerResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.RefreshPeerResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.refreshPeer = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/RefreshPeer", h, f || {}, g, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.refreshPeer = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/RefreshPeer", h, f || {}, g);
      };
      const c = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/GetPeers", r.web.MethodType.UNARY, o.v1.signaling.api.GetPeersRequest, o.v1.signaling.api.GetPeersResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetPeersResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.GetPeersResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetPeersResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.getPeers = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/GetPeers", h, f || {}, c, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.getPeers = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/GetPeers", h, f || {}, c);
      };
      const d = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/GetIceServers", r.web.MethodType.UNARY, o.v1.signaling.api.GetIceServersRequest, o.v1.signaling.api.GetIceServersResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetIceServersResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.GetIceServersResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.GetIceServersResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.getIceServers = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/GetIceServers", h, f || {}, d, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.getIceServers = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/GetIceServers", h, f || {}, d);
      };
      const T = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/SendSignal", r.web.MethodType.UNARY, o.v1.signaling.api.SendSignalRequest, o.v1.signaling.api.SendSignalResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.SendSignalResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.SendSignalResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.SendSignalResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.sendSignal = function(h, f, v) {
        return this.client_.rpcCall(this.hostname_ + "/v1.signaling.api.Signaling/SendSignal", h, f || {}, T, v);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.sendSignal = function(h, f) {
        return this.client_.unaryCall(this.hostname_ + "/v1.signaling.api.Signaling/SendSignal", h, f || {}, T);
      };
      const b = new r.web.MethodDescriptor("/v1.signaling.api.Signaling/ReceiveSignalStream", r.web.MethodType.SERVER_STREAMING, o.v1.signaling.api.ReceiveSignalStreamRequest, o.v1.signaling.api.ReceiveSignalStreamResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.ReceiveSignalStreamResponse.deserializeBinary);
      new r.web.AbstractClientBase.MethodInfo(o.v1.signaling.api.ReceiveSignalStreamResponse, function(h) {
        return h.serializeBinary();
      }, o.v1.signaling.api.ReceiveSignalStreamResponse.deserializeBinary), o.v1.signaling.api.SignalingClient.prototype.receiveSignalStream = function(h, f) {
        return this.client_.serverStreaming(this.hostname_ + "/v1.signaling.api.Signaling/ReceiveSignalStream", h, f || {}, b);
      }, o.v1.signaling.api.SignalingPromiseClient.prototype.receiveSignalStream = function(h, f) {
        return this.client_.serverStreaming(this.hostname_ + "/v1.signaling.api.Signaling/ReceiveSignalStream", h, f || {}, b);
      }, e.exports = o.v1.signaling.api;
    }, function(e, t, n) {
      var r = n(99), o = r, l = Function("return this")();
      o.exportSymbol("proto.google.protobuf.BoolValue", null, l), o.exportSymbol("proto.google.protobuf.BytesValue", null, l), o.exportSymbol("proto.google.protobuf.DoubleValue", null, l), o.exportSymbol("proto.google.protobuf.FloatValue", null, l), o.exportSymbol("proto.google.protobuf.Int32Value", null, l), o.exportSymbol("proto.google.protobuf.Int64Value", null, l), o.exportSymbol("proto.google.protobuf.StringValue", null, l), o.exportSymbol("proto.google.protobuf.UInt32Value", null, l), o.exportSymbol("proto.google.protobuf.UInt64Value", null, l), proto.google.protobuf.DoubleValue = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.DoubleValue, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.DoubleValue.displayName = "proto.google.protobuf.DoubleValue"), proto.google.protobuf.FloatValue = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.FloatValue, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.FloatValue.displayName = "proto.google.protobuf.FloatValue"), proto.google.protobuf.Int64Value = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.Int64Value, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.Int64Value.displayName = "proto.google.protobuf.Int64Value"), proto.google.protobuf.UInt64Value = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.UInt64Value, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.UInt64Value.displayName = "proto.google.protobuf.UInt64Value"), proto.google.protobuf.Int32Value = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.Int32Value, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.Int32Value.displayName = "proto.google.protobuf.Int32Value"), proto.google.protobuf.UInt32Value = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.UInt32Value, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.UInt32Value.displayName = "proto.google.protobuf.UInt32Value"), proto.google.protobuf.BoolValue = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.BoolValue, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.BoolValue.displayName = "proto.google.protobuf.BoolValue"), proto.google.protobuf.StringValue = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.StringValue, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.StringValue.displayName = "proto.google.protobuf.StringValue"), proto.google.protobuf.BytesValue = function(u) {
        r.Message.initialize(this, u, 0, -1, null, null);
      }, o.inherits(proto.google.protobuf.BytesValue, r.Message), o.DEBUG && !COMPILED && (proto.google.protobuf.BytesValue.displayName = "proto.google.protobuf.BytesValue"), r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.DoubleValue.prototype.toObject = function(u) {
        return proto.google.protobuf.DoubleValue.toObject(u, this);
      }, proto.google.protobuf.DoubleValue.toObject = function(u, s) {
        var g = { value: r.Message.getFloatingPointFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.DoubleValue.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.DoubleValue();
        return proto.google.protobuf.DoubleValue.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.DoubleValue.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readDouble();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.DoubleValue.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.DoubleValue.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.DoubleValue.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeDouble(1, g);
      }, proto.google.protobuf.DoubleValue.prototype.getValue = function() {
        return r.Message.getFloatingPointFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.DoubleValue.prototype.setValue = function(u) {
        return r.Message.setProto3FloatField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.FloatValue.prototype.toObject = function(u) {
        return proto.google.protobuf.FloatValue.toObject(u, this);
      }, proto.google.protobuf.FloatValue.toObject = function(u, s) {
        var g = { value: r.Message.getFloatingPointFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.FloatValue.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.FloatValue();
        return proto.google.protobuf.FloatValue.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.FloatValue.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readFloat();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.FloatValue.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.FloatValue.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.FloatValue.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeFloat(1, g);
      }, proto.google.protobuf.FloatValue.prototype.getValue = function() {
        return r.Message.getFloatingPointFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.FloatValue.prototype.setValue = function(u) {
        return r.Message.setProto3FloatField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Int64Value.prototype.toObject = function(u) {
        return proto.google.protobuf.Int64Value.toObject(u, this);
      }, proto.google.protobuf.Int64Value.toObject = function(u, s) {
        var g = { value: r.Message.getFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.Int64Value.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.Int64Value();
        return proto.google.protobuf.Int64Value.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.Int64Value.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readInt64();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.Int64Value.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.Int64Value.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.Int64Value.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeInt64(1, g);
      }, proto.google.protobuf.Int64Value.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.Int64Value.prototype.setValue = function(u) {
        return r.Message.setProto3IntField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UInt64Value.prototype.toObject = function(u) {
        return proto.google.protobuf.UInt64Value.toObject(u, this);
      }, proto.google.protobuf.UInt64Value.toObject = function(u, s) {
        var g = { value: r.Message.getFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.UInt64Value.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.UInt64Value();
        return proto.google.protobuf.UInt64Value.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.UInt64Value.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readUint64();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.UInt64Value.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.UInt64Value.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.UInt64Value.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeUint64(1, g);
      }, proto.google.protobuf.UInt64Value.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.UInt64Value.prototype.setValue = function(u) {
        return r.Message.setProto3IntField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Int32Value.prototype.toObject = function(u) {
        return proto.google.protobuf.Int32Value.toObject(u, this);
      }, proto.google.protobuf.Int32Value.toObject = function(u, s) {
        var g = { value: r.Message.getFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.Int32Value.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.Int32Value();
        return proto.google.protobuf.Int32Value.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.Int32Value.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readInt32();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.Int32Value.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.Int32Value.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.Int32Value.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeInt32(1, g);
      }, proto.google.protobuf.Int32Value.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.Int32Value.prototype.setValue = function(u) {
        return r.Message.setProto3IntField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.UInt32Value.prototype.toObject = function(u) {
        return proto.google.protobuf.UInt32Value.toObject(u, this);
      }, proto.google.protobuf.UInt32Value.toObject = function(u, s) {
        var g = { value: r.Message.getFieldWithDefault(s, 1, 0) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.UInt32Value.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.UInt32Value();
        return proto.google.protobuf.UInt32Value.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.UInt32Value.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readUint32();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.UInt32Value.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.UInt32Value.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.UInt32Value.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) !== 0 && s.writeUint32(1, g);
      }, proto.google.protobuf.UInt32Value.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, 0);
      }, proto.google.protobuf.UInt32Value.prototype.setValue = function(u) {
        return r.Message.setProto3IntField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.BoolValue.prototype.toObject = function(u) {
        return proto.google.protobuf.BoolValue.toObject(u, this);
      }, proto.google.protobuf.BoolValue.toObject = function(u, s) {
        var g = { value: r.Message.getBooleanFieldWithDefault(s, 1, !1) };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.BoolValue.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.BoolValue();
        return proto.google.protobuf.BoolValue.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.BoolValue.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readBool();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.BoolValue.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.BoolValue.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.BoolValue.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()) && s.writeBool(1, g);
      }, proto.google.protobuf.BoolValue.prototype.getValue = function() {
        return r.Message.getBooleanFieldWithDefault(this, 1, !1);
      }, proto.google.protobuf.BoolValue.prototype.setValue = function(u) {
        return r.Message.setProto3BooleanField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.StringValue.prototype.toObject = function(u) {
        return proto.google.protobuf.StringValue.toObject(u, this);
      }, proto.google.protobuf.StringValue.toObject = function(u, s) {
        var g = { value: r.Message.getFieldWithDefault(s, 1, "") };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.StringValue.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.StringValue();
        return proto.google.protobuf.StringValue.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.StringValue.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readString();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.StringValue.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.StringValue.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.StringValue.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue()).length > 0 && s.writeString(1, g);
      }, proto.google.protobuf.StringValue.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.google.protobuf.StringValue.prototype.setValue = function(u) {
        return r.Message.setProto3StringField(this, 1, u);
      }, r.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.BytesValue.prototype.toObject = function(u) {
        return proto.google.protobuf.BytesValue.toObject(u, this);
      }, proto.google.protobuf.BytesValue.toObject = function(u, s) {
        var g = { value: s.getValue_asB64() };
        return u && (g.$jspbMessageInstance = s), g;
      }), proto.google.protobuf.BytesValue.deserializeBinary = function(u) {
        var s = new r.BinaryReader(u), g = new proto.google.protobuf.BytesValue();
        return proto.google.protobuf.BytesValue.deserializeBinaryFromReader(g, s);
      }, proto.google.protobuf.BytesValue.deserializeBinaryFromReader = function(u, s) {
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              var g = s.readBytes();
              u.setValue(g);
              break;
            default:
              s.skipField();
          }
        return u;
      }, proto.google.protobuf.BytesValue.prototype.serializeBinary = function() {
        var u = new r.BinaryWriter();
        return proto.google.protobuf.BytesValue.serializeBinaryToWriter(this, u), u.getResultBuffer();
      }, proto.google.protobuf.BytesValue.serializeBinaryToWriter = function(u, s) {
        var g;
        (g = u.getValue_asU8()).length > 0 && s.writeBytes(1, g);
      }, proto.google.protobuf.BytesValue.prototype.getValue = function() {
        return r.Message.getFieldWithDefault(this, 1, "");
      }, proto.google.protobuf.BytesValue.prototype.getValue_asB64 = function() {
        return r.Message.bytesAsB64(this.getValue());
      }, proto.google.protobuf.BytesValue.prototype.getValue_asU8 = function() {
        return r.Message.bytesAsU8(this.getValue());
      }, proto.google.protobuf.BytesValue.prototype.setValue = function(u) {
        return r.Message.setProto3BytesField(this, 1, u);
      }, o.object.extend(t, proto.google.protobuf);
    }, function(module, exports, __webpack_require__) {
      (function(global, Buffer) {
        var $jscomp = $jscomp || {};
        $jscomp.scope = {}, $jscomp.findInternal = function(e, t, n) {
          e instanceof String && (e = String(e));
          for (var r = e.length, o = 0; o < r; o++) {
            var l = e[o];
            if (t.call(n, l, o, e))
              return { i: o, v: l };
          }
          return { i: -1, v: void 0 };
        }, $jscomp.ASSUME_ES5 = !1, $jscomp.ASSUME_NO_NATIVE_MAP = !1, $jscomp.ASSUME_NO_NATIVE_SET = !1, $jscomp.SIMPLE_FROUND_POLYFILL = !1, $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(e, t, n) {
          e != Array.prototype && e != Object.prototype && (e[t] = n.value);
        }, $jscomp.getGlobal = function(e) {
          return typeof window < "u" && window === e ? e : global !== void 0 && global != null ? global : e;
        }, $jscomp.global = $jscomp.getGlobal(this), $jscomp.polyfill = function(e, t, n, r) {
          if (t) {
            for (n = $jscomp.global, e = e.split("."), r = 0; r < e.length - 1; r++) {
              var o = e[r];
              o in n || (n[o] = {}), n = n[o];
            }
            (t = t(r = n[e = e[e.length - 1]])) != r && t != null && $jscomp.defineProperty(n, e, { configurable: !0, writable: !0, value: t });
          }
        }, $jscomp.polyfill("Array.prototype.findIndex", function(e) {
          return e || function(t, n) {
            return $jscomp.findInternal(this, t, n).i;
          };
        }, "es6", "es3"), $jscomp.checkStringArgs = function(e, t, n) {
          if (e == null)
            throw new TypeError("The 'this' value for String.prototype." + n + " must not be null or undefined");
          if (t instanceof RegExp)
            throw new TypeError("First argument to String.prototype." + n + " must not be a regular expression");
          return e + "";
        }, $jscomp.polyfill("String.prototype.endsWith", function(e) {
          return e || function(t, n) {
            var r = $jscomp.checkStringArgs(this, t, "endsWith");
            t += "", n === void 0 && (n = r.length), n = Math.max(0, Math.min(0 | n, r.length));
            for (var o = t.length; 0 < o && 0 < n; )
              if (r[--n] != t[--o])
                return !1;
            return 0 >= o;
          };
        }, "es6", "es3"), $jscomp.polyfill("Array.prototype.find", function(e) {
          return e || function(t, n) {
            return $jscomp.findInternal(this, t, n).v;
          };
        }, "es6", "es3"), $jscomp.polyfill("String.prototype.startsWith", function(e) {
          return e || function(t, n) {
            var r = $jscomp.checkStringArgs(this, t, "startsWith");
            t += "";
            var o = r.length, l = t.length;
            n = Math.max(0, Math.min(0 | n, r.length));
            for (var u = 0; u < l && n < o; )
              if (r[n++] != t[u++])
                return !1;
            return u >= l;
          };
        }, "es6", "es3"), $jscomp.polyfill("String.prototype.repeat", function(e) {
          return e || function(t) {
            var n = $jscomp.checkStringArgs(this, null, "repeat");
            if (0 > t || 1342177279 < t)
              throw new RangeError("Invalid count value");
            t |= 0;
            for (var r = ""; t; )
              1 & t && (r += n), (t >>>= 1) && (n += n);
            return r;
          };
        }, "es6", "es3");
        var COMPILED = !0, goog = goog || {};
        goog.global = this || self, goog.isDef = function(e) {
          return e !== void 0;
        }, goog.isString = function(e) {
          return typeof e == "string";
        }, goog.isBoolean = function(e) {
          return typeof e == "boolean";
        }, goog.isNumber = function(e) {
          return typeof e == "number";
        }, goog.exportPath_ = function(e, t, n) {
          e = e.split("."), n = n || goog.global, e[0] in n || n.execScript === void 0 || n.execScript("var " + e[0]);
          for (var r; e.length && (r = e.shift()); )
            !e.length && goog.isDef(t) ? n[r] = t : n = n[r] && n[r] !== Object.prototype[r] ? n[r] : n[r] = {};
        }, goog.define = function(e, t) {
          return t;
        }, goog.FEATURESET_YEAR = 2012, goog.DEBUG = !0, goog.LOCALE = "en", goog.TRUSTED_SITE = !0, goog.STRICT_MODE_COMPATIBLE = !1, goog.DISALLOW_TEST_ONLY_CODE = !goog.DEBUG, goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1, goog.provide = function(e) {
          if (goog.isInModuleLoader_())
            throw Error("goog.provide cannot be used within a module.");
          goog.constructNamespace_(e);
        }, goog.constructNamespace_ = function(e, t) {
          goog.exportPath_(e, t);
        }, goog.getScriptNonce = function(e) {
          return e && e != goog.global ? goog.getScriptNonce_(e.document) : (goog.cspNonce_ === null && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document)), goog.cspNonce_);
        }, goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/, goog.cspNonce_ = null, goog.getScriptNonce_ = function(e) {
          return (e = e.querySelector && e.querySelector("script[nonce]")) && (e = e.nonce || e.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(e) ? e : "";
        }, goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/, goog.module = function(e) {
          if (!goog.isString(e) || !e || e.search(goog.VALID_MODULE_RE_) == -1)
            throw Error("Invalid module identifier");
          if (!goog.isInGoogModuleLoader_())
            throw Error("Module " + e + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
          if (goog.moduleLoaderState_.moduleName)
            throw Error("goog.module may only be called once per module.");
          goog.moduleLoaderState_.moduleName = e;
        }, goog.module.get = function(e) {
          return goog.module.getInternal_(e);
        }, goog.module.getInternal_ = function(e) {
          return null;
        }, goog.ModuleType = { ES6: "es6", GOOG: "goog" }, goog.moduleLoaderState_ = null, goog.isInModuleLoader_ = function() {
          return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
        }, goog.isInGoogModuleLoader_ = function() {
          return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
        }, goog.isInEs6ModuleLoader_ = function() {
          if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6)
            return !0;
          var e = goog.global.$jscomp;
          return !!e && typeof e.getCurrentModulePath == "function" && !!e.getCurrentModulePath();
        }, goog.module.declareLegacyNamespace = function() {
          goog.moduleLoaderState_.declareLegacyNamespace = !0;
        }, goog.declareModuleId = function(e) {
          if (goog.moduleLoaderState_)
            goog.moduleLoaderState_.moduleName = e;
          else {
            var t = goog.global.$jscomp;
            if (!t || typeof t.getCurrentModulePath != "function")
              throw Error('Module with namespace "' + e + '" has been loaded incorrectly.');
            t = t.require(t.getCurrentModulePath()), goog.loadedModules_[e] = { exports: t, type: goog.ModuleType.ES6, moduleId: e };
          }
        }, goog.setTestOnly = function(e) {
          if (goog.DISALLOW_TEST_ONLY_CODE)
            throw e = e || "", Error("Importing test-only code into non-debug environment" + (e ? ": " + e : "."));
        }, goog.forwardDeclare = function(e) {
        }, goog.getObjectByName = function(e, t) {
          e = e.split("."), t = t || goog.global;
          for (var n = 0; n < e.length; n++)
            if (t = t[e[n]], !goog.isDefAndNotNull(t))
              return null;
          return t;
        }, goog.globalize = function(e, t) {
          for (var n in t = t || goog.global, e)
            t[n] = e[n];
        }, goog.addDependency = function(e, t, n, r) {
        }, goog.ENABLE_DEBUG_LOADER = !0, goog.logToConsole_ = function(e) {
          goog.global.console && goog.global.console.error(e);
        }, goog.require = function(e) {
        }, goog.requireType = function(e) {
          return {};
        }, goog.basePath = "", goog.nullFunction = function() {
        }, goog.abstractMethod = function() {
          throw Error("unimplemented abstract method");
        }, goog.addSingletonGetter = function(e) {
          e.instance_ = void 0, e.getInstance = function() {
            return e.instance_ ? e.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = e), e.instance_ = new e());
          };
        }, goog.instantiatedSingletons_ = [], goog.LOAD_MODULE_USING_EVAL = !0, goog.SEAL_MODULE_EXPORTS = goog.DEBUG, goog.loadedModules_ = {}, goog.DEPENDENCIES_ENABLED = !COMPILED, goog.TRANSPILE = "detect", goog.ASSUME_ES_MODULES_TRANSPILED = !1, goog.TRANSPILE_TO_LANGUAGE = "", goog.TRANSPILER = "transpile.js", goog.hasBadLetScoping = null, goog.useSafari10Workaround = function() {
          if (goog.hasBadLetScoping == null) {
            try {
              var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
            } catch (e) {
              a = !1;
            }
            goog.hasBadLetScoping = a;
          }
          return goog.hasBadLetScoping;
        }, goog.workaroundSafari10EvalBug = function(e) {
          return "(function(){" + e + `
;})();
`;
        }, goog.loadModule = function(e) {
          var t = goog.moduleLoaderState_;
          try {
            if (goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: !1, type: goog.ModuleType.GOOG }, goog.isFunction(e))
              var n = e.call(void 0, {});
            else {
              if (!goog.isString(e))
                throw Error("Invalid module definition");
              goog.useSafari10Workaround() && (e = goog.workaroundSafari10EvalBug(e)), n = goog.loadModuleFromSource_.call(void 0, e);
            }
            var r = goog.moduleLoaderState_.moduleName;
            if (!goog.isString(r) || !r)
              throw Error('Invalid module name "' + r + '"');
            goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(r, n) : goog.SEAL_MODULE_EXPORTS && Object.seal && typeof n == "object" && n != null && Object.seal(n), goog.loadedModules_[r] = { exports: n, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
          } finally {
            goog.moduleLoaderState_ = t;
          }
        }, goog.loadModuleFromSource_ = function(a) {
          return eval(a), {};
        }, goog.normalizePath_ = function(e) {
          e = e.split("/");
          for (var t = 0; t < e.length; )
            e[t] == "." ? e.splice(t, 1) : t && e[t] == ".." && e[t - 1] && e[t - 1] != ".." ? e.splice(--t, 2) : t++;
          return e.join("/");
        }, goog.loadFileSync_ = function(e) {
          if (goog.global.CLOSURE_LOAD_FILE_SYNC)
            return goog.global.CLOSURE_LOAD_FILE_SYNC(e);
          try {
            var t = new goog.global.XMLHttpRequest();
            return t.open("get", e, !1), t.send(), t.status == 0 || t.status == 200 ? t.responseText : null;
          } catch {
            return null;
          }
        }, goog.transpile_ = function(e, t, n) {
          var r = goog.global.$jscomp;
          r || (goog.global.$jscomp = r = {});
          var o = r.transpile;
          if (!o) {
            var l = goog.basePath + goog.TRANSPILER, u = goog.loadFileSync_(l);
            if (u) {
              if (function() {
                (0, eval)(u + `
//# sourceURL=` + l);
              }.call(goog.global), goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile)
                throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
              goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile, o = (r = goog.global.$jscomp).transpile;
            }
          }
          return o || (o = r.transpile = function(s, g) {
            return goog.logToConsole_(g + " requires transpilation but no transpiler was found."), s;
          }), o(e, t, n);
        }, goog.typeOf = function(e) {
          var t = typeof e;
          if (t == "object") {
            if (!e)
              return "null";
            if (e instanceof Array)
              return "array";
            if (e instanceof Object)
              return t;
            var n = Object.prototype.toString.call(e);
            if (n == "[object Window]")
              return "object";
            if (n == "[object Array]" || typeof e.length == "number" && e.splice !== void 0 && e.propertyIsEnumerable !== void 0 && !e.propertyIsEnumerable("splice"))
              return "array";
            if (n == "[object Function]" || e.call !== void 0 && e.propertyIsEnumerable !== void 0 && !e.propertyIsEnumerable("call"))
              return "function";
          } else if (t == "function" && e.call === void 0)
            return "object";
          return t;
        }, goog.isNull = function(e) {
          return e === null;
        }, goog.isDefAndNotNull = function(e) {
          return e != null;
        }, goog.isArray = function(e) {
          return goog.typeOf(e) == "array";
        }, goog.isArrayLike = function(e) {
          var t = goog.typeOf(e);
          return t == "array" || t == "object" && typeof e.length == "number";
        }, goog.isDateLike = function(e) {
          return goog.isObject(e) && typeof e.getFullYear == "function";
        }, goog.isFunction = function(e) {
          return goog.typeOf(e) == "function";
        }, goog.isObject = function(e) {
          var t = typeof e;
          return t == "object" && e != null || t == "function";
        }, goog.getUid = function(e) {
          return e[goog.UID_PROPERTY_] || (e[goog.UID_PROPERTY_] = ++goog.uidCounter_);
        }, goog.hasUid = function(e) {
          return !!e[goog.UID_PROPERTY_];
        }, goog.removeUid = function(e) {
          e !== null && "removeAttribute" in e && e.removeAttribute(goog.UID_PROPERTY_);
          try {
            delete e[goog.UID_PROPERTY_];
          } catch {
          }
        }, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(e) {
          var t = goog.typeOf(e);
          if (t == "object" || t == "array") {
            if (typeof e.clone == "function")
              return e.clone();
            for (var n in t = t == "array" ? [] : {}, e)
              t[n] = goog.cloneObject(e[n]);
            return t;
          }
          return e;
        }, goog.bindNative_ = function(e, t, n) {
          return e.call.apply(e.bind, arguments);
        }, goog.bindJs_ = function(e, t, n) {
          if (!e)
            throw Error();
          if (2 < arguments.length) {
            var r = Array.prototype.slice.call(arguments, 2);
            return function() {
              var o = Array.prototype.slice.call(arguments);
              return Array.prototype.unshift.apply(o, r), e.apply(t, o);
            };
          }
          return function() {
            return e.apply(t, arguments);
          };
        }, goog.bind = function(e, t, n) {
          return Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_, goog.bind.apply(null, arguments);
        }, goog.partial = function(e, t) {
          var n = Array.prototype.slice.call(arguments, 1);
          return function() {
            var r = n.slice();
            return r.push.apply(r, arguments), e.apply(this, r);
          };
        }, goog.mixin = function(e, t) {
          for (var n in t)
            e[n] = t[n];
        }, goog.now = goog.TRUSTED_SITE && Date.now || function() {
          return +/* @__PURE__ */ new Date();
        }, goog.globalEval = function(e) {
          if (goog.global.execScript)
            goog.global.execScript(e, "JavaScript");
          else {
            if (!goog.global.eval)
              throw Error("goog.globalEval not available");
            if (goog.evalWorksForGlobals_ == null) {
              try {
                goog.global.eval("var _evalTest_ = 1;");
              } catch {
              }
              if (goog.global._evalTest_ !== void 0) {
                try {
                  delete goog.global._evalTest_;
                } catch {
                }
                goog.evalWorksForGlobals_ = !0;
              } else
                goog.evalWorksForGlobals_ = !1;
            }
            if (goog.evalWorksForGlobals_)
              goog.global.eval(e);
            else {
              var t = goog.global.document, n = t.createElement("SCRIPT");
              n.type = "text/javascript", n.defer = !1, n.appendChild(t.createTextNode(e)), t.head.appendChild(n), t.head.removeChild(n);
            }
          }
        }, goog.evalWorksForGlobals_ = null, goog.getCssName = function(e, t) {
          if (String(e).charAt(0) == ".")
            throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + e);
          var n = function(o) {
            return goog.cssNameMapping_[o] || o;
          }, r = function(o) {
            o = o.split("-");
            for (var l = [], u = 0; u < o.length; u++)
              l.push(n(o[u]));
            return l.join("-");
          };
          return r = goog.cssNameMapping_ ? goog.cssNameMappingStyle_ == "BY_WHOLE" ? n : r : function(o) {
            return o;
          }, e = t ? e + "-" + r(t) : r(e), goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(e) : e;
        }, goog.setCssNameMapping = function(e, t) {
          goog.cssNameMapping_ = e, goog.cssNameMappingStyle_ = t;
        }, goog.getMsg = function(e, t, n) {
          return n && n.html && (e = e.replace(/</g, "&lt;")), t && (e = e.replace(/\{\$([^}]+)}/g, function(r, o) {
            return t != null && o in t ? t[o] : r;
          })), e;
        }, goog.getMsgWithFallback = function(e, t) {
          return e;
        }, goog.exportSymbol = function(e, t, n) {
          goog.exportPath_(e, t, n);
        }, goog.exportProperty = function(e, t, n) {
          e[t] = n;
        }, goog.inherits = function(e, t) {
          function n() {
          }
          n.prototype = t.prototype, e.superClass_ = t.prototype, e.prototype = new n(), e.prototype.constructor = e, e.base = function(r, o, l) {
            for (var u = Array(arguments.length - 2), s = 2; s < arguments.length; s++)
              u[s - 2] = arguments[s];
            return t.prototype[o].apply(r, u);
          };
        }, goog.base = function(e, t, n) {
          var r = arguments.callee.caller;
          if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !r)
            throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
          if (r.superClass_ !== void 0) {
            for (var o = Array(arguments.length - 1), l = 1; l < arguments.length; l++)
              o[l - 1] = arguments[l];
            return r.superClass_.constructor.apply(e, o);
          }
          if (typeof t != "string" && typeof t != "symbol")
            throw Error("method names provided to goog.base must be a string or a symbol");
          for (o = Array(arguments.length - 2), l = 2; l < arguments.length; l++)
            o[l - 2] = arguments[l];
          l = !1;
          for (var u = e.constructor.prototype; u; u = Object.getPrototypeOf(u))
            if (u[t] === r)
              l = !0;
            else if (l)
              return u[t].apply(e, o);
          if (e[t] === r)
            return e.constructor.prototype[t].apply(e, o);
          throw Error("goog.base called from a method of one name to a method of a different name");
        }, goog.scope = function(e) {
          if (goog.isInModuleLoader_())
            throw Error("goog.scope is not supported within a module.");
          e.call(goog.global);
        }, goog.defineClass = function(e, t) {
          var n = t.constructor, r = t.statics;
          return n && n != Object.prototype.constructor || (n = function() {
            throw Error("cannot instantiate an interface (no constructor defined).");
          }), n = goog.defineClass.createSealingConstructor_(n, e), e && goog.inherits(n, e), delete t.constructor, delete t.statics, goog.defineClass.applyProperties_(n.prototype, t), r != null && (r instanceof Function ? r(n) : goog.defineClass.applyProperties_(n, r)), n;
        }, goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG, goog.defineClass.createSealingConstructor_ = function(e, t) {
          if (!goog.defineClass.SEAL_CLASS_INSTANCES)
            return e;
          var n = !goog.defineClass.isUnsealable_(t), r = function() {
            var o = e.apply(this, arguments) || this;
            return o[goog.UID_PROPERTY_] = o[goog.UID_PROPERTY_], this.constructor === r && n && Object.seal instanceof Function && Object.seal(o), o;
          };
          return r;
        }, goog.defineClass.isUnsealable_ = function(e) {
          return e && e.prototype && e.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
        }, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.defineClass.applyProperties_ = function(e, t) {
          for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
          for (var r = 0; r < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; r++)
            n = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[r], Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        }, goog.tagUnsealableClass = function(e) {
        }, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.TRUSTED_TYPES_POLICY_NAME = "", goog.identity_ = function(e) {
          return e;
        }, goog.createTrustedTypesPolicy = function(e) {
          var t = null;
          if (typeof TrustedTypes > "u" || !TrustedTypes.createPolicy)
            return t;
          try {
            t = TrustedTypes.createPolicy(e, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_, createURL: goog.identity_ });
          } catch (n) {
            goog.logToConsole_(n.message);
          }
          return t;
        }, goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null;
        var jspb = { BinaryConstants: {}, ConstBinaryMessage: function() {
        }, BinaryMessage: function() {
        } };
        jspb.BinaryConstants.FieldType = { INVALID: -1, DOUBLE: 1, FLOAT: 2, INT64: 3, UINT64: 4, INT32: 5, FIXED64: 6, FIXED32: 7, BOOL: 8, STRING: 9, GROUP: 10, MESSAGE: 11, BYTES: 12, UINT32: 13, ENUM: 14, SFIXED32: 15, SFIXED64: 16, SINT32: 17, SINT64: 18, FHASH64: 30, VHASH64: 31 }, jspb.BinaryConstants.WireType = { INVALID: -1, VARINT: 0, FIXED64: 1, DELIMITED: 2, START_GROUP: 3, END_GROUP: 4, FIXED32: 5 }, jspb.BinaryConstants.FieldTypeToWireType = function(e) {
          var t = jspb.BinaryConstants.FieldType, n = jspb.BinaryConstants.WireType;
          switch (e) {
            case t.INT32:
            case t.INT64:
            case t.UINT32:
            case t.UINT64:
            case t.SINT32:
            case t.SINT64:
            case t.BOOL:
            case t.ENUM:
            case t.VHASH64:
              return n.VARINT;
            case t.DOUBLE:
            case t.FIXED64:
            case t.SFIXED64:
            case t.FHASH64:
              return n.FIXED64;
            case t.STRING:
            case t.MESSAGE:
            case t.BYTES:
              return n.DELIMITED;
            case t.FLOAT:
            case t.FIXED32:
            case t.SFIXED32:
              return n.FIXED32;
            default:
              return n.INVALID;
          }
        }, jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1, jspb.BinaryConstants.FLOAT32_EPS = 1401298464324817e-60, jspb.BinaryConstants.FLOAT32_MIN = 11754943508222875e-54, jspb.BinaryConstants.FLOAT32_MAX = 34028234663852886e22, jspb.BinaryConstants.FLOAT64_EPS = 5e-324, jspb.BinaryConstants.FLOAT64_MIN = 22250738585072014e-324, jspb.BinaryConstants.FLOAT64_MAX = 17976931348623157e292, jspb.BinaryConstants.TWO_TO_20 = 1048576, jspb.BinaryConstants.TWO_TO_23 = 8388608, jspb.BinaryConstants.TWO_TO_31 = 2147483648, jspb.BinaryConstants.TWO_TO_32 = 4294967296, jspb.BinaryConstants.TWO_TO_52 = 4503599627370496, jspb.BinaryConstants.TWO_TO_63 = 9223372036854776e3, jspb.BinaryConstants.TWO_TO_64 = 18446744073709552e3, jspb.BinaryConstants.ZERO_HASH = "\0\0\0\0\0\0\0\0", goog.dom = {}, goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 }, goog.debug = {}, goog.debug.Error = function(e) {
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, goog.debug.Error);
          else {
            var t = Error().stack;
            t && (this.stack = t);
          }
          e && (this.message = String(e)), this.reportErrorToServer = !0;
        }, goog.inherits(goog.debug.Error, Error), goog.debug.Error.prototype.name = "CustomError", goog.asserts = {}, goog.asserts.ENABLE_ASSERTS = goog.DEBUG, goog.asserts.AssertionError = function(e, t) {
          goog.debug.Error.call(this, goog.asserts.subs_(e, t)), this.messagePattern = e;
        }, goog.inherits(goog.asserts.AssertionError, goog.debug.Error), goog.asserts.AssertionError.prototype.name = "AssertionError", goog.asserts.DEFAULT_ERROR_HANDLER = function(e) {
          throw e;
        }, goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER, goog.asserts.subs_ = function(e, t) {
          for (var n = "", r = (e = e.split("%s")).length - 1, o = 0; o < r; o++)
            n += e[o] + (o < t.length ? t[o] : "%s");
          return n + e[r];
        }, goog.asserts.doAssertFailure_ = function(e, t, n, r) {
          var o = "Assertion failed";
          if (n) {
            o += ": " + n;
            var l = r;
          } else
            e && (o += ": " + e, l = t);
          e = new goog.asserts.AssertionError("" + o, l || []), goog.asserts.errorHandler_(e);
        }, goog.asserts.setErrorHandler = function(e) {
          goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = e);
        }, goog.asserts.assert = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !e && goog.asserts.doAssertFailure_("", null, t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertExists = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && e == null && goog.asserts.doAssertFailure_("Expected to exist: %s.", [e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.fail = function(e, t) {
          goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (e ? ": " + e : ""), Array.prototype.slice.call(arguments, 1)));
        }, goog.asserts.assertNumber = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isNumber(e) && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertString = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isString(e) && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertFunction = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isFunction(e) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertObject = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isObject(e) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertArray = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isArray(e) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertBoolean = function(e, t, n) {
          return goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(e) && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertElement = function(e, t, n) {
          return !goog.asserts.ENABLE_ASSERTS || goog.isObject(e) && e.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(e), e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertInstanceof = function(e, t, n, r) {
          return !goog.asserts.ENABLE_ASSERTS || e instanceof t || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(t), goog.asserts.getType_(e)], n, Array.prototype.slice.call(arguments, 3)), e;
        }, goog.asserts.assertFinite = function(e, t, n) {
          return !goog.asserts.ENABLE_ASSERTS || typeof e == "number" && isFinite(e) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [e], t, Array.prototype.slice.call(arguments, 2)), e;
        }, goog.asserts.assertObjectPrototypeIsIntact = function() {
          for (var e in Object.prototype)
            goog.asserts.fail(e + " should not be enumerable in Object.prototype.");
        }, goog.asserts.getType_ = function(e) {
          return e instanceof Function ? e.displayName || e.name || "unknown type name" : e instanceof Object ? e.constructor.displayName || e.constructor.name || Object.prototype.toString.call(e) : e === null ? "null" : typeof e;
        }, goog.array = {}, goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE, goog.array.ASSUME_NATIVE_FUNCTIONS = 2012 < goog.FEATURESET_YEAR, goog.array.peek = function(e) {
          return e[e.length - 1];
        }, goog.array.last = goog.array.peek, goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.indexOf.call(e, t, n);
        } : function(e, t, n) {
          if (n = n == null ? 0 : 0 > n ? Math.max(0, e.length + n) : n, goog.isString(e))
            return goog.isString(t) && t.length == 1 ? e.indexOf(t, n) : -1;
          for (; n < e.length; n++)
            if (n in e && e[n] === t)
              return n;
          return -1;
        }, goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.lastIndexOf.call(e, t, n ?? e.length - 1);
        } : function(e, t, n) {
          if (0 > (n = n ?? e.length - 1) && (n = Math.max(0, e.length + n)), goog.isString(e))
            return goog.isString(t) && t.length == 1 ? e.lastIndexOf(t, n) : -1;
          for (; 0 <= n; n--)
            if (n in e && e[n] === t)
              return n;
          return -1;
        }, goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(e, t, n) {
          goog.asserts.assert(e.length != null), Array.prototype.forEach.call(e, t, n);
        } : function(e, t, n) {
          for (var r = e.length, o = goog.isString(e) ? e.split("") : e, l = 0; l < r; l++)
            l in o && t.call(n, o[l], l, e);
        }, goog.array.forEachRight = function(e, t, n) {
          var r = e.length, o = goog.isString(e) ? e.split("") : e;
          for (--r; 0 <= r; --r)
            r in o && t.call(n, o[r], r, e);
        }, goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.filter.call(e, t, n);
        } : function(e, t, n) {
          for (var r = e.length, o = [], l = 0, u = goog.isString(e) ? e.split("") : e, s = 0; s < r; s++)
            if (s in u) {
              var g = u[s];
              t.call(n, g, s, e) && (o[l++] = g);
            }
          return o;
        }, goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.map.call(e, t, n);
        } : function(e, t, n) {
          for (var r = e.length, o = Array(r), l = goog.isString(e) ? e.split("") : e, u = 0; u < r; u++)
            u in l && (o[u] = t.call(n, l[u], u, e));
          return o;
        }, goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(e, t, n, r) {
          return goog.asserts.assert(e.length != null), r && (t = goog.bind(t, r)), Array.prototype.reduce.call(e, t, n);
        } : function(e, t, n, r) {
          var o = n;
          return goog.array.forEach(e, function(l, u) {
            o = t.call(r, o, l, u, e);
          }), o;
        }, goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(e, t, n, r) {
          return goog.asserts.assert(e.length != null), goog.asserts.assert(t != null), r && (t = goog.bind(t, r)), Array.prototype.reduceRight.call(e, t, n);
        } : function(e, t, n, r) {
          var o = n;
          return goog.array.forEachRight(e, function(l, u) {
            o = t.call(r, o, l, u, e);
          }), o;
        }, goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.some.call(e, t, n);
        } : function(e, t, n) {
          for (var r = e.length, o = goog.isString(e) ? e.split("") : e, l = 0; l < r; l++)
            if (l in o && t.call(n, o[l], l, e))
              return !0;
          return !1;
        }, goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(e, t, n) {
          return goog.asserts.assert(e.length != null), Array.prototype.every.call(e, t, n);
        } : function(e, t, n) {
          for (var r = e.length, o = goog.isString(e) ? e.split("") : e, l = 0; l < r; l++)
            if (l in o && !t.call(n, o[l], l, e))
              return !1;
          return !0;
        }, goog.array.count = function(e, t, n) {
          var r = 0;
          return goog.array.forEach(e, function(o, l, u) {
            t.call(n, o, l, u) && ++r;
          }, n), r;
        }, goog.array.find = function(e, t, n) {
          return 0 > (t = goog.array.findIndex(e, t, n)) ? null : goog.isString(e) ? e.charAt(t) : e[t];
        }, goog.array.findIndex = function(e, t, n) {
          for (var r = e.length, o = goog.isString(e) ? e.split("") : e, l = 0; l < r; l++)
            if (l in o && t.call(n, o[l], l, e))
              return l;
          return -1;
        }, goog.array.findRight = function(e, t, n) {
          return 0 > (t = goog.array.findIndexRight(e, t, n)) ? null : goog.isString(e) ? e.charAt(t) : e[t];
        }, goog.array.findIndexRight = function(e, t, n) {
          var r = e.length, o = goog.isString(e) ? e.split("") : e;
          for (--r; 0 <= r; r--)
            if (r in o && t.call(n, o[r], r, e))
              return r;
          return -1;
        }, goog.array.contains = function(e, t) {
          return 0 <= goog.array.indexOf(e, t);
        }, goog.array.isEmpty = function(e) {
          return e.length == 0;
        }, goog.array.clear = function(e) {
          if (!goog.isArray(e))
            for (var t = e.length - 1; 0 <= t; t--)
              delete e[t];
          e.length = 0;
        }, goog.array.insert = function(e, t) {
          goog.array.contains(e, t) || e.push(t);
        }, goog.array.insertAt = function(e, t, n) {
          goog.array.splice(e, n, 0, t);
        }, goog.array.insertArrayAt = function(e, t, n) {
          goog.partial(goog.array.splice, e, n, 0).apply(null, t);
        }, goog.array.insertBefore = function(e, t, n) {
          var r;
          arguments.length == 2 || 0 > (r = goog.array.indexOf(e, n)) ? e.push(t) : goog.array.insertAt(e, t, r);
        }, goog.array.remove = function(e, t) {
          var n;
          return (n = 0 <= (t = goog.array.indexOf(e, t))) && goog.array.removeAt(e, t), n;
        }, goog.array.removeLast = function(e, t) {
          return 0 <= (t = goog.array.lastIndexOf(e, t)) && (goog.array.removeAt(e, t), !0);
        }, goog.array.removeAt = function(e, t) {
          return goog.asserts.assert(e.length != null), Array.prototype.splice.call(e, t, 1).length == 1;
        }, goog.array.removeIf = function(e, t, n) {
          return 0 <= (t = goog.array.findIndex(e, t, n)) && (goog.array.removeAt(e, t), !0);
        }, goog.array.removeAllIf = function(e, t, n) {
          var r = 0;
          return goog.array.forEachRight(e, function(o, l) {
            t.call(n, o, l, e) && goog.array.removeAt(e, l) && r++;
          }), r;
        }, goog.array.concat = function(e) {
          return Array.prototype.concat.apply([], arguments);
        }, goog.array.join = function(e) {
          return Array.prototype.concat.apply([], arguments);
        }, goog.array.toArray = function(e) {
          var t = e.length;
          if (0 < t) {
            for (var n = Array(t), r = 0; r < t; r++)
              n[r] = e[r];
            return n;
          }
          return [];
        }, goog.array.clone = goog.array.toArray, goog.array.extend = function(e, t) {
          for (var n = 1; n < arguments.length; n++) {
            var r = arguments[n];
            if (goog.isArrayLike(r)) {
              var o = e.length || 0, l = r.length || 0;
              e.length = o + l;
              for (var u = 0; u < l; u++)
                e[o + u] = r[u];
            } else
              e.push(r);
          }
        }, goog.array.splice = function(e, t, n, r) {
          return goog.asserts.assert(e.length != null), Array.prototype.splice.apply(e, goog.array.slice(arguments, 1));
        }, goog.array.slice = function(e, t, n) {
          return goog.asserts.assert(e.length != null), 2 >= arguments.length ? Array.prototype.slice.call(e, t) : Array.prototype.slice.call(e, t, n);
        }, goog.array.removeDuplicates = function(e, t, n) {
          t = t || e;
          var r = function(g) {
            return goog.isObject(g) ? "o" + goog.getUid(g) : (typeof g).charAt(0) + g;
          };
          n = n || r, r = {};
          for (var o = 0, l = 0; l < e.length; ) {
            var u = e[l++], s = n(u);
            Object.prototype.hasOwnProperty.call(r, s) || (r[s] = !0, t[o++] = u);
          }
          t.length = o;
        }, goog.array.binarySearch = function(e, t, n) {
          return goog.array.binarySearch_(e, n || goog.array.defaultCompare, !1, t);
        }, goog.array.binarySelect = function(e, t, n) {
          return goog.array.binarySearch_(e, t, !0, void 0, n);
        }, goog.array.binarySearch_ = function(e, t, n, r, o) {
          for (var l, u = 0, s = e.length; u < s; ) {
            var g = u + s >> 1, c = n ? t.call(o, e[g], g, e) : t(r, e[g]);
            0 < c ? u = g + 1 : (s = g, l = !c);
          }
          return l ? u : ~u;
        }, goog.array.sort = function(e, t) {
          e.sort(t || goog.array.defaultCompare);
        }, goog.array.stableSort = function(e, t) {
          for (var n = Array(e.length), r = 0; r < e.length; r++)
            n[r] = { index: r, value: e[r] };
          var o = t || goog.array.defaultCompare;
          for (goog.array.sort(n, function(l, u) {
            return o(l.value, u.value) || l.index - u.index;
          }), r = 0; r < e.length; r++)
            e[r] = n[r].value;
        }, goog.array.sortByKey = function(e, t, n) {
          var r = n || goog.array.defaultCompare;
          goog.array.sort(e, function(o, l) {
            return r(t(o), t(l));
          });
        }, goog.array.sortObjectsByKey = function(e, t, n) {
          goog.array.sortByKey(e, function(r) {
            return r[t];
          }, n);
        }, goog.array.isSorted = function(e, t, n) {
          t = t || goog.array.defaultCompare;
          for (var r = 1; r < e.length; r++) {
            var o = t(e[r - 1], e[r]);
            if (0 < o || o == 0 && n)
              return !1;
          }
          return !0;
        }, goog.array.equals = function(e, t, n) {
          if (!goog.isArrayLike(e) || !goog.isArrayLike(t) || e.length != t.length)
            return !1;
          var r = e.length;
          n = n || goog.array.defaultCompareEquality;
          for (var o = 0; o < r; o++)
            if (!n(e[o], t[o]))
              return !1;
          return !0;
        }, goog.array.compare3 = function(e, t, n) {
          n = n || goog.array.defaultCompare;
          for (var r = Math.min(e.length, t.length), o = 0; o < r; o++) {
            var l = n(e[o], t[o]);
            if (l != 0)
              return l;
          }
          return goog.array.defaultCompare(e.length, t.length);
        }, goog.array.defaultCompare = function(e, t) {
          return e > t ? 1 : e < t ? -1 : 0;
        }, goog.array.inverseDefaultCompare = function(e, t) {
          return -goog.array.defaultCompare(e, t);
        }, goog.array.defaultCompareEquality = function(e, t) {
          return e === t;
        }, goog.array.binaryInsert = function(e, t, n) {
          return 0 > (n = goog.array.binarySearch(e, t, n)) && (goog.array.insertAt(e, t, -(n + 1)), !0);
        }, goog.array.binaryRemove = function(e, t, n) {
          return 0 <= (t = goog.array.binarySearch(e, t, n)) && goog.array.removeAt(e, t);
        }, goog.array.bucket = function(e, t, n) {
          for (var r = {}, o = 0; o < e.length; o++) {
            var l = e[o], u = t.call(n, l, o, e);
            goog.isDef(u) && (r[u] || (r[u] = [])).push(l);
          }
          return r;
        }, goog.array.toObject = function(e, t, n) {
          var r = {};
          return goog.array.forEach(e, function(o, l) {
            r[t.call(n, o, l, e)] = o;
          }), r;
        }, goog.array.range = function(e, t, n) {
          var r = [], o = 0, l = e;
          if (t !== void 0 && (o = e, l = t), 0 > (n = n || 1) * (l - o))
            return [];
          if (0 < n)
            for (e = o; e < l; e += n)
              r.push(e);
          else
            for (e = o; e > l; e += n)
              r.push(e);
          return r;
        }, goog.array.repeat = function(e, t) {
          for (var n = [], r = 0; r < t; r++)
            n[r] = e;
          return n;
        }, goog.array.flatten = function(e) {
          for (var t = [], n = 0; n < arguments.length; n++) {
            var r = arguments[n];
            if (goog.isArray(r))
              for (var o = 0; o < r.length; o += 8192) {
                var l = goog.array.slice(r, o, o + 8192);
                l = goog.array.flatten.apply(null, l);
                for (var u = 0; u < l.length; u++)
                  t.push(l[u]);
              }
            else
              t.push(r);
          }
          return t;
        }, goog.array.rotate = function(e, t) {
          return goog.asserts.assert(e.length != null), e.length && (0 < (t %= e.length) ? Array.prototype.unshift.apply(e, e.splice(-t, t)) : 0 > t && Array.prototype.push.apply(e, e.splice(0, -t))), e;
        }, goog.array.moveItem = function(e, t, n) {
          goog.asserts.assert(0 <= t && t < e.length), goog.asserts.assert(0 <= n && n < e.length), t = Array.prototype.splice.call(e, t, 1), Array.prototype.splice.call(e, n, 0, t[0]);
        }, goog.array.zip = function(e) {
          if (!arguments.length)
            return [];
          for (var t = [], n = arguments[0].length, r = 1; r < arguments.length; r++)
            arguments[r].length < n && (n = arguments[r].length);
          for (r = 0; r < n; r++) {
            for (var o = [], l = 0; l < arguments.length; l++)
              o.push(arguments[l][r]);
            t.push(o);
          }
          return t;
        }, goog.array.shuffle = function(e, t) {
          t = t || Math.random;
          for (var n = e.length - 1; 0 < n; n--) {
            var r = Math.floor(t() * (n + 1)), o = e[n];
            e[n] = e[r], e[r] = o;
          }
        }, goog.array.copyByIndex = function(e, t) {
          var n = [];
          return goog.array.forEach(t, function(r) {
            n.push(e[r]);
          }), n;
        }, goog.array.concatMap = function(e, t, n) {
          return goog.array.concat.apply([], goog.array.map(e, t, n));
        }, goog.crypt = {}, goog.crypt.stringToByteArray = function(e) {
          for (var t = [], n = 0, r = 0; r < e.length; r++) {
            var o = e.charCodeAt(r);
            255 < o && (t[n++] = 255 & o, o >>= 8), t[n++] = o;
          }
          return t;
        }, goog.crypt.byteArrayToString = function(e) {
          if (8192 >= e.length)
            return String.fromCharCode.apply(null, e);
          for (var t = "", n = 0; n < e.length; n += 8192) {
            var r = goog.array.slice(e, n, n + 8192);
            t += String.fromCharCode.apply(null, r);
          }
          return t;
        }, goog.crypt.byteArrayToHex = function(e, t) {
          return goog.array.map(e, function(n) {
            return 1 < (n = n.toString(16)).length ? n : "0" + n;
          }).join(t || "");
        }, goog.crypt.hexToByteArray = function(e) {
          goog.asserts.assert(e.length % 2 == 0, "Key string length must be multiple of 2");
          for (var t = [], n = 0; n < e.length; n += 2)
            t.push(parseInt(e.substring(n, n + 2), 16));
          return t;
        }, goog.crypt.stringToUtf8ByteArray = function(e) {
          for (var t = [], n = 0, r = 0; r < e.length; r++) {
            var o = e.charCodeAt(r);
            128 > o ? t[n++] = o : (2048 > o ? t[n++] = o >> 6 | 192 : ((64512 & o) == 55296 && r + 1 < e.length && (64512 & e.charCodeAt(r + 1)) == 56320 ? (o = 65536 + ((1023 & o) << 10) + (1023 & e.charCodeAt(++r)), t[n++] = o >> 18 | 240, t[n++] = o >> 12 & 63 | 128) : t[n++] = o >> 12 | 224, t[n++] = o >> 6 & 63 | 128), t[n++] = 63 & o | 128);
          }
          return t;
        }, goog.crypt.utf8ByteArrayToString = function(e) {
          for (var t = [], n = 0, r = 0; n < e.length; ) {
            var o = e[n++];
            if (128 > o)
              t[r++] = String.fromCharCode(o);
            else if (191 < o && 224 > o) {
              var l = e[n++];
              t[r++] = String.fromCharCode((31 & o) << 6 | 63 & l);
            } else if (239 < o && 365 > o) {
              l = e[n++];
              var u = e[n++];
              o = ((7 & o) << 18 | (63 & l) << 12 | (63 & u) << 6 | 63 & e[n++]) - 65536, t[r++] = String.fromCharCode(55296 + (o >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & o));
            } else
              l = e[n++], u = e[n++], t[r++] = String.fromCharCode((15 & o) << 12 | (63 & l) << 6 | 63 & u);
          }
          return t.join("");
        }, goog.crypt.xorByteArray = function(e, t) {
          goog.asserts.assert(e.length == t.length, "XOR array lengths must match");
          for (var n = [], r = 0; r < e.length; r++)
            n.push(e[r] ^ t[r]);
          return n;
        }, goog.string = {}, goog.string.internal = {}, goog.string.internal.startsWith = function(e, t) {
          return e.lastIndexOf(t, 0) == 0;
        }, goog.string.internal.endsWith = function(e, t) {
          var n = e.length - t.length;
          return 0 <= n && e.indexOf(t, n) == n;
        }, goog.string.internal.caseInsensitiveStartsWith = function(e, t) {
          return goog.string.internal.caseInsensitiveCompare(t, e.substr(0, t.length)) == 0;
        }, goog.string.internal.caseInsensitiveEndsWith = function(e, t) {
          return goog.string.internal.caseInsensitiveCompare(t, e.substr(e.length - t.length, t.length)) == 0;
        }, goog.string.internal.caseInsensitiveEquals = function(e, t) {
          return e.toLowerCase() == t.toLowerCase();
        }, goog.string.internal.isEmptyOrWhitespace = function(e) {
          return /^[\s\xa0]*$/.test(e);
        }, goog.string.internal.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(e) {
          return e.trim();
        } : function(e) {
          return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(e)[1];
        }, goog.string.internal.caseInsensitiveCompare = function(e, t) {
          return (e = String(e).toLowerCase()) < (t = String(t).toLowerCase()) ? -1 : e == t ? 0 : 1;
        }, goog.string.internal.newLineToBr = function(e, t) {
          return e.replace(/(\r\n|\r|\n)/g, t ? "<br />" : "<br>");
        }, goog.string.internal.htmlEscape = function(e, t) {
          if (t)
            e = e.replace(goog.string.internal.AMP_RE_, "&amp;").replace(goog.string.internal.LT_RE_, "&lt;").replace(goog.string.internal.GT_RE_, "&gt;").replace(goog.string.internal.QUOT_RE_, "&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.internal.NULL_RE_, "&#0;");
          else {
            if (!goog.string.internal.ALL_RE_.test(e))
              return e;
            e.indexOf("&") != -1 && (e = e.replace(goog.string.internal.AMP_RE_, "&amp;")), e.indexOf("<") != -1 && (e = e.replace(goog.string.internal.LT_RE_, "&lt;")), e.indexOf(">") != -1 && (e = e.replace(goog.string.internal.GT_RE_, "&gt;")), e.indexOf('"') != -1 && (e = e.replace(goog.string.internal.QUOT_RE_, "&quot;")), e.indexOf("'") != -1 && (e = e.replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;")), e.indexOf("\0") != -1 && (e = e.replace(goog.string.internal.NULL_RE_, "&#0;"));
          }
          return e;
        }, goog.string.internal.AMP_RE_ = /&/g, goog.string.internal.LT_RE_ = /</g, goog.string.internal.GT_RE_ = />/g, goog.string.internal.QUOT_RE_ = /"/g, goog.string.internal.SINGLE_QUOTE_RE_ = /'/g, goog.string.internal.NULL_RE_ = /\x00/g, goog.string.internal.ALL_RE_ = /[\x00&<>"']/, goog.string.internal.whitespaceEscape = function(e, t) {
          return goog.string.internal.newLineToBr(e.replace(/  /g, " &#160;"), t);
        }, goog.string.internal.contains = function(e, t) {
          return e.indexOf(t) != -1;
        }, goog.string.internal.caseInsensitiveContains = function(e, t) {
          return goog.string.internal.contains(e.toLowerCase(), t.toLowerCase());
        }, goog.string.internal.compareVersions = function(e, t) {
          var n = 0;
          e = goog.string.internal.trim(String(e)).split("."), t = goog.string.internal.trim(String(t)).split(".");
          for (var r = Math.max(e.length, t.length), o = 0; n == 0 && o < r; o++) {
            var l = e[o] || "", u = t[o] || "";
            do {
              if (l = /(\d*)(\D*)(.*)/.exec(l) || ["", "", "", ""], u = /(\d*)(\D*)(.*)/.exec(u) || ["", "", "", ""], l[0].length == 0 && u[0].length == 0)
                break;
              n = l[1].length == 0 ? 0 : parseInt(l[1], 10);
              var s = u[1].length == 0 ? 0 : parseInt(u[1], 10);
              n = goog.string.internal.compareElements_(n, s) || goog.string.internal.compareElements_(l[2].length == 0, u[2].length == 0) || goog.string.internal.compareElements_(l[2], u[2]), l = l[3], u = u[3];
            } while (n == 0);
          }
          return n;
        }, goog.string.internal.compareElements_ = function(e, t) {
          return e < t ? -1 : e > t ? 1 : 0;
        }, goog.string.TypedString = function() {
        }, goog.string.Const = function(e, t) {
          this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = e === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && t || "", this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
        }, goog.string.Const.prototype.implementsGoogStringTypedString = !0, goog.string.Const.prototype.getTypedStringValue = function() {
          return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
        }, goog.string.Const.prototype.toString = function() {
          return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
        }, goog.string.Const.unwrap = function(e) {
          return e instanceof goog.string.Const && e.constructor === goog.string.Const && e.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_ ? e.stringConstValueWithSecurityContract__googStringSecurityPrivate_ : (goog.asserts.fail("expected object of type Const, got '" + e + "'"), "type_error:Const");
        }, goog.string.Const.from = function(e) {
          return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, e);
        }, goog.string.Const.TYPE_MARKER_ = {}, goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {}, goog.string.Const.EMPTY = goog.string.Const.from(""), goog.fs = {}, goog.fs.url = {}, goog.fs.url.createObjectUrl = function(e) {
          return goog.fs.url.getUrlObject_().createObjectURL(e);
        }, goog.fs.url.revokeObjectUrl = function(e) {
          goog.fs.url.getUrlObject_().revokeObjectURL(e);
        }, goog.fs.url.getUrlObject_ = function() {
          var e = goog.fs.url.findUrlObject_();
          if (e != null)
            return e;
          throw Error("This browser doesn't seem to support blob URLs");
        }, goog.fs.url.findUrlObject_ = function() {
          return goog.isDef(goog.global.URL) && goog.isDef(goog.global.URL.createObjectURL) ? goog.global.URL : goog.isDef(goog.global.webkitURL) && goog.isDef(goog.global.webkitURL.createObjectURL) ? goog.global.webkitURL : goog.isDef(goog.global.createObjectURL) ? goog.global : null;
        }, goog.fs.url.browserSupportsObjectUrls = function() {
          return goog.fs.url.findUrlObject_() != null;
        }, goog.html = {}, goog.html.trustedtypes = {}, goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#html") : null, goog.i18n = {}, goog.i18n.bidi = {}, goog.i18n.bidi.FORCE_RTL = !1, goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == "ar" || goog.LOCALE.substring(0, 2).toLowerCase() == "fa" || goog.LOCALE.substring(0, 2).toLowerCase() == "he" || goog.LOCALE.substring(0, 2).toLowerCase() == "iw" || goog.LOCALE.substring(0, 2).toLowerCase() == "ps" || goog.LOCALE.substring(0, 2).toLowerCase() == "sd" || goog.LOCALE.substring(0, 2).toLowerCase() == "ug" || goog.LOCALE.substring(0, 2).toLowerCase() == "ur" || goog.LOCALE.substring(0, 2).toLowerCase() == "yi") && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") || 3 <= goog.LOCALE.length && goog.LOCALE.substring(0, 3).toLowerCase() == "ckb" && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") || 7 <= goog.LOCALE.length && (goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") && (goog.LOCALE.substring(3, 7).toLowerCase() == "adlm" || goog.LOCALE.substring(3, 7).toLowerCase() == "arab" || goog.LOCALE.substring(3, 7).toLowerCase() == "hebr" || goog.LOCALE.substring(3, 7).toLowerCase() == "nkoo" || goog.LOCALE.substring(3, 7).toLowerCase() == "rohg" || goog.LOCALE.substring(3, 7).toLowerCase() == "thaa") || 8 <= goog.LOCALE.length && (goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") && (goog.LOCALE.substring(4, 8).toLowerCase() == "adlm" || goog.LOCALE.substring(4, 8).toLowerCase() == "arab" || goog.LOCALE.substring(4, 8).toLowerCase() == "hebr" || goog.LOCALE.substring(4, 8).toLowerCase() == "nkoo" || goog.LOCALE.substring(4, 8).toLowerCase() == "rohg" || goog.LOCALE.substring(4, 8).toLowerCase() == "thaa"), goog.i18n.bidi.Format = { LRE: "‪", RLE: "‫", PDF: "‬", LRM: "‎", RLM: "‏" }, goog.i18n.bidi.Dir = { LTR: 1, RTL: -1, NEUTRAL: 0 }, goog.i18n.bidi.RIGHT = "right", goog.i18n.bidi.LEFT = "left", goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT, goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, goog.i18n.bidi.toDir = function(e, t) {
          return typeof e == "number" ? 0 < e ? goog.i18n.bidi.Dir.LTR : 0 > e ? goog.i18n.bidi.Dir.RTL : t ? null : goog.i18n.bidi.Dir.NEUTRAL : e == null ? null : e ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
        }, goog.i18n.bidi.ltrChars_ = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ऀ-῿‎Ⰰ-\uD801\uD804-\uD839\uD83C-\uDBFF豈-﬜︀-﹯﻽-￿", goog.i18n.bidi.rtlChars_ = "֑-ۯۺ-ࣿ‏\uD802-\uD803\uD83A-\uD83Bיִ-﷿ﹰ-ﻼ", goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g, goog.i18n.bidi.stripHtmlIfNeeded_ = function(e, t) {
          return t ? e.replace(goog.i18n.bidi.htmlSkipReg_, "") : e;
        }, goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.hasAnyRtl = function(e, t) {
          return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl, goog.i18n.bidi.hasAnyLtr = function(e, t) {
          return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.isRtlChar = function(e) {
          return goog.i18n.bidi.rtlRe_.test(e);
        }, goog.i18n.bidi.isLtrChar = function(e) {
          return goog.i18n.bidi.ltrRe_.test(e);
        }, goog.i18n.bidi.isNeutralChar = function(e) {
          return !goog.i18n.bidi.isLtrChar(e) && !goog.i18n.bidi.isRtlChar(e);
        }, goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]"), goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]"), goog.i18n.bidi.startsWithRtl = function(e, t) {
          return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl, goog.i18n.bidi.startsWithLtr = function(e, t) {
          return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr, goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/, goog.i18n.bidi.isNeutralText = function(e, t) {
          return e = goog.i18n.bidi.stripHtmlIfNeeded_(e, t), goog.i18n.bidi.isRequiredLtrRe_.test(e) || !goog.i18n.bidi.hasAnyLtr(e) && !goog.i18n.bidi.hasAnyRtl(e);
        }, goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$"), goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$"), goog.i18n.bidi.endsWithLtr = function(e, t) {
          return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr, goog.i18n.bidi.endsWithRtl = function(e, t) {
          return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(e, t));
        }, goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl, goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i, goog.i18n.bidi.isRtlLanguage = function(e) {
          return goog.i18n.bidi.rtlLocalesRe_.test(e);
        }, goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g, goog.i18n.bidi.guardBracketInText = function(e, t) {
          return t = (t === void 0 ? goog.i18n.bidi.hasAnyRtl(e) : t) ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM, e.replace(goog.i18n.bidi.bracketGuardTextRe_, t + "$&" + t);
        }, goog.i18n.bidi.enforceRtlInHtml = function(e) {
          return e.charAt(0) == "<" ? e.replace(/<\w+/, "$& dir=rtl") : `
<span dir=rtl>` + e + "</span>";
        }, goog.i18n.bidi.enforceRtlInText = function(e) {
          return goog.i18n.bidi.Format.RLE + e + goog.i18n.bidi.Format.PDF;
        }, goog.i18n.bidi.enforceLtrInHtml = function(e) {
          return e.charAt(0) == "<" ? e.replace(/<\w+/, "$& dir=ltr") : `
<span dir=ltr>` + e + "</span>";
        }, goog.i18n.bidi.enforceLtrInText = function(e) {
          return goog.i18n.bidi.Format.LRE + e + goog.i18n.bidi.Format.PDF;
        }, goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g, goog.i18n.bidi.leftRe_ = /left/gi, goog.i18n.bidi.rightRe_ = /right/gi, goog.i18n.bidi.tempRe_ = /%%%%/g, goog.i18n.bidi.mirrorCSS = function(e) {
          return e.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
        }, goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g, goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g, goog.i18n.bidi.normalizeHebrewQuote = function(e) {
          return e.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1״").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1׳");
        }, goog.i18n.bidi.wordSeparatorRe_ = /\s+/, goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/, goog.i18n.bidi.rtlDetectionThreshold_ = 0.4, goog.i18n.bidi.estimateDirection = function(e, t) {
          var n = 0, r = 0, o = !1;
          for (e = goog.i18n.bidi.stripHtmlIfNeeded_(e, t).split(goog.i18n.bidi.wordSeparatorRe_), t = 0; t < e.length; t++) {
            var l = e[t];
            goog.i18n.bidi.startsWithRtl(l) ? (n++, r++) : goog.i18n.bidi.isRequiredLtrRe_.test(l) ? o = !0 : goog.i18n.bidi.hasAnyLtr(l) ? r++ : goog.i18n.bidi.hasNumeralsRe_.test(l) && (o = !0);
          }
          return r == 0 ? o ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : n / r > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
        }, goog.i18n.bidi.detectRtlDirectionality = function(e, t) {
          return goog.i18n.bidi.estimateDirection(e, t) == goog.i18n.bidi.Dir.RTL;
        }, goog.i18n.bidi.setElementDirAndAlign = function(e, t) {
          e && (t = goog.i18n.bidi.toDir(t)) && (e.style.textAlign = t == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, e.dir = t == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
        }, goog.i18n.bidi.setElementDirByTextDirectionality = function(e, t) {
          switch (goog.i18n.bidi.estimateDirection(t)) {
            case goog.i18n.bidi.Dir.LTR:
              e.dir = "ltr";
              break;
            case goog.i18n.bidi.Dir.RTL:
              e.dir = "rtl";
              break;
            default:
              e.removeAttribute("dir");
          }
        }, goog.i18n.bidi.DirectionalString = function() {
        }, goog.html.TrustedResourceUrl = function() {
          this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = "", this.trustedURL_ = null, this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
        }, goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = !0, goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString();
        }, goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.TrustedResourceUrl.prototype.getDirection = function() {
          return goog.i18n.bidi.Dir.LTR;
        }, goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(e, t) {
          var n = goog.html.TrustedResourceUrl.unwrap(this), r = (n = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(n))[3] || "";
          return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(n[1] + goog.html.TrustedResourceUrl.stringifyParams_("?", n[2] || "", e) + goog.html.TrustedResourceUrl.stringifyParams_("#", r, t));
        }, goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
          return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
        }), goog.html.TrustedResourceUrl.unwrap = function(e) {
          return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(e).toString();
        }, goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(e) {
          return e instanceof goog.html.TrustedResourceUrl && e.constructor === goog.html.TrustedResourceUrl && e.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ : (goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + e + "' of type " + goog.typeOf(e)), "type_error:TrustedResourceUrl");
        }, goog.html.TrustedResourceUrl.unwrapTrustedURL = function(e) {
          return e.trustedURL_ ? e.trustedURL_ : goog.html.TrustedResourceUrl.unwrap(e);
        }, goog.html.TrustedResourceUrl.format = function(e, t) {
          var n = goog.string.Const.unwrap(e);
          if (!goog.html.TrustedResourceUrl.BASE_URL_.test(n))
            throw Error("Invalid TrustedResourceUrl format: " + n);
          return e = n.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(r, o) {
            if (!Object.prototype.hasOwnProperty.call(t, o))
              throw Error('Found marker, "' + o + '", in format string, "' + n + '", but no valid label mapping found in args: ' + JSON.stringify(t));
            return (r = t[o]) instanceof goog.string.Const ? goog.string.Const.unwrap(r) : encodeURIComponent(String(r));
          }), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g, goog.html.TrustedResourceUrl.BASE_URL_ = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i, goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/, goog.html.TrustedResourceUrl.formatWithParams = function(e, t, n, r) {
          return goog.html.TrustedResourceUrl.format(e, t).cloneWithParams(n, r);
        }, goog.html.TrustedResourceUrl.fromConstant = function(e) {
          return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(e));
        }, goog.html.TrustedResourceUrl.fromConstants = function(e) {
          for (var t = "", n = 0; n < e.length; n++)
            t += goog.string.Const.unwrap(e[n]);
          return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(e) {
          var t = new goog.html.TrustedResourceUrl();
          return t.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(e) : e, goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY && (t.trustedURL_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(e)), t;
        }, goog.html.TrustedResourceUrl.stringifyParams_ = function(e, t, n) {
          if (n == null)
            return t;
          if (goog.isString(n))
            return n ? e + encodeURIComponent(n) : "";
          for (var r in n) {
            var o = n[r];
            o = goog.isArray(o) ? o : [o];
            for (var l = 0; l < o.length; l++) {
              var u = o[l];
              u != null && (t || (t = e), t += (t.length > e.length ? "&" : "") + encodeURIComponent(r) + "=" + encodeURIComponent(String(u)));
            }
          }
          return t;
        }, goog.html.SafeUrl = function() {
          this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = "", this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
        }, goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez", goog.html.SafeUrl.prototype.implementsGoogStringTypedString = !0, goog.html.SafeUrl.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
        }, goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeUrl.prototype.getDirection = function() {
          return goog.i18n.bidi.Dir.LTR;
        }, goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
          return "SafeUrl{" + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + "}";
        }), goog.html.SafeUrl.unwrap = function(e) {
          return goog.html.SafeUrl.unwrapTrustedURL(e).toString();
        }, goog.html.SafeUrl.unwrapTrustedURL = function(e) {
          return e instanceof goog.html.SafeUrl && e.constructor === goog.html.SafeUrl && e.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseSafeUrlWrappedValue_ : (goog.asserts.fail("expected object of type SafeUrl, got '" + e + "' of type " + goog.typeOf(e)), "type_error:SafeUrl");
        }, goog.html.SafeUrl.fromConstant = function(e) {
          return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(e));
        }, goog.html.SAFE_MIME_TYPE_PATTERN_ = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime))(?:;\w+=(?:\w+|"[\w;=]+"))*$/i, goog.html.SafeUrl.isSafeMimeType = function(e) {
          return goog.html.SAFE_MIME_TYPE_PATTERN_.test(e);
        }, goog.html.SafeUrl.fromBlob = function(e) {
          return e = goog.html.SAFE_MIME_TYPE_PATTERN_.test(e.type) ? goog.fs.url.createObjectUrl(e) : goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.DATA_URL_PATTERN_ = /^data:([^,]*);base64,[a-z0-9+\/]+=*$/i, goog.html.SafeUrl.fromDataUrl = function(e) {
          var t = (e = e.replace(/(%0A|%0D)/g, "")).match(goog.html.DATA_URL_PATTERN_);
          return t = t && goog.html.SAFE_MIME_TYPE_PATTERN_.test(t[1]), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t ? e : goog.html.SafeUrl.INNOCUOUS_STRING);
        }, goog.html.SafeUrl.fromTelUrl = function(e) {
          return goog.string.internal.caseInsensitiveStartsWith(e, "tel:") || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SIP_URL_PATTERN_ = /^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i, goog.html.SafeUrl.fromSipUrl = function(e) {
          return goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(e)) || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeUrl.fromFacebookMessengerUrl = function(e) {
          return goog.string.internal.caseInsensitiveStartsWith(e, "fb-messenger://share") || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeUrl.fromWhatsAppUrl = function(e) {
          return goog.string.internal.caseInsensitiveStartsWith(e, "whatsapp://send") || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeUrl.fromSmsUrl = function(e) {
          return goog.string.internal.caseInsensitiveStartsWith(e, "sms:") && goog.html.SafeUrl.isSmsUrlBodyValid_(e) || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeUrl.isSmsUrlBodyValid_ = function(e) {
          var t = e.indexOf("#");
          if (0 < t && (e = e.substring(0, t)), !(t = e.match(/[?&]body=/gi)))
            return !0;
          if (1 < t.length)
            return !1;
          if (!(e = e.match(/[?&]body=([^&]*)/)[1]))
            return !0;
          try {
            decodeURIComponent(e);
          } catch {
            return !1;
          }
          return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(e);
        }, goog.html.SafeUrl.fromSshUrl = function(e) {
          return goog.string.internal.caseInsensitiveStartsWith(e, "ssh://") || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(e, t) {
          return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, e, t);
        }, goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(e, t) {
          return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, e, t);
        }, goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(e, t) {
          return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, e, t);
        }, goog.html.SafeUrl.sanitizeExtensionUrl_ = function(e, t, n) {
          return (e = e.exec(t)) ? (e = e[1], (n instanceof goog.string.Const ? [goog.string.Const.unwrap(n)] : n.map(function(r) {
            return goog.string.Const.unwrap(r);
          })).indexOf(e) == -1 && (t = goog.html.SafeUrl.INNOCUOUS_STRING)) : t = goog.html.SafeUrl.INNOCUOUS_STRING, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.SafeUrl.fromTrustedResourceUrl = function(e) {
          return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(e));
        }, goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i, goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_, goog.html.SafeUrl.sanitize = function(e) {
          return e instanceof goog.html.SafeUrl ? e : (e = typeof e == "object" && e.implementsGoogStringTypedString ? e.getTypedStringValue() : String(e), goog.html.SAFE_URL_PATTERN_.test(e) || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e));
        }, goog.html.SafeUrl.sanitizeAssertUnchanged = function(e, t) {
          return e instanceof goog.html.SafeUrl ? e : (e = typeof e == "object" && e.implementsGoogStringTypedString ? e.getTypedStringValue() : String(e), t && /^data:/i.test(e) && (t = goog.html.SafeUrl.fromDataUrl(e)).getTypedStringValue() == e ? t : (goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(e), "%s does not match the safe URL pattern", e) || (e = goog.html.SafeUrl.INNOCUOUS_STRING), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(e)));
        }, goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(e) {
          var t = new goog.html.SafeUrl();
          return t.privateDoNotAccessOrElseSafeUrlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createURL(e) : e, t;
        }, goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank"), goog.html.SafeStyle = function() {
          this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "", this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
        }, goog.html.SafeStyle.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyle.fromConstant = function(e) {
          return (e = goog.string.Const.unwrap(e)).length === 0 ? goog.html.SafeStyle.EMPTY : (goog.asserts.assert(goog.string.internal.endsWith(e, ";"), "Last character of style string is not ';': " + e), goog.asserts.assert(goog.string.internal.contains(e, ":"), `Style string must contain at least one ':', to specify a "name: value" pair: ` + e), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(e));
        }, goog.html.SafeStyle.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
        }, goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
          return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
        }), goog.html.SafeStyle.unwrap = function(e) {
          return e instanceof goog.html.SafeStyle && e.constructor === goog.html.SafeStyle && e.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseSafeStyleWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyle, got '" + e + "' of type " + goog.typeOf(e)), "type_error:SafeStyle");
        }, goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(e) {
          return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(e);
        }, goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e) {
          return this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = e, this;
        }, goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(""), goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez", goog.html.SafeStyle.create = function(e) {
          var t, n = "";
          for (t in e) {
            if (!/^[-_a-zA-Z0-9]+$/.test(t))
              throw Error("Name allows only [-_a-zA-Z0-9], got: " + t);
            var r = e[t];
            r != null && (n += t + ":" + (r = goog.isArray(r) ? goog.array.map(r, goog.html.SafeStyle.sanitizePropertyValue_).join(" ") : goog.html.SafeStyle.sanitizePropertyValue_(r)) + ";");
          }
          return n ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(n) : goog.html.SafeStyle.EMPTY;
        }, goog.html.SafeStyle.sanitizePropertyValue_ = function(e) {
          if (e instanceof goog.html.SafeUrl)
            return 'url("' + goog.html.SafeUrl.unwrap(e).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")';
          if (e = e instanceof goog.string.Const ? goog.string.Const.unwrap(e) : goog.html.SafeStyle.sanitizePropertyValueString_(String(e)), /[{;}]/.test(e))
            throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.", [e]);
          return e;
        }, goog.html.SafeStyle.sanitizePropertyValueString_ = function(e) {
          var t = e.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
          return goog.html.SafeStyle.VALUE_RE_.test(t) ? goog.html.SafeStyle.COMMENT_RE_.test(e) ? (goog.asserts.fail("String value disallows comments, got: " + e), goog.html.SafeStyle.INNOCUOUS_STRING) : goog.html.SafeStyle.hasBalancedQuotes_(e) ? goog.html.SafeStyle.hasBalancedSquareBrackets_(e) ? goog.html.SafeStyle.sanitizeUrl_(e) : (goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: " + e), goog.html.SafeStyle.INNOCUOUS_STRING) : (goog.asserts.fail("String value requires balanced quotes, got: " + e), goog.html.SafeStyle.INNOCUOUS_STRING) : (goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + e), goog.html.SafeStyle.INNOCUOUS_STRING);
        }, goog.html.SafeStyle.hasBalancedQuotes_ = function(e) {
          for (var t = !0, n = !0, r = 0; r < e.length; r++) {
            var o = e.charAt(r);
            o == "'" && n ? t = !t : o == '"' && t && (n = !n);
          }
          return t && n;
        }, goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(e) {
          for (var t = !0, n = /^[-_a-zA-Z0-9]$/, r = 0; r < e.length; r++) {
            var o = e.charAt(r);
            if (o == "]") {
              if (t)
                return !1;
              t = !0;
            } else if (o == "[") {
              if (!t)
                return !1;
              t = !1;
            } else if (!t && !n.test(o))
              return !1;
          }
          return t;
        }, goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = `[-,."'%_!# a-zA-Z0-9\\[\\]]`, goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$"), goog.html.SafeStyle.URL_RE_ = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g, goog.html.SafeStyle.FUNCTIONS_RE_ = /\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|(rotate|scale|translate)(X|Y|Z|3d)?)\([-+*/0-9a-z.%\[\], ]+\)/g, goog.html.SafeStyle.COMMENT_RE_ = /\/\*/, goog.html.SafeStyle.sanitizeUrl_ = function(e) {
          return e.replace(goog.html.SafeStyle.URL_RE_, function(t, n, r, o) {
            var l = "";
            return r = r.replace(/^(['"])(.*)\1$/, function(u, s, g) {
              return l = s, g;
            }), t = goog.html.SafeUrl.sanitize(r).getTypedStringValue(), n + l + t + l + o;
          });
        }, goog.html.SafeStyle.concat = function(e) {
          var t = "", n = function(r) {
            goog.isArray(r) ? goog.array.forEach(r, n) : t += goog.html.SafeStyle.unwrap(r);
          };
          return goog.array.forEach(arguments, n), t ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(t) : goog.html.SafeStyle.EMPTY;
        }, goog.html.SafeScript = function() {
          this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "", this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
        }, goog.html.SafeScript.prototype.implementsGoogStringTypedString = !0, goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeScript.fromConstant = function(e) {
          return (e = goog.string.Const.unwrap(e)).length === 0 ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeScript.fromConstantAndArgs = function(e, t) {
          for (var n = [], r = 1; r < arguments.length; r++)
            n.push(goog.html.SafeScript.stringify_(arguments[r]));
          return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(e) + ")(" + n.join(", ") + ");");
        }, goog.html.SafeScript.fromJson = function(e) {
          return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(e));
        }, goog.html.SafeScript.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
        }, goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
          return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
        }), goog.html.SafeScript.unwrap = function(e) {
          return goog.html.SafeScript.unwrapTrustedScript(e).toString();
        }, goog.html.SafeScript.unwrapTrustedScript = function(e) {
          return e instanceof goog.html.SafeScript && e.constructor === goog.html.SafeScript && e.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseSafeScriptWrappedValue_ : (goog.asserts.fail("expected object of type SafeScript, got '" + e + "' of type " + goog.typeOf(e)), "type_error:SafeScript");
        }, goog.html.SafeScript.stringify_ = function(e) {
          return JSON.stringify(e).replace(/</g, "\\x3c");
        }, goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(e) {
          return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(e);
        }, goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e) {
          return this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(e) : e, this;
        }, goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(""), goog.object = {}, goog.object.is = function(e, t) {
          return e === t ? e !== 0 || 1 / e == 1 / t : e != e && t != t;
        }, goog.object.forEach = function(e, t, n) {
          for (var r in e)
            t.call(n, e[r], r, e);
        }, goog.object.filter = function(e, t, n) {
          var r, o = {};
          for (r in e)
            t.call(n, e[r], r, e) && (o[r] = e[r]);
          return o;
        }, goog.object.map = function(e, t, n) {
          var r, o = {};
          for (r in e)
            o[r] = t.call(n, e[r], r, e);
          return o;
        }, goog.object.some = function(e, t, n) {
          for (var r in e)
            if (t.call(n, e[r], r, e))
              return !0;
          return !1;
        }, goog.object.every = function(e, t, n) {
          for (var r in e)
            if (!t.call(n, e[r], r, e))
              return !1;
          return !0;
        }, goog.object.getCount = function(e) {
          var t, n = 0;
          for (t in e)
            n++;
          return n;
        }, goog.object.getAnyKey = function(e) {
          for (var t in e)
            return t;
        }, goog.object.getAnyValue = function(e) {
          for (var t in e)
            return e[t];
        }, goog.object.contains = function(e, t) {
          return goog.object.containsValue(e, t);
        }, goog.object.getValues = function(e) {
          var t, n = [], r = 0;
          for (t in e)
            n[r++] = e[t];
          return n;
        }, goog.object.getKeys = function(e) {
          var t, n = [], r = 0;
          for (t in e)
            n[r++] = t;
          return n;
        }, goog.object.getValueByKeys = function(e, t) {
          var n = goog.isArrayLike(t), r = n ? t : arguments;
          for (n = n ? 0 : 1; n < r.length; n++) {
            if (e == null)
              return;
            e = e[r[n]];
          }
          return e;
        }, goog.object.containsKey = function(e, t) {
          return e !== null && t in e;
        }, goog.object.containsValue = function(e, t) {
          for (var n in e)
            if (e[n] == t)
              return !0;
          return !1;
        }, goog.object.findKey = function(e, t, n) {
          for (var r in e)
            if (t.call(n, e[r], r, e))
              return r;
        }, goog.object.findValue = function(e, t, n) {
          return (t = goog.object.findKey(e, t, n)) && e[t];
        }, goog.object.isEmpty = function(e) {
          for (var t in e)
            return !1;
          return !0;
        }, goog.object.clear = function(e) {
          for (var t in e)
            delete e[t];
        }, goog.object.remove = function(e, t) {
          var n;
          return (n = t in e) && delete e[t], n;
        }, goog.object.add = function(e, t, n) {
          if (e !== null && t in e)
            throw Error('The object already contains the key "' + t + '"');
          goog.object.set(e, t, n);
        }, goog.object.get = function(e, t, n) {
          return e !== null && t in e ? e[t] : n;
        }, goog.object.set = function(e, t, n) {
          e[t] = n;
        }, goog.object.setIfUndefined = function(e, t, n) {
          return t in e ? e[t] : e[t] = n;
        }, goog.object.setWithReturnValueIfNotSet = function(e, t, n) {
          return t in e ? e[t] : (n = n(), e[t] = n);
        }, goog.object.equals = function(e, t) {
          for (var n in e)
            if (!(n in t) || e[n] !== t[n])
              return !1;
          for (var r in t)
            if (!(r in e))
              return !1;
          return !0;
        }, goog.object.clone = function(e) {
          var t, n = {};
          for (t in e)
            n[t] = e[t];
          return n;
        }, goog.object.unsafeClone = function(e) {
          var t = goog.typeOf(e);
          if (t == "object" || t == "array") {
            if (goog.isFunction(e.clone))
              return e.clone();
            for (var n in t = t == "array" ? [] : {}, e)
              t[n] = goog.object.unsafeClone(e[n]);
            return t;
          }
          return e;
        }, goog.object.transpose = function(e) {
          var t, n = {};
          for (t in e)
            n[e[t]] = t;
          return n;
        }, goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "), goog.object.extend = function(e, t) {
          for (var n, r, o = 1; o < arguments.length; o++) {
            for (n in r = arguments[o])
              e[n] = r[n];
            for (var l = 0; l < goog.object.PROTOTYPE_FIELDS_.length; l++)
              n = goog.object.PROTOTYPE_FIELDS_[l], Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
          }
        }, goog.object.create = function(e) {
          var t = arguments.length;
          if (t == 1 && goog.isArray(arguments[0]))
            return goog.object.create.apply(null, arguments[0]);
          if (t % 2)
            throw Error("Uneven number of arguments");
          for (var n = {}, r = 0; r < t; r += 2)
            n[arguments[r]] = arguments[r + 1];
          return n;
        }, goog.object.createSet = function(e) {
          var t = arguments.length;
          if (t == 1 && goog.isArray(arguments[0]))
            return goog.object.createSet.apply(null, arguments[0]);
          for (var n = {}, r = 0; r < t; r++)
            n[arguments[r]] = !0;
          return n;
        }, goog.object.createImmutableView = function(e) {
          var t = e;
          return Object.isFrozen && !Object.isFrozen(e) && (t = Object.create(e), Object.freeze(t)), t;
        }, goog.object.isImmutableView = function(e) {
          return !!Object.isFrozen && Object.isFrozen(e);
        }, goog.object.getAllPropertyNames = function(e, t, n) {
          if (!e)
            return [];
          if (!Object.getOwnPropertyNames || !Object.getPrototypeOf)
            return goog.object.getKeys(e);
          for (var r = {}; e && (e !== Object.prototype || t) && (e !== Function.prototype || n); ) {
            for (var o = Object.getOwnPropertyNames(e), l = 0; l < o.length; l++)
              r[o[l]] = !0;
            e = Object.getPrototypeOf(e);
          }
          return goog.object.getKeys(r);
        }, goog.object.getSuperClass = function(e) {
          return (e = Object.getPrototypeOf(e.prototype)) && e.constructor;
        }, goog.html.SafeStyleSheet = function() {
          this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "", this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
        }, goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = !0, goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeStyleSheet.createRule = function(e, t) {
          if (goog.string.internal.contains(e, "<"))
            throw Error("Selector does not allow '<', got: " + e);
          var n = e.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
          if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(n))
            throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + e);
          if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(n))
            throw Error("() and [] in selector must be balanced, got: " + e);
          return t instanceof goog.html.SafeStyle || (t = goog.html.SafeStyle.create(t)), e = e + "{" + goog.html.SafeStyle.unwrap(t).replace(/</g, "\\3C ") + "}", goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e);
        }, goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(e) {
          for (var t = { "(": ")", "[": "]" }, n = [], r = 0; r < e.length; r++) {
            var o = e[r];
            if (t[o])
              n.push(t[o]);
            else if (goog.object.contains(t, o) && n.pop() != o)
              return !1;
          }
          return n.length == 0;
        }, goog.html.SafeStyleSheet.concat = function(e) {
          var t = "", n = function(r) {
            goog.isArray(r) ? goog.array.forEach(r, n) : t += goog.html.SafeStyleSheet.unwrap(r);
          };
          return goog.array.forEach(arguments, n), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.SafeStyleSheet.fromConstant = function(e) {
          return (e = goog.string.Const.unwrap(e)).length === 0 ? goog.html.SafeStyleSheet.EMPTY : (goog.asserts.assert(!goog.string.internal.contains(e, "<"), "Forbidden '<' character in style sheet string: " + e), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(e));
        }, goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
        }, goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
          return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
        }), goog.html.SafeStyleSheet.unwrap = function(e) {
          return e instanceof goog.html.SafeStyleSheet && e.constructor === goog.html.SafeStyleSheet && e.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ : (goog.asserts.fail("expected object of type SafeStyleSheet, got '" + e + "' of type " + goog.typeOf(e)), "type_error:SafeStyleSheet");
        }, goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(e) {
          return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(e);
        }, goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e) {
          return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = e, this;
        }, goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(""), goog.dom.tags = {}, goog.dom.tags.VOID_TAGS_ = { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }, goog.dom.tags.isVoidTag = function(e) {
          return goog.dom.tags.VOID_TAGS_[e] === !0;
        }, goog.dom.HtmlElement = function() {
        }, goog.dom.TagName = function(e) {
          this.tagName_ = e;
        }, goog.dom.TagName.prototype.toString = function() {
          return this.tagName_;
        }, goog.dom.TagName.A = new goog.dom.TagName("A"), goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR"), goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM"), goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS"), goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET"), goog.dom.TagName.AREA = new goog.dom.TagName("AREA"), goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE"), goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE"), goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO"), goog.dom.TagName.B = new goog.dom.TagName("B"), goog.dom.TagName.BASE = new goog.dom.TagName("BASE"), goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT"), goog.dom.TagName.BDI = new goog.dom.TagName("BDI"), goog.dom.TagName.BDO = new goog.dom.TagName("BDO"), goog.dom.TagName.BIG = new goog.dom.TagName("BIG"), goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE"), goog.dom.TagName.BODY = new goog.dom.TagName("BODY"), goog.dom.TagName.BR = new goog.dom.TagName("BR"), goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON"), goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS"), goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION"), goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER"), goog.dom.TagName.CITE = new goog.dom.TagName("CITE"), goog.dom.TagName.CODE = new goog.dom.TagName("CODE"), goog.dom.TagName.COL = new goog.dom.TagName("COL"), goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP"), goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND"), goog.dom.TagName.DATA = new goog.dom.TagName("DATA"), goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST"), goog.dom.TagName.DD = new goog.dom.TagName("DD"), goog.dom.TagName.DEL = new goog.dom.TagName("DEL"), goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS"), goog.dom.TagName.DFN = new goog.dom.TagName("DFN"), goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG"), goog.dom.TagName.DIR = new goog.dom.TagName("DIR"), goog.dom.TagName.DIV = new goog.dom.TagName("DIV"), goog.dom.TagName.DL = new goog.dom.TagName("DL"), goog.dom.TagName.DT = new goog.dom.TagName("DT"), goog.dom.TagName.EM = new goog.dom.TagName("EM"), goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED"), goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET"), goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION"), goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE"), goog.dom.TagName.FONT = new goog.dom.TagName("FONT"), goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER"), goog.dom.TagName.FORM = new goog.dom.TagName("FORM"), goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME"), goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET"), goog.dom.TagName.H1 = new goog.dom.TagName("H1"), goog.dom.TagName.H2 = new goog.dom.TagName("H2"), goog.dom.TagName.H3 = new goog.dom.TagName("H3"), goog.dom.TagName.H4 = new goog.dom.TagName("H4"), goog.dom.TagName.H5 = new goog.dom.TagName("H5"), goog.dom.TagName.H6 = new goog.dom.TagName("H6"), goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD"), goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER"), goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP"), goog.dom.TagName.HR = new goog.dom.TagName("HR"), goog.dom.TagName.HTML = new goog.dom.TagName("HTML"), goog.dom.TagName.I = new goog.dom.TagName("I"), goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME"), goog.dom.TagName.IMG = new goog.dom.TagName("IMG"), goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT"), goog.dom.TagName.INS = new goog.dom.TagName("INS"), goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX"), goog.dom.TagName.KBD = new goog.dom.TagName("KBD"), goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN"), goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL"), goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND"), goog.dom.TagName.LI = new goog.dom.TagName("LI"), goog.dom.TagName.LINK = new goog.dom.TagName("LINK"), goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN"), goog.dom.TagName.MAP = new goog.dom.TagName("MAP"), goog.dom.TagName.MARK = new goog.dom.TagName("MARK"), goog.dom.TagName.MATH = new goog.dom.TagName("MATH"), goog.dom.TagName.MENU = new goog.dom.TagName("MENU"), goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM"), goog.dom.TagName.META = new goog.dom.TagName("META"), goog.dom.TagName.METER = new goog.dom.TagName("METER"), goog.dom.TagName.NAV = new goog.dom.TagName("NAV"), goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES"), goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT"), goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT"), goog.dom.TagName.OL = new goog.dom.TagName("OL"), goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP"), goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION"), goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT"), goog.dom.TagName.P = new goog.dom.TagName("P"), goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM"), goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE"), goog.dom.TagName.PRE = new goog.dom.TagName("PRE"), goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS"), goog.dom.TagName.Q = new goog.dom.TagName("Q"), goog.dom.TagName.RP = new goog.dom.TagName("RP"), goog.dom.TagName.RT = new goog.dom.TagName("RT"), goog.dom.TagName.RTC = new goog.dom.TagName("RTC"), goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY"), goog.dom.TagName.S = new goog.dom.TagName("S"), goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP"), goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT"), goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION"), goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT"), goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL"), goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE"), goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN"), goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE"), goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG"), goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE"), goog.dom.TagName.SUB = new goog.dom.TagName("SUB"), goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY"), goog.dom.TagName.SUP = new goog.dom.TagName("SUP"), goog.dom.TagName.SVG = new goog.dom.TagName("SVG"), goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE"), goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY"), goog.dom.TagName.TD = new goog.dom.TagName("TD"), goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE"), goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA"), goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT"), goog.dom.TagName.TH = new goog.dom.TagName("TH"), goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD"), goog.dom.TagName.TIME = new goog.dom.TagName("TIME"), goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE"), goog.dom.TagName.TR = new goog.dom.TagName("TR"), goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK"), goog.dom.TagName.TT = new goog.dom.TagName("TT"), goog.dom.TagName.U = new goog.dom.TagName("U"), goog.dom.TagName.UL = new goog.dom.TagName("UL"), goog.dom.TagName.VAR = new goog.dom.TagName("VAR"), goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO"), goog.dom.TagName.WBR = new goog.dom.TagName("WBR"), goog.labs = {}, goog.labs.userAgent = {}, goog.labs.userAgent.util = {}, goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
          var e = goog.labs.userAgent.util.getNavigator_();
          return e && (e = e.userAgent) ? e : "";
        }, goog.labs.userAgent.util.getNavigator_ = function() {
          return goog.global.navigator;
        }, goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_(), goog.labs.userAgent.util.setUserAgent = function(e) {
          goog.labs.userAgent.util.userAgent_ = e || goog.labs.userAgent.util.getNativeUserAgentString_();
        }, goog.labs.userAgent.util.getUserAgent = function() {
          return goog.labs.userAgent.util.userAgent_;
        }, goog.labs.userAgent.util.matchUserAgent = function(e) {
          var t = goog.labs.userAgent.util.getUserAgent();
          return goog.string.internal.contains(t, e);
        }, goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(e) {
          var t = goog.labs.userAgent.util.getUserAgent();
          return goog.string.internal.caseInsensitiveContains(t, e);
        }, goog.labs.userAgent.util.extractVersionTuples = function(e) {
          for (var t, n = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, r = []; t = n.exec(e); )
            r.push([t[1], t[2], t[3] || void 0]);
          return r;
        }, goog.labs.userAgent.browser = {}, goog.labs.userAgent.browser.matchOpera_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Opera");
        }, goog.labs.userAgent.browser.matchIE_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
        }, goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Edge");
        }, goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Edg/");
        }, goog.labs.userAgent.browser.matchOperaChromium_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("OPR");
        }, goog.labs.userAgent.browser.matchFirefox_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Firefox") || goog.labs.userAgent.util.matchUserAgent("FxiOS");
        }, goog.labs.userAgent.browser.matchSafari_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdgeHtml_() || goog.labs.userAgent.browser.matchEdgeChromium_() || goog.labs.userAgent.browser.matchOperaChromium_() || goog.labs.userAgent.browser.matchFirefox_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
        }, goog.labs.userAgent.browser.matchCoast_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Coast");
        }, goog.labs.userAgent.browser.matchIosWebview_ = function() {
          return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && !goog.labs.userAgent.browser.matchFirefox_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
        }, goog.labs.userAgent.browser.matchChrome_ = function() {
          return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdgeHtml_();
        }, goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
          return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
        }, goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_, goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_, goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_, goog.labs.userAgent.browser.isEdgeChromium = goog.labs.userAgent.browser.matchEdgeChromium_, goog.labs.userAgent.browser.isOperaChromium = goog.labs.userAgent.browser.matchOperaChromium_, goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_, goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_, goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_, goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_, goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_, goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_, goog.labs.userAgent.browser.isSilk = function() {
          return goog.labs.userAgent.util.matchUserAgent("Silk");
        }, goog.labs.userAgent.browser.getVersion = function() {
          function e(o) {
            return o = goog.array.find(o, r), n[o] || "";
          }
          var t = goog.labs.userAgent.util.getUserAgent();
          if (goog.labs.userAgent.browser.isIE())
            return goog.labs.userAgent.browser.getIEVersion_(t);
          t = goog.labs.userAgent.util.extractVersionTuples(t);
          var n = {};
          goog.array.forEach(t, function(o) {
            n[o[0]] = o[1];
          });
          var r = goog.partial(goog.object.containsKey, n);
          return goog.labs.userAgent.browser.isOpera() ? e(["Version", "Opera"]) : goog.labs.userAgent.browser.isEdge() ? e(["Edge"]) : goog.labs.userAgent.browser.isEdgeChromium() ? e(["Edg"]) : goog.labs.userAgent.browser.isChrome() ? e(["Chrome", "CriOS"]) : (t = t[2]) && t[1] || "";
        }, goog.labs.userAgent.browser.isVersionOrHigher = function(e) {
          return 0 <= goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(), e);
        }, goog.labs.userAgent.browser.getIEVersion_ = function(e) {
          var t = /rv: *([\d\.]*)/.exec(e);
          if (t && t[1])
            return t[1];
          t = "";
          var n = /MSIE +([\d\.]+)/.exec(e);
          if (n && n[1])
            if (e = /Trident\/(\d.\d)/.exec(e), n[1] == "7.0")
              if (e && e[1])
                switch (e[1]) {
                  case "4.0":
                    t = "8.0";
                    break;
                  case "5.0":
                    t = "9.0";
                    break;
                  case "6.0":
                    t = "10.0";
                    break;
                  case "7.0":
                    t = "11.0";
                }
              else
                t = "7.0";
            else
              t = n[1];
          return t;
        }, goog.html.SafeHtml = function() {
          this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "", this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_, this.dir_ = null;
        }, goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = !0, goog.html.SafeHtml.prototype.getDirection = function() {
          return this.dir_;
        }, goog.html.SafeHtml.prototype.implementsGoogStringTypedString = !0, goog.html.SafeHtml.prototype.getTypedStringValue = function() {
          return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
        }, goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
          return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
        }), goog.html.SafeHtml.unwrap = function(e) {
          return goog.html.SafeHtml.unwrapTrustedHTML(e).toString();
        }, goog.html.SafeHtml.unwrapTrustedHTML = function(e) {
          return e instanceof goog.html.SafeHtml && e.constructor === goog.html.SafeHtml && e.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ ? e.privateDoNotAccessOrElseSafeHtmlWrappedValue_ : (goog.asserts.fail("expected object of type SafeHtml, got '" + e + "' of type " + goog.typeOf(e)), "type_error:SafeHtml");
        }, goog.html.SafeHtml.htmlEscape = function(e) {
          if (e instanceof goog.html.SafeHtml)
            return e;
          var t = typeof e == "object", n = null;
          return t && e.implementsGoogI18nBidiDirectionalString && (n = e.getDirection()), e = t && e.implementsGoogStringTypedString ? e.getTypedStringValue() : String(e), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(e), n);
        }, goog.html.SafeHtml.htmlEscapePreservingNewlines = function(e) {
          return e instanceof goog.html.SafeHtml ? e : (e = goog.html.SafeHtml.htmlEscape(e), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(e)), e.getDirection()));
        }, goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(e) {
          return e instanceof goog.html.SafeHtml ? e : (e = goog.html.SafeHtml.htmlEscape(e), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(e)), e.getDirection()));
        }, goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape, goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/, goog.html.SafeHtml.URL_ATTRIBUTES_ = { action: !0, cite: !0, data: !0, formaction: !0, href: !0, manifest: !0, poster: !0, src: !0 }, goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = { APPLET: !0, BASE: !0, EMBED: !0, IFRAME: !0, LINK: !0, MATH: !0, META: !0, OBJECT: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.html.SafeHtml.create = function(e, t, n) {
          return goog.html.SafeHtml.verifyTagName(String(e)), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(e), t, n);
        }, goog.html.SafeHtml.verifyTagName = function(e) {
          if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(e))
            throw Error("Invalid tag name <" + e + ">.");
          if (e.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)
            throw Error("Tag name <" + e + "> is not allowed for SafeHtml.");
        }, goog.html.SafeHtml.createIframe = function(e, t, n, r) {
          e && goog.html.TrustedResourceUrl.unwrap(e);
          var o = {};
          return o.src = e || null, o.srcdoc = t && goog.html.SafeHtml.unwrap(t), e = goog.html.SafeHtml.combineAttributes(o, { sandbox: "" }, n), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", e, r);
        }, goog.html.SafeHtml.createSandboxIframe = function(e, t, n, r) {
          if (!goog.html.SafeHtml.canUseSandboxIframe())
            throw Error("The browser does not support sandboxed iframes.");
          var o = {};
          return o.src = e ? goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(e)) : null, o.srcdoc = t || null, o.sandbox = "", e = goog.html.SafeHtml.combineAttributes(o, {}, n), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", e, r);
        }, goog.html.SafeHtml.canUseSandboxIframe = function() {
          return goog.global.HTMLIFrameElement && "sandbox" in goog.global.HTMLIFrameElement.prototype;
        }, goog.html.SafeHtml.createScriptSrc = function(e, t) {
          return goog.html.TrustedResourceUrl.unwrap(e), e = goog.html.SafeHtml.combineAttributes({ src: e }, {}, t), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", e);
        }, goog.html.SafeHtml.createScript = function(e, t) {
          for (var n in t) {
            var r = n.toLowerCase();
            if (r == "language" || r == "src" || r == "text" || r == "type")
              throw Error('Cannot set "' + r + '" attribute');
          }
          for (n = "", e = goog.array.concat(e), r = 0; r < e.length; r++)
            n += goog.html.SafeScript.unwrap(e[r]);
          return e = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(n, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", t, e);
        }, goog.html.SafeHtml.createStyle = function(e, t) {
          t = goog.html.SafeHtml.combineAttributes({ type: "text/css" }, {}, t);
          var n = "";
          e = goog.array.concat(e);
          for (var r = 0; r < e.length; r++)
            n += goog.html.SafeStyleSheet.unwrap(e[r]);
          return e = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(n, goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style", t, e);
        }, goog.html.SafeHtml.createMetaRefresh = function(e, t) {
          return e = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(e)), (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge()) && goog.string.internal.contains(e, ";") && (e = "'" + e.replace(/'/g, "%27") + "'"), goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", { "http-equiv": "refresh", content: (t || 0) + "; url=" + e });
        }, goog.html.SafeHtml.getAttrNameAndValue_ = function(e, t, n) {
          if (n instanceof goog.string.Const)
            n = goog.string.Const.unwrap(n);
          else if (t.toLowerCase() == "style")
            n = goog.html.SafeHtml.getStyleValue_(n);
          else {
            if (/^on/i.test(t))
              throw Error('Attribute "' + t + '" requires goog.string.Const value, "' + n + '" given.');
            if (t.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
              if (n instanceof goog.html.TrustedResourceUrl)
                n = goog.html.TrustedResourceUrl.unwrap(n);
              else if (n instanceof goog.html.SafeUrl)
                n = goog.html.SafeUrl.unwrap(n);
              else {
                if (!goog.isString(n))
                  throw Error('Attribute "' + t + '" on tag "' + e + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + n + '" given.');
                n = goog.html.SafeUrl.sanitize(n).getTypedStringValue();
              }
          }
          return n.implementsGoogStringTypedString && (n = n.getTypedStringValue()), goog.asserts.assert(goog.isString(n) || goog.isNumber(n), "String or number value expected, got " + typeof n + " with value: " + n), t + '="' + goog.string.internal.htmlEscape(String(n)) + '"';
        }, goog.html.SafeHtml.getStyleValue_ = function(e) {
          if (!goog.isObject(e))
            throw Error('The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof e + " given: " + e);
          return e instanceof goog.html.SafeStyle || (e = goog.html.SafeStyle.create(e)), goog.html.SafeStyle.unwrap(e);
        }, goog.html.SafeHtml.createWithDir = function(e, t, n, r) {
          return (t = goog.html.SafeHtml.create(t, n, r)).dir_ = e, t;
        }, goog.html.SafeHtml.join = function(e, t) {
          var n = (e = goog.html.SafeHtml.htmlEscape(e)).getDirection(), r = [], o = function(l) {
            goog.isArray(l) ? goog.array.forEach(l, o) : (l = goog.html.SafeHtml.htmlEscape(l), r.push(goog.html.SafeHtml.unwrap(l)), l = l.getDirection(), n == goog.i18n.bidi.Dir.NEUTRAL ? n = l : l != goog.i18n.bidi.Dir.NEUTRAL && n != l && (n = null));
          };
          return goog.array.forEach(t, o), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(r.join(goog.html.SafeHtml.unwrap(e)), n);
        }, goog.html.SafeHtml.concat = function(e) {
          return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
        }, goog.html.SafeHtml.concatWithDir = function(e, t) {
          var n = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
          return n.dir_ = e, n;
        }, goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {}, goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(e, t) {
          return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(e, t);
        }, goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(e, t) {
          return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(e) : e, this.dir_ = t, this;
        }, goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(e, t, n) {
          var r = null, o = "<" + e + goog.html.SafeHtml.stringifyAttributes(e, t);
          return goog.isDefAndNotNull(n) ? goog.isArray(n) || (n = [n]) : n = [], goog.dom.tags.isVoidTag(e.toLowerCase()) ? (goog.asserts.assert(!n.length, "Void tag <" + e + "> does not allow content."), o += ">") : (r = goog.html.SafeHtml.concat(n), o += ">" + goog.html.SafeHtml.unwrap(r) + "</" + e + ">", r = r.getDirection()), (e = t && t.dir) && (r = /^(ltr|rtl|auto)$/i.test(e) ? goog.i18n.bidi.Dir.NEUTRAL : null), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(o, r);
        }, goog.html.SafeHtml.stringifyAttributes = function(e, t) {
          var n = "";
          if (t)
            for (var r in t) {
              if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(r))
                throw Error('Invalid attribute name "' + r + '".');
              var o = t[r];
              goog.isDefAndNotNull(o) && (n += " " + goog.html.SafeHtml.getAttrNameAndValue_(e, r, o));
            }
          return n;
        }, goog.html.SafeHtml.combineAttributes = function(e, t, n) {
          var r, o = {};
          for (r in e)
            goog.asserts.assert(r.toLowerCase() == r, "Must be lower case"), o[r] = e[r];
          for (r in t)
            goog.asserts.assert(r.toLowerCase() == r, "Must be lower case"), o[r] = t[r];
          for (r in n) {
            var l = r.toLowerCase();
            if (l in e)
              throw Error('Cannot override "' + l + '" attribute, got "' + r + '" with value "' + n[r] + '"');
            l in t && delete o[l], o[r] = n[r];
          }
          return o;
        }, goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL), goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL), goog.html.uncheckedconversions = {}, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(e, t, n) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(t, n || null);
        }, goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(e, t) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(e, t) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(e, t) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(e, t) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(t);
        }, goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(e, t) {
          return goog.asserts.assertString(goog.string.Const.unwrap(e), "must provide justification"), goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(e)), "must provide non-empty justification"), goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(t);
        }, goog.dom.asserts = {}, goog.dom.asserts.assertIsLocation = function(e) {
          if (goog.asserts.ENABLE_ASSERTS) {
            var t = goog.dom.asserts.getWindow_(e);
            t && (!e || !(e instanceof t.Location) && e instanceof t.Element) && goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(e));
          }
          return e;
        }, goog.dom.asserts.assertIsElementType_ = function(e, t) {
          if (goog.asserts.ENABLE_ASSERTS) {
            var n = goog.dom.asserts.getWindow_(e);
            n && n[t] !== void 0 && (e && (e instanceof n[t] || !(e instanceof n.Location || e instanceof n.Element)) || goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s", t, goog.dom.asserts.debugStringForType_(e)));
          }
          return e;
        }, goog.dom.asserts.assertIsHTMLAnchorElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLAnchorElement");
        }, goog.dom.asserts.assertIsHTMLButtonElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLButtonElement");
        }, goog.dom.asserts.assertIsHTMLLinkElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLLinkElement");
        }, goog.dom.asserts.assertIsHTMLImageElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLImageElement");
        }, goog.dom.asserts.assertIsHTMLAudioElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLAudioElement");
        }, goog.dom.asserts.assertIsHTMLVideoElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLVideoElement");
        }, goog.dom.asserts.assertIsHTMLInputElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLInputElement");
        }, goog.dom.asserts.assertIsHTMLTextAreaElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLTextAreaElement");
        }, goog.dom.asserts.assertIsHTMLCanvasElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLCanvasElement");
        }, goog.dom.asserts.assertIsHTMLEmbedElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLEmbedElement");
        }, goog.dom.asserts.assertIsHTMLFormElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLFormElement");
        }, goog.dom.asserts.assertIsHTMLFrameElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLFrameElement");
        }, goog.dom.asserts.assertIsHTMLIFrameElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLIFrameElement");
        }, goog.dom.asserts.assertIsHTMLObjectElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLObjectElement");
        }, goog.dom.asserts.assertIsHTMLScriptElement = function(e) {
          return goog.dom.asserts.assertIsElementType_(e, "HTMLScriptElement");
        }, goog.dom.asserts.debugStringForType_ = function(e) {
          if (!goog.isObject(e))
            return e === void 0 ? "undefined" : e === null ? "null" : typeof e;
          try {
            return e.constructor.displayName || e.constructor.name || Object.prototype.toString.call(e);
          } catch {
            return "<object could not be stringified>";
          }
        }, goog.dom.asserts.getWindow_ = function(e) {
          try {
            var t = e && e.ownerDocument, n = t && (t.defaultView || t.parentWindow);
            if ((n = n || goog.global).Element && n.Location)
              return n;
          } catch {
          }
          return null;
        }, goog.functions = {}, goog.functions.constant = function(e) {
          return function() {
            return e;
          };
        }, goog.functions.FALSE = function() {
          return !1;
        }, goog.functions.TRUE = function() {
          return !0;
        }, goog.functions.NULL = function() {
          return null;
        }, goog.functions.identity = function(e, t) {
          return e;
        }, goog.functions.error = function(e) {
          return function() {
            throw Error(e);
          };
        }, goog.functions.fail = function(e) {
          return function() {
            throw e;
          };
        }, goog.functions.lock = function(e, t) {
          return t = t || 0, function() {
            return e.apply(this, Array.prototype.slice.call(arguments, 0, t));
          };
        }, goog.functions.nth = function(e) {
          return function() {
            return arguments[e];
          };
        }, goog.functions.partialRight = function(e, t) {
          var n = Array.prototype.slice.call(arguments, 1);
          return function() {
            var r = Array.prototype.slice.call(arguments);
            return r.push.apply(r, n), e.apply(this, r);
          };
        }, goog.functions.withReturnValue = function(e, t) {
          return goog.functions.sequence(e, goog.functions.constant(t));
        }, goog.functions.equalTo = function(e, t) {
          return function(n) {
            return t ? e == n : e === n;
          };
        }, goog.functions.compose = function(e, t) {
          var n = arguments, r = n.length;
          return function() {
            var o;
            r && (o = n[r - 1].apply(this, arguments));
            for (var l = r - 2; 0 <= l; l--)
              o = n[l].call(this, o);
            return o;
          };
        }, goog.functions.sequence = function(e) {
          var t = arguments, n = t.length;
          return function() {
            for (var r, o = 0; o < n; o++)
              r = t[o].apply(this, arguments);
            return r;
          };
        }, goog.functions.and = function(e) {
          var t = arguments, n = t.length;
          return function() {
            for (var r = 0; r < n; r++)
              if (!t[r].apply(this, arguments))
                return !1;
            return !0;
          };
        }, goog.functions.or = function(e) {
          var t = arguments, n = t.length;
          return function() {
            for (var r = 0; r < n; r++)
              if (t[r].apply(this, arguments))
                return !0;
            return !1;
          };
        }, goog.functions.not = function(e) {
          return function() {
            return !e.apply(this, arguments);
          };
        }, goog.functions.create = function(e, t) {
          var n = function() {
          };
          return n.prototype = e.prototype, n = new n(), e.apply(n, Array.prototype.slice.call(arguments, 1)), n;
        }, goog.functions.CACHE_RETURN_VALUE = !0, goog.functions.cacheReturnValue = function(e) {
          var t, n = !1;
          return function() {
            return goog.functions.CACHE_RETURN_VALUE ? (n || (t = e(), n = !0), t) : e();
          };
        }, goog.functions.once = function(e) {
          var t = e;
          return function() {
            if (t) {
              var n = t;
              t = null, n();
            }
          };
        }, goog.functions.debounce = function(e, t, n) {
          var r = 0;
          return function(o) {
            goog.global.clearTimeout(r);
            var l = arguments;
            r = goog.global.setTimeout(function() {
              e.apply(n, l);
            }, t);
          };
        }, goog.functions.throttle = function(e, t, n) {
          var r = 0, o = !1, l = [], u = function() {
            r = 0, o && (o = !1, s());
          }, s = function() {
            r = goog.global.setTimeout(u, t), e.apply(n, l);
          };
          return function(g) {
            l = arguments, r ? o = !0 : s();
          };
        }, goog.functions.rateLimit = function(e, t, n) {
          var r = 0, o = function() {
            r = 0;
          };
          return function(l) {
            r || (r = goog.global.setTimeout(o, t), e.apply(n, arguments));
          };
        }, goog.dom.safe = {}, goog.dom.safe.InsertAdjacentHtmlPosition = { AFTERBEGIN: "afterbegin", AFTEREND: "afterend", BEFOREBEGIN: "beforebegin", BEFOREEND: "beforeend" }, goog.dom.safe.insertAdjacentHtml = function(e, t, n) {
          e.insertAdjacentHTML(t, goog.html.SafeHtml.unwrapTrustedHTML(n));
        }, goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = { MATH: !0, SCRIPT: !0, STYLE: !0, SVG: !0, TEMPLATE: !0 }, goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
          if (goog.DEBUG && typeof document > "u")
            return !1;
          var e = document.createElement("div"), t = document.createElement("div");
          return t.appendChild(document.createElement("div")), e.appendChild(t), !(goog.DEBUG && !e.firstChild) && (t = e.firstChild.firstChild, e.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY), !t.parentElement);
        }), goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(e, t) {
          if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
            for (; e.lastChild; )
              e.removeChild(e.lastChild);
          e.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(t);
        }, goog.dom.safe.setInnerHtml = function(e, t) {
          if (goog.asserts.ENABLE_ASSERTS) {
            var n = e.tagName.toUpperCase();
            if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[n])
              throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + e.tagName + ".");
          }
          goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(e, t);
        }, goog.dom.safe.setOuterHtml = function(e, t) {
          e.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(t);
        }, goog.dom.safe.setFormElementAction = function(e, t) {
          t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), goog.dom.asserts.assertIsHTMLFormElement(e).action = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setButtonFormAction = function(e, t) {
          t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), goog.dom.asserts.assertIsHTMLButtonElement(e).formAction = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setInputFormAction = function(e, t) {
          t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), goog.dom.asserts.assertIsHTMLInputElement(e).formAction = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setStyle = function(e, t) {
          e.style.cssText = goog.html.SafeStyle.unwrap(t);
        }, goog.dom.safe.documentWrite = function(e, t) {
          e.write(goog.html.SafeHtml.unwrapTrustedHTML(t));
        }, goog.dom.safe.setAnchorHref = function(e, t) {
          goog.dom.asserts.assertIsHTMLAnchorElement(e), t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), e.href = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setImageSrc = function(e, t) {
          if (goog.dom.asserts.assertIsHTMLImageElement(e), !(t instanceof goog.html.SafeUrl)) {
            var n = /^data:image\//i.test(t);
            t = goog.html.SafeUrl.sanitizeAssertUnchanged(t, n);
          }
          e.src = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setAudioSrc = function(e, t) {
          if (goog.dom.asserts.assertIsHTMLAudioElement(e), !(t instanceof goog.html.SafeUrl)) {
            var n = /^data:audio\//i.test(t);
            t = goog.html.SafeUrl.sanitizeAssertUnchanged(t, n);
          }
          e.src = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setVideoSrc = function(e, t) {
          if (goog.dom.asserts.assertIsHTMLVideoElement(e), !(t instanceof goog.html.SafeUrl)) {
            var n = /^data:video\//i.test(t);
            t = goog.html.SafeUrl.sanitizeAssertUnchanged(t, n);
          }
          e.src = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setEmbedSrc = function(e, t) {
          goog.dom.asserts.assertIsHTMLEmbedElement(e), e.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t);
        }, goog.dom.safe.setFrameSrc = function(e, t) {
          goog.dom.asserts.assertIsHTMLFrameElement(e), e.src = goog.html.TrustedResourceUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setIframeSrc = function(e, t) {
          goog.dom.asserts.assertIsHTMLIFrameElement(e), e.src = goog.html.TrustedResourceUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.setIframeSrcdoc = function(e, t) {
          goog.dom.asserts.assertIsHTMLIFrameElement(e), e.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(t);
        }, goog.dom.safe.setLinkHrefAndRel = function(e, t, n) {
          goog.dom.asserts.assertIsHTMLLinkElement(e), e.rel = n, goog.string.internal.caseInsensitiveContains(n, "stylesheet") ? (goog.asserts.assert(t instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'), e.href = goog.html.TrustedResourceUrl.unwrapTrustedURL(t)) : e.href = t instanceof goog.html.TrustedResourceUrl ? goog.html.TrustedResourceUrl.unwrapTrustedURL(t) : t instanceof goog.html.SafeUrl ? goog.html.SafeUrl.unwrapTrustedURL(t) : goog.html.SafeUrl.unwrapTrustedURL(goog.html.SafeUrl.sanitizeAssertUnchanged(t));
        }, goog.dom.safe.setObjectData = function(e, t) {
          goog.dom.asserts.assertIsHTMLObjectElement(e), e.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t);
        }, goog.dom.safe.setScriptSrc = function(e, t) {
          goog.dom.asserts.assertIsHTMLScriptElement(e), e.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(t), (t = goog.getScriptNonce()) && e.setAttribute("nonce", t);
        }, goog.dom.safe.setScriptContent = function(e, t) {
          goog.dom.asserts.assertIsHTMLScriptElement(e), e.text = goog.html.SafeScript.unwrapTrustedScript(t), (t = goog.getScriptNonce()) && e.setAttribute("nonce", t);
        }, goog.dom.safe.setLocationHref = function(e, t) {
          goog.dom.asserts.assertIsLocation(e), t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), e.href = goog.html.SafeUrl.unwrapTrustedURL(t);
        }, goog.dom.safe.assignLocation = function(e, t) {
          goog.dom.asserts.assertIsLocation(e), t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), e.assign(goog.html.SafeUrl.unwrapTrustedURL(t));
        }, goog.dom.safe.replaceLocation = function(e, t) {
          goog.dom.asserts.assertIsLocation(e), t = t instanceof goog.html.SafeUrl ? t : goog.html.SafeUrl.sanitizeAssertUnchanged(t), e.replace(goog.html.SafeUrl.unwrapTrustedURL(t));
        }, goog.dom.safe.openInWindow = function(e, t, n, r, o) {
          return e = e instanceof goog.html.SafeUrl ? e : goog.html.SafeUrl.sanitizeAssertUnchanged(e), (t || goog.global).open(goog.html.SafeUrl.unwrapTrustedURL(e), n ? goog.string.Const.unwrap(n) : "", r, o);
        }, goog.dom.safe.parseFromStringHtml = function(e, t) {
          return goog.dom.safe.parseFromString(e, t, "text/html");
        }, goog.dom.safe.parseFromString = function(e, t, n) {
          return e.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(t), n);
        }, goog.dom.safe.createImageFromBlob = function(e) {
          if (!/^image\/.*/g.test(e.type))
            throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");
          var t = goog.global.URL.createObjectURL(e);
          return (e = new goog.global.Image()).onload = function() {
            goog.global.URL.revokeObjectURL(t);
          }, goog.dom.safe.setImageSrc(e, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."), t)), e;
        }, goog.string.DETECT_DOUBLE_ESCAPING = !1, goog.string.FORCE_NON_DOM_HTML_UNESCAPING = !1, goog.string.Unicode = { NBSP: " " }, goog.string.startsWith = goog.string.internal.startsWith, goog.string.endsWith = goog.string.internal.endsWith, goog.string.caseInsensitiveStartsWith = goog.string.internal.caseInsensitiveStartsWith, goog.string.caseInsensitiveEndsWith = goog.string.internal.caseInsensitiveEndsWith, goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals, goog.string.subs = function(e, t) {
          for (var n = e.split("%s"), r = "", o = Array.prototype.slice.call(arguments, 1); o.length && 1 < n.length; )
            r += n.shift() + o.shift();
          return r + n.join("%s");
        }, goog.string.collapseWhitespace = function(e) {
          return e.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
        }, goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace, goog.string.isEmptyString = function(e) {
          return e.length == 0;
        }, goog.string.isEmpty = goog.string.isEmptyOrWhitespace, goog.string.isEmptyOrWhitespaceSafe = function(e) {
          return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(e));
        }, goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe, goog.string.isBreakingWhitespace = function(e) {
          return !/[^\t\n\r ]/.test(e);
        }, goog.string.isAlpha = function(e) {
          return !/[^a-zA-Z]/.test(e);
        }, goog.string.isNumeric = function(e) {
          return !/[^0-9]/.test(e);
        }, goog.string.isAlphaNumeric = function(e) {
          return !/[^a-zA-Z0-9]/.test(e);
        }, goog.string.isSpace = function(e) {
          return e == " ";
        }, goog.string.isUnicodeChar = function(e) {
          return e.length == 1 && " " <= e && "~" >= e || "" <= e && "�" >= e;
        }, goog.string.stripNewlines = function(e) {
          return e.replace(/(\r\n|\r|\n)+/g, " ");
        }, goog.string.canonicalizeNewlines = function(e) {
          return e.replace(/(\r\n|\r|\n)/g, `
`);
        }, goog.string.normalizeWhitespace = function(e) {
          return e.replace(/\xa0|\s/g, " ");
        }, goog.string.normalizeSpaces = function(e) {
          return e.replace(/\xa0|[ \t]+/g, " ");
        }, goog.string.collapseBreakingSpaces = function(e) {
          return e.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
        }, goog.string.trim = goog.string.internal.trim, goog.string.trimLeft = function(e) {
          return e.replace(/^[\s\xa0]+/, "");
        }, goog.string.trimRight = function(e) {
          return e.replace(/[\s\xa0]+$/, "");
        }, goog.string.caseInsensitiveCompare = goog.string.internal.caseInsensitiveCompare, goog.string.numberAwareCompare_ = function(e, t, n) {
          if (e == t)
            return 0;
          if (!e)
            return -1;
          if (!t)
            return 1;
          for (var r = e.toLowerCase().match(n), o = t.toLowerCase().match(n), l = Math.min(r.length, o.length), u = 0; u < l; u++) {
            n = r[u];
            var s = o[u];
            if (n != s)
              return e = parseInt(n, 10), !isNaN(e) && (t = parseInt(s, 10), !isNaN(t) && e - t) ? e - t : n < s ? -1 : 1;
          }
          return r.length != o.length ? r.length - o.length : e < t ? -1 : 1;
        }, goog.string.intAwareCompare = function(e, t) {
          return goog.string.numberAwareCompare_(e, t, /\d+|\D+/g);
        }, goog.string.floatAwareCompare = function(e, t) {
          return goog.string.numberAwareCompare_(e, t, /\d+|\.\d+|\D+/g);
        }, goog.string.numerateCompare = goog.string.floatAwareCompare, goog.string.urlEncode = function(e) {
          return encodeURIComponent(String(e));
        }, goog.string.urlDecode = function(e) {
          return decodeURIComponent(e.replace(/\+/g, " "));
        }, goog.string.newLineToBr = goog.string.internal.newLineToBr, goog.string.htmlEscape = function(e, t) {
          return e = goog.string.internal.htmlEscape(e, t), goog.string.DETECT_DOUBLE_ESCAPING && (e = e.replace(goog.string.E_RE_, "&#101;")), e;
        }, goog.string.E_RE_ = /e/g, goog.string.unescapeEntities = function(e) {
          return goog.string.contains(e, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(e) : goog.string.unescapePureXmlEntities_(e) : e;
        }, goog.string.unescapeEntitiesWithDocument = function(e, t) {
          return goog.string.contains(e, "&") ? goog.string.unescapeEntitiesUsingDom_(e, t) : e;
        }, goog.string.unescapeEntitiesUsingDom_ = function(e, t) {
          var n = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' }, r = t ? t.createElement("div") : goog.global.document.createElement("div");
          return e.replace(goog.string.HTML_ENTITY_PATTERN_, function(o, l) {
            var u = n[o];
            return u || (l.charAt(0) == "#" && (l = +("0" + l.substr(1)), isNaN(l) || (u = String.fromCharCode(l))), u || (goog.dom.safe.setInnerHtml(r, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Single HTML entity."), o + " ")), u = r.firstChild.nodeValue.slice(0, -1)), n[o] = u);
          });
        }, goog.string.unescapePureXmlEntities_ = function(e) {
          return e.replace(/&([^;]+);/g, function(t, n) {
            switch (n) {
              case "amp":
                return "&";
              case "lt":
                return "<";
              case "gt":
                return ">";
              case "quot":
                return '"';
              default:
                return n.charAt(0) != "#" || (n = +("0" + n.substr(1)), isNaN(n)) ? t : String.fromCharCode(n);
            }
          });
        }, goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g, goog.string.whitespaceEscape = function(e, t) {
          return goog.string.newLineToBr(e.replace(/  /g, " &#160;"), t);
        }, goog.string.preserveSpaces = function(e) {
          return e.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
        }, goog.string.stripQuotes = function(e, t) {
          for (var n = t.length, r = 0; r < n; r++) {
            var o = n == 1 ? t : t.charAt(r);
            if (e.charAt(0) == o && e.charAt(e.length - 1) == o)
              return e.substring(1, e.length - 1);
          }
          return e;
        }, goog.string.truncate = function(e, t, n) {
          return n && (e = goog.string.unescapeEntities(e)), e.length > t && (e = e.substring(0, t - 3) + "..."), n && (e = goog.string.htmlEscape(e)), e;
        }, goog.string.truncateMiddle = function(e, t, n, r) {
          if (n && (e = goog.string.unescapeEntities(e)), r && e.length > t) {
            r > t && (r = t);
            var o = e.length - r;
            e = e.substring(0, t - r) + "..." + e.substring(o);
          } else
            e.length > t && (r = Math.floor(t / 2), o = e.length - r, e = e.substring(0, r + t % 2) + "..." + e.substring(o));
          return n && (e = goog.string.htmlEscape(e)), e;
        }, goog.string.specialEscapeChars_ = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" }, goog.string.jsEscapeCache_ = { "'": "\\'" }, goog.string.quote = function(e) {
          e = String(e);
          for (var t = ['"'], n = 0; n < e.length; n++) {
            var r = e.charAt(n), o = r.charCodeAt(0);
            t[n + 1] = goog.string.specialEscapeChars_[r] || (31 < o && 127 > o ? r : goog.string.escapeChar(r));
          }
          return t.push('"'), t.join("");
        }, goog.string.escapeString = function(e) {
          for (var t = [], n = 0; n < e.length; n++)
            t[n] = goog.string.escapeChar(e.charAt(n));
          return t.join("");
        }, goog.string.escapeChar = function(e) {
          if (e in goog.string.jsEscapeCache_)
            return goog.string.jsEscapeCache_[e];
          if (e in goog.string.specialEscapeChars_)
            return goog.string.jsEscapeCache_[e] = goog.string.specialEscapeChars_[e];
          var t = e.charCodeAt(0);
          if (31 < t && 127 > t)
            var n = e;
          else
            256 > t ? (n = "\\x", (16 > t || 256 < t) && (n += "0")) : (n = "\\u", 4096 > t && (n += "0")), n += t.toString(16).toUpperCase();
          return goog.string.jsEscapeCache_[e] = n;
        }, goog.string.contains = goog.string.internal.contains, goog.string.caseInsensitiveContains = goog.string.internal.caseInsensitiveContains, goog.string.countOf = function(e, t) {
          return e && t ? e.split(t).length - 1 : 0;
        }, goog.string.removeAt = function(e, t, n) {
          var r = e;
          return 0 <= t && t < e.length && 0 < n && (r = e.substr(0, t) + e.substr(t + n, e.length - t - n)), r;
        }, goog.string.remove = function(e, t) {
          return e.replace(t, "");
        }, goog.string.removeAll = function(e, t) {
          return t = new RegExp(goog.string.regExpEscape(t), "g"), e.replace(t, "");
        }, goog.string.replaceAll = function(e, t, n) {
          return t = new RegExp(goog.string.regExpEscape(t), "g"), e.replace(t, n.replace(/\$/g, "$$$$"));
        }, goog.string.regExpEscape = function(e) {
          return String(e).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
        }, goog.string.repeat = String.prototype.repeat ? function(e, t) {
          return e.repeat(t);
        } : function(e, t) {
          return Array(t + 1).join(e);
        }, goog.string.padNumber = function(e, t, n) {
          return (n = (e = goog.isDef(n) ? e.toFixed(n) : String(e)).indexOf(".")) == -1 && (n = e.length), goog.string.repeat("0", Math.max(0, t - n)) + e;
        }, goog.string.makeSafe = function(e) {
          return e == null ? "" : String(e);
        }, goog.string.buildString = function(e) {
          return Array.prototype.join.call(arguments, "");
        }, goog.string.getRandomString = function() {
          return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
        }, goog.string.compareVersions = goog.string.internal.compareVersions, goog.string.hashCode = function(e) {
          for (var t = 0, n = 0; n < e.length; ++n)
            t = 31 * t + e.charCodeAt(n) >>> 0;
          return t;
        }, goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0, goog.string.createUniqueString = function() {
          return "goog_" + goog.string.uniqueStringCounter_++;
        }, goog.string.toNumber = function(e) {
          var t = Number(e);
          return t == 0 && goog.string.isEmptyOrWhitespace(e) ? NaN : t;
        }, goog.string.isLowerCamelCase = function(e) {
          return /^[a-z]+([A-Z][a-z]*)*$/.test(e);
        }, goog.string.isUpperCamelCase = function(e) {
          return /^([A-Z][a-z]*)+$/.test(e);
        }, goog.string.toCamelCase = function(e) {
          return String(e).replace(/\-([a-z])/g, function(t, n) {
            return n.toUpperCase();
          });
        }, goog.string.toSelectorCase = function(e) {
          return String(e).replace(/([A-Z])/g, "-$1").toLowerCase();
        }, goog.string.toTitleCase = function(e, t) {
          return t = goog.isString(t) ? goog.string.regExpEscape(t) : "\\s", e.replace(new RegExp("(^" + (t ? "|[" + t + "]+" : "") + ")([a-z])", "g"), function(n, r, o) {
            return r + o.toUpperCase();
          });
        }, goog.string.capitalize = function(e) {
          return String(e.charAt(0)).toUpperCase() + String(e.substr(1)).toLowerCase();
        }, goog.string.parseInt = function(e) {
          return isFinite(e) && (e = String(e)), goog.isString(e) ? /^\s*-?0x/i.test(e) ? parseInt(e, 16) : parseInt(e, 10) : NaN;
        }, goog.string.splitLimit = function(e, t, n) {
          e = e.split(t);
          for (var r = []; 0 < n && e.length; )
            r.push(e.shift()), n--;
          return e.length && r.push(e.join(t)), r;
        }, goog.string.lastComponent = function(e, t) {
          if (!t)
            return e;
          typeof t == "string" && (t = [t]);
          for (var n = -1, r = 0; r < t.length; r++)
            if (t[r] != "") {
              var o = e.lastIndexOf(t[r]);
              o > n && (n = o);
            }
          return n == -1 ? e : e.slice(n + 1);
        }, goog.string.editDistance = function(e, t) {
          var n = [], r = [];
          if (e == t)
            return 0;
          if (!e.length || !t.length)
            return Math.max(e.length, t.length);
          for (var o = 0; o < t.length + 1; o++)
            n[o] = o;
          for (o = 0; o < e.length; o++) {
            r[0] = o + 1;
            for (var l = 0; l < t.length; l++)
              r[l + 1] = Math.min(r[l] + 1, n[l + 1] + 1, n[l] + +(e[o] != t[l]));
            for (l = 0; l < n.length; l++)
              n[l] = r[l];
          }
          return r[t.length];
        }, goog.labs.userAgent.platform = {}, goog.labs.userAgent.platform.isAndroid = function() {
          return goog.labs.userAgent.util.matchUserAgent("Android");
        }, goog.labs.userAgent.platform.isIpod = function() {
          return goog.labs.userAgent.util.matchUserAgent("iPod");
        }, goog.labs.userAgent.platform.isIphone = function() {
          return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
        }, goog.labs.userAgent.platform.isIpad = function() {
          return goog.labs.userAgent.util.matchUserAgent("iPad");
        }, goog.labs.userAgent.platform.isIos = function() {
          return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
        }, goog.labs.userAgent.platform.isMacintosh = function() {
          return goog.labs.userAgent.util.matchUserAgent("Macintosh");
        }, goog.labs.userAgent.platform.isLinux = function() {
          return goog.labs.userAgent.util.matchUserAgent("Linux");
        }, goog.labs.userAgent.platform.isWindows = function() {
          return goog.labs.userAgent.util.matchUserAgent("Windows");
        }, goog.labs.userAgent.platform.isChromeOS = function() {
          return goog.labs.userAgent.util.matchUserAgent("CrOS");
        }, goog.labs.userAgent.platform.isChromecast = function() {
          return goog.labs.userAgent.util.matchUserAgent("CrKey");
        }, goog.labs.userAgent.platform.isKaiOS = function() {
          return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS");
        }, goog.labs.userAgent.platform.isGo2Phone = function() {
          return goog.labs.userAgent.util.matchUserAgentIgnoreCase("GAFP");
        }, goog.labs.userAgent.platform.getVersion = function() {
          var e = goog.labs.userAgent.util.getUserAgent(), t = "";
          return goog.labs.userAgent.platform.isWindows() ? t = (e = (t = /Windows (?:NT|Phone) ([0-9.]+)/).exec(e)) ? e[1] : "0.0" : goog.labs.userAgent.platform.isIos() ? t = (e = (t = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/).exec(e)) && e[1].replace(/_/g, ".") : goog.labs.userAgent.platform.isMacintosh() ? t = (e = (t = /Mac OS X ([0-9_.]+)/).exec(e)) ? e[1].replace(/_/g, ".") : "10" : goog.labs.userAgent.platform.isKaiOS() ? t = (e = (t = /(?:KaiOS)\/(\S+)/i).exec(e)) && e[1] : goog.labs.userAgent.platform.isAndroid() ? t = (e = (t = /Android\s+([^\);]+)(\)|;)/).exec(e)) && e[1] : goog.labs.userAgent.platform.isChromeOS() && (t = (e = (t = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/).exec(e)) && e[1]), t || "";
        }, goog.labs.userAgent.platform.isVersionOrHigher = function(e) {
          return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), e);
        }, goog.reflect = {}, goog.reflect.object = function(e, t) {
          return t;
        }, goog.reflect.objectProperty = function(e, t) {
          return e;
        }, goog.reflect.sinkValue = function(e) {
          return goog.reflect.sinkValue[" "](e), e;
        }, goog.reflect.sinkValue[" "] = goog.nullFunction, goog.reflect.canAccessProperty = function(e, t) {
          try {
            return goog.reflect.sinkValue(e[t]), !0;
          } catch {
          }
          return !1;
        }, goog.reflect.cache = function(e, t, n, r) {
          return r = r ? r(t) : t, Object.prototype.hasOwnProperty.call(e, r) ? e[r] : e[r] = n(t);
        }, goog.labs.userAgent.engine = {}, goog.labs.userAgent.engine.isPresto = function() {
          return goog.labs.userAgent.util.matchUserAgent("Presto");
        }, goog.labs.userAgent.engine.isTrident = function() {
          return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
        }, goog.labs.userAgent.engine.isEdge = function() {
          return goog.labs.userAgent.util.matchUserAgent("Edge");
        }, goog.labs.userAgent.engine.isWebKit = function() {
          return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
        }, goog.labs.userAgent.engine.isGecko = function() {
          return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
        }, goog.labs.userAgent.engine.getVersion = function() {
          var e = goog.labs.userAgent.util.getUserAgent();
          if (e) {
            e = goog.labs.userAgent.util.extractVersionTuples(e);
            var t, n = goog.labs.userAgent.engine.getEngineTuple_(e);
            if (n)
              return n[0] == "Gecko" ? goog.labs.userAgent.engine.getVersionForKey_(e, "Firefox") : n[1];
            if ((e = e[0]) && (t = e[2]) && (t = /Trident\/([^\s;]+)/.exec(t)))
              return t[1];
          }
          return "";
        }, goog.labs.userAgent.engine.getEngineTuple_ = function(e) {
          if (!goog.labs.userAgent.engine.isEdge())
            return e[1];
          for (var t = 0; t < e.length; t++) {
            var n = e[t];
            if (n[0] == "Edge")
              return n;
          }
        }, goog.labs.userAgent.engine.isVersionOrHigher = function(e) {
          return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), e);
        }, goog.labs.userAgent.engine.getVersionForKey_ = function(e, t) {
          return (e = goog.array.find(e, function(n) {
            return t == n[0];
          })) && e[1] || "";
        }, goog.userAgent = {}, goog.userAgent.ASSUME_IE = !1, goog.userAgent.ASSUME_EDGE = !1, goog.userAgent.ASSUME_GECKO = !1, goog.userAgent.ASSUME_WEBKIT = !1, goog.userAgent.ASSUME_MOBILE_WEBKIT = !1, goog.userAgent.ASSUME_OPERA = !1, goog.userAgent.ASSUME_ANY_VERSION = !1, goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA, goog.userAgent.getUserAgentString = function() {
          return goog.labs.userAgent.util.getUserAgent();
        }, goog.userAgent.getNavigatorTyped = function() {
          return goog.global.navigator || null;
        }, goog.userAgent.getNavigator = function() {
          return goog.userAgent.getNavigatorTyped();
        }, goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera(), goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE(), goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge(), goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE, goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko(), goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit(), goog.userAgent.isMobile_ = function() {
          return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
        }, goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_(), goog.userAgent.SAFARI = goog.userAgent.WEBKIT, goog.userAgent.determinePlatform_ = function() {
          var e = goog.userAgent.getNavigatorTyped();
          return e && e.platform || "";
        }, goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_(), goog.userAgent.ASSUME_MAC = !1, goog.userAgent.ASSUME_WINDOWS = !1, goog.userAgent.ASSUME_LINUX = !1, goog.userAgent.ASSUME_X11 = !1, goog.userAgent.ASSUME_ANDROID = !1, goog.userAgent.ASSUME_IPHONE = !1, goog.userAgent.ASSUME_IPAD = !1, goog.userAgent.ASSUME_IPOD = !1, goog.userAgent.ASSUME_KAIOS = !1, goog.userAgent.ASSUME_GO2PHONE = !1, goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD, goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh(), goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows(), goog.userAgent.isLegacyLinux_ = function() {
          return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
        }, goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_(), goog.userAgent.isX11_ = function() {
          var e = goog.userAgent.getNavigatorTyped();
          return !!e && goog.string.contains(e.appVersion || "", "X11");
        }, goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_(), goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid(), goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone(), goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod(), goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos(), goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS(), goog.userAgent.GO2PHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_GO2PHONE : goog.labs.userAgent.platform.isGo2Phone(), goog.userAgent.determineVersion_ = function() {
          var e = "", t = goog.userAgent.getVersionRegexResult_();
          return t && (e = t ? t[1] : ""), goog.userAgent.IE && (t = goog.userAgent.getDocumentMode_()) != null && t > parseFloat(e) ? String(t) : e;
        }, goog.userAgent.getVersionRegexResult_ = function() {
          var e = goog.userAgent.getUserAgentString();
          return goog.userAgent.GECKO ? /rv:([^\);]+)(\)|;)/.exec(e) : goog.userAgent.EDGE ? /Edge\/([\d\.]+)/.exec(e) : goog.userAgent.IE ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(e) : goog.userAgent.WEBKIT ? /WebKit\/(\S+)/.exec(e) : goog.userAgent.OPERA ? /(?:Version)[ \/]?(\S+)/.exec(e) : void 0;
        }, goog.userAgent.getDocumentMode_ = function() {
          var e = goog.global.document;
          return e ? e.documentMode : void 0;
        }, goog.userAgent.VERSION = goog.userAgent.determineVersion_(), goog.userAgent.compare = function(e, t) {
          return goog.string.compareVersions(e, t);
        }, goog.userAgent.isVersionOrHigherCache_ = {}, goog.userAgent.isVersionOrHigher = function(e) {
          return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, e, function() {
            return 0 <= goog.string.compareVersions(goog.userAgent.VERSION, e);
          });
        }, goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher, goog.userAgent.isDocumentModeOrHigher = function(e) {
          return Number(goog.userAgent.DOCUMENT_MODE) >= e;
        }, goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher, goog.userAgent.DOCUMENT_MODE = function() {
          if (goog.global.document && goog.userAgent.IE)
            return goog.userAgent.getDocumentMode_();
        }(), goog.userAgent.product = {}, goog.userAgent.product.ASSUME_FIREFOX = !1, goog.userAgent.product.ASSUME_IPHONE = !1, goog.userAgent.product.ASSUME_IPAD = !1, goog.userAgent.product.ASSUME_ANDROID = !1, goog.userAgent.product.ASSUME_CHROME = !1, goog.userAgent.product.ASSUME_SAFARI = !1, goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI, goog.userAgent.product.OPERA = goog.userAgent.OPERA, goog.userAgent.product.IE = goog.userAgent.IE, goog.userAgent.product.EDGE = goog.userAgent.EDGE, goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox(), goog.userAgent.product.isIphoneOrIpod_ = function() {
          return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
        }, goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_(), goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad(), goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser(), goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome(), goog.userAgent.product.isSafariDesktop_ = function() {
          return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
        }, goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_(), goog.crypt.base64 = {}, goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "+/=", goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "-_.", goog.crypt.base64.Alphabet = { DEFAULT: 0, NO_PADDING: 1, WEBSAFE: 2, WEBSAFE_DOT_PADDING: 3, WEBSAFE_NO_PADDING: 4 }, goog.crypt.base64.paddingChars_ = "=.", goog.crypt.base64.isPadding_ = function(e) {
          return goog.string.contains(goog.crypt.base64.paddingChars_, e);
        }, goog.crypt.base64.byteToCharMaps_ = {}, goog.crypt.base64.charToByteMap_ = null, goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA, goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || typeof goog.global.btoa == "function", goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && typeof goog.global.atob == "function", goog.crypt.base64.encodeByteArray = function(e, t) {
          goog.asserts.assert(goog.isArrayLike(e), "encodeByteArray takes an array as a parameter"), t === void 0 && (t = goog.crypt.base64.Alphabet.DEFAULT), goog.crypt.base64.init_(), t = goog.crypt.base64.byteToCharMaps_[t];
          for (var n = [], r = 0; r < e.length; r += 3) {
            var o = e[r], l = r + 1 < e.length, u = l ? e[r + 1] : 0, s = r + 2 < e.length, g = s ? e[r + 2] : 0, c = o >> 2;
            o = (3 & o) << 4 | u >> 4, u = (15 & u) << 2 | g >> 6, g &= 63, s || (g = 64, l || (u = 64)), n.push(t[c], t[o], t[u] || "", t[g] || "");
          }
          return n.join("");
        }, goog.crypt.base64.encodeString = function(e, t) {
          return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !t ? goog.global.btoa(e) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(e), t);
        }, goog.crypt.base64.decodeString = function(e, t) {
          if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !t)
            return goog.global.atob(e);
          var n = "";
          return goog.crypt.base64.decodeStringInternal_(e, function(r) {
            n += String.fromCharCode(r);
          }), n;
        }, goog.crypt.base64.decodeStringToByteArray = function(e, t) {
          var n = [];
          return goog.crypt.base64.decodeStringInternal_(e, function(r) {
            n.push(r);
          }), n;
        }, goog.crypt.base64.decodeStringToUint8Array = function(e) {
          goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
          var t = e.length, n = 3 * t / 4;
          n % 3 ? n = Math.floor(n) : goog.crypt.base64.isPadding_(e[t - 1]) && (n = goog.crypt.base64.isPadding_(e[t - 2]) ? n - 2 : n - 1);
          var r = new Uint8Array(n), o = 0;
          return goog.crypt.base64.decodeStringInternal_(e, function(l) {
            r[o++] = l;
          }), r.subarray(0, o);
        }, goog.crypt.base64.decodeStringInternal_ = function(e, t) {
          function n(g) {
            for (; r < e.length; ) {
              var c = e.charAt(r++), d = goog.crypt.base64.charToByteMap_[c];
              if (d != null)
                return d;
              if (!goog.string.isEmptyOrWhitespace(c))
                throw Error("Unknown base64 encoding at char: " + c);
            }
            return g;
          }
          goog.crypt.base64.init_();
          for (var r = 0; ; ) {
            var o = n(-1), l = n(0), u = n(64), s = n(64);
            if (s === 64 && o === -1)
              break;
            t(o << 2 | l >> 4), u != 64 && (t(l << 4 & 240 | u >> 2), s != 64 && t(u << 6 & 192 | s));
          }
        }, goog.crypt.base64.init_ = function() {
          if (!goog.crypt.base64.charToByteMap_) {
            goog.crypt.base64.charToByteMap_ = {};
            for (var e = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""), t = ["+/=", "+/", "-_=", "-_.", "-_"], n = 0; 5 > n; n++) {
              var r = e.concat(t[n].split(""));
              goog.crypt.base64.byteToCharMaps_[n] = r;
              for (var o = 0; o < r.length; o++) {
                var l = r[o], u = goog.crypt.base64.charToByteMap_[l];
                u === void 0 ? goog.crypt.base64.charToByteMap_[l] = o : goog.asserts.assert(u === o);
              }
            }
          }
        }, jspb.utils = {}, jspb.utils.split64Low = 0, jspb.utils.split64High = 0, jspb.utils.splitUint64 = function(e) {
          var t = e >>> 0;
          e = Math.floor((e - t) / jspb.BinaryConstants.TWO_TO_32) >>> 0, jspb.utils.split64Low = t, jspb.utils.split64High = e;
        }, jspb.utils.splitInt64 = function(e) {
          var t = 0 > e, n = (e = Math.abs(e)) >>> 0;
          e = Math.floor((e - n) / jspb.BinaryConstants.TWO_TO_32), e >>>= 0, t && (e = ~e >>> 0, 4294967295 < (n = 1 + (~n >>> 0)) && (n = 0, 4294967295 < ++e && (e = 0))), jspb.utils.split64Low = n, jspb.utils.split64High = e;
        }, jspb.utils.splitZigzag64 = function(e) {
          var t = 0 > e;
          e = 2 * Math.abs(e), jspb.utils.splitUint64(e), e = jspb.utils.split64Low;
          var n = jspb.utils.split64High;
          t && (e == 0 ? n == 0 ? n = e = 4294967295 : (n--, e = 4294967295) : e--), jspb.utils.split64Low = e, jspb.utils.split64High = n;
        }, jspb.utils.splitFloat32 = function(e) {
          var t = 0 > e ? 1 : 0;
          if ((e = t ? -e : e) === 0)
            0 < 1 / e ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648);
          else if (isNaN(e))
            jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647;
          else if (e > jspb.BinaryConstants.FLOAT32_MAX)
            jspb.utils.split64High = 0, jspb.utils.split64Low = (t << 31 | 2139095040) >>> 0;
          else if (e < jspb.BinaryConstants.FLOAT32_MIN)
            e = Math.round(e / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (t << 31 | e) >>> 0;
          else {
            var n = Math.floor(Math.log(e) / Math.LN2);
            e *= Math.pow(2, -n), e = 8388607 & Math.round(e * jspb.BinaryConstants.TWO_TO_23), jspb.utils.split64High = 0, jspb.utils.split64Low = (t << 31 | n + 127 << 23 | e) >>> 0;
          }
        }, jspb.utils.splitFloat64 = function(e) {
          var t = 0 > e ? 1 : 0;
          if ((e = t ? -e : e) === 0)
            jspb.utils.split64High = 0 < 1 / e ? 0 : 2147483648, jspb.utils.split64Low = 0;
          else if (isNaN(e))
            jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;
          else if (e > jspb.BinaryConstants.FLOAT64_MAX)
            jspb.utils.split64High = (t << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;
          else if (e < jspb.BinaryConstants.FLOAT64_MIN) {
            var n = e / Math.pow(2, -1074);
            e = n / jspb.BinaryConstants.TWO_TO_32, jspb.utils.split64High = (t << 31 | e) >>> 0, jspb.utils.split64Low = n >>> 0;
          } else {
            var r = 0;
            if (2 <= (n = e))
              for (; 2 <= n && 1023 > r; )
                r++, n /= 2;
            else
              for (; 1 > n && -1022 < r; )
                n *= 2, r--;
            e = (n = e * Math.pow(2, -r)) * jspb.BinaryConstants.TWO_TO_20 & 1048575, n = n * jspb.BinaryConstants.TWO_TO_52 >>> 0, jspb.utils.split64High = (t << 31 | r + 1023 << 20 | e) >>> 0, jspb.utils.split64Low = n;
          }
        }, jspb.utils.splitHash64 = function(e) {
          var t = e.charCodeAt(0), n = e.charCodeAt(1), r = e.charCodeAt(2), o = e.charCodeAt(3), l = e.charCodeAt(4), u = e.charCodeAt(5), s = e.charCodeAt(6);
          e = e.charCodeAt(7), jspb.utils.split64Low = t + (n << 8) + (r << 16) + (o << 24) >>> 0, jspb.utils.split64High = l + (u << 8) + (s << 16) + (e << 24) >>> 0;
        }, jspb.utils.joinUint64 = function(e, t) {
          return t * jspb.BinaryConstants.TWO_TO_32 + (e >>> 0);
        }, jspb.utils.joinInt64 = function(e, t) {
          var n = 2147483648 & t;
          return n && (t = ~t >>> 0, (e = 1 + ~e >>> 0) == 0 && (t = t + 1 >>> 0)), e = jspb.utils.joinUint64(e, t), n ? -e : e;
        }, jspb.utils.toZigzag64 = function(e, t, n) {
          var r = t >> 31;
          return n(e << 1 ^ r, (t << 1 | e >>> 31) ^ r);
        }, jspb.utils.joinZigzag64 = function(e, t) {
          return jspb.utils.fromZigzag64(e, t, jspb.utils.joinInt64);
        }, jspb.utils.fromZigzag64 = function(e, t, n) {
          var r = -(1 & e);
          return n((e >>> 1 | t << 31) ^ r, t >>> 1 ^ r);
        }, jspb.utils.joinFloat32 = function(e, t) {
          t = 2 * (e >> 31) + 1;
          var n = e >>> 23 & 255;
          return e &= 8388607, n == 255 ? e ? NaN : 1 / 0 * t : n == 0 ? t * Math.pow(2, -149) * e : t * Math.pow(2, n - 150) * (e + Math.pow(2, 23));
        }, jspb.utils.joinFloat64 = function(e, t) {
          var n = 2 * (t >> 31) + 1, r = t >>> 20 & 2047;
          return e = jspb.BinaryConstants.TWO_TO_32 * (1048575 & t) + e, r == 2047 ? e ? NaN : 1 / 0 * n : r == 0 ? n * Math.pow(2, -1074) * e : n * Math.pow(2, r - 1075) * (e + jspb.BinaryConstants.TWO_TO_52);
        }, jspb.utils.joinHash64 = function(e, t) {
          return String.fromCharCode(e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255, t >>> 0 & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255);
        }, jspb.utils.DIGITS = "0123456789abcdef".split(""), jspb.utils.ZERO_CHAR_CODE_ = 48, jspb.utils.A_CHAR_CODE_ = 97, jspb.utils.joinUnsignedDecimalString = function(e, t) {
          function n(o, l) {
            return o = o ? String(o) : "", l ? "0000000".slice(o.length) + o : o;
          }
          if (2097151 >= t)
            return "" + (jspb.BinaryConstants.TWO_TO_32 * t + e);
          var r = (e >>> 24 | t << 8) >>> 0 & 16777215;
          return e = (16777215 & e) + 6777216 * r + 6710656 * (t = t >> 16 & 65535), r += 8147497 * t, t *= 2, 1e7 <= e && (r += Math.floor(e / 1e7), e %= 1e7), 1e7 <= r && (t += Math.floor(r / 1e7), r %= 1e7), n(t, 0) + n(r, t) + n(e, 1);
        }, jspb.utils.joinSignedDecimalString = function(e, t) {
          var n = 2147483648 & t;
          return n && (t = ~t + ((e = 1 + ~e >>> 0) == 0 ? 1 : 0) >>> 0), e = jspb.utils.joinUnsignedDecimalString(e, t), n ? "-" + e : e;
        }, jspb.utils.hash64ToDecimalString = function(e, t) {
          jspb.utils.splitHash64(e), e = jspb.utils.split64Low;
          var n = jspb.utils.split64High;
          return t ? jspb.utils.joinSignedDecimalString(e, n) : jspb.utils.joinUnsignedDecimalString(e, n);
        }, jspb.utils.hash64ArrayToDecimalStrings = function(e, t) {
          for (var n = Array(e.length), r = 0; r < e.length; r++)
            n[r] = jspb.utils.hash64ToDecimalString(e[r], t);
          return n;
        }, jspb.utils.decimalStringToHash64 = function(e) {
          function t(l, u) {
            for (var s = 0; 8 > s && (l !== 1 || 0 < u); s++)
              u = l * r[s] + u, r[s] = 255 & u, u >>>= 8;
          }
          goog.asserts.assert(0 < e.length);
          var n = !1;
          e[0] === "-" && (n = !0, e = e.slice(1));
          for (var r = [0, 0, 0, 0, 0, 0, 0, 0], o = 0; o < e.length; o++)
            t(10, e.charCodeAt(o) - jspb.utils.ZERO_CHAR_CODE_);
          return n && (function() {
            for (var l = 0; 8 > l; l++)
              r[l] = 255 & ~r[l];
          }(), t(1, 1)), goog.crypt.byteArrayToString(r);
        }, jspb.utils.splitDecimalString = function(e) {
          jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(e));
        }, jspb.utils.toHexDigit_ = function(e) {
          return String.fromCharCode(10 > e ? jspb.utils.ZERO_CHAR_CODE_ + e : jspb.utils.A_CHAR_CODE_ - 10 + e);
        }, jspb.utils.fromHexCharCode_ = function(e) {
          return e >= jspb.utils.A_CHAR_CODE_ ? e - jspb.utils.A_CHAR_CODE_ + 10 : e - jspb.utils.ZERO_CHAR_CODE_;
        }, jspb.utils.hash64ToHexString = function(e) {
          var t = Array(18);
          t[0] = "0", t[1] = "x";
          for (var n = 0; 8 > n; n++) {
            var r = e.charCodeAt(7 - n);
            t[2 * n + 2] = jspb.utils.toHexDigit_(r >> 4), t[2 * n + 3] = jspb.utils.toHexDigit_(15 & r);
          }
          return t.join("");
        }, jspb.utils.hexStringToHash64 = function(e) {
          e = e.toLowerCase(), goog.asserts.assert(e.length == 18), goog.asserts.assert(e[0] == "0"), goog.asserts.assert(e[1] == "x");
          for (var t = "", n = 0; 8 > n; n++) {
            var r = jspb.utils.fromHexCharCode_(e.charCodeAt(2 * n + 2)), o = jspb.utils.fromHexCharCode_(e.charCodeAt(2 * n + 3));
            t = String.fromCharCode(16 * r + o) + t;
          }
          return t;
        }, jspb.utils.hash64ToNumber = function(e, t) {
          jspb.utils.splitHash64(e), e = jspb.utils.split64Low;
          var n = jspb.utils.split64High;
          return t ? jspb.utils.joinInt64(e, n) : jspb.utils.joinUint64(e, n);
        }, jspb.utils.numberToHash64 = function(e) {
          return jspb.utils.splitInt64(e), jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.utils.countVarints = function(e, t, n) {
          for (var r = 0, o = t; o < n; o++)
            r += e[o] >> 7;
          return n - t - r;
        }, jspb.utils.countVarintFields = function(e, t, n, r) {
          var o = 0;
          if (128 > (r = 8 * r + jspb.BinaryConstants.WireType.VARINT))
            for (; t < n && e[t++] == r; )
              for (o++; ; ) {
                var l = e[t++];
                if (!(128 & l))
                  break;
              }
          else
            for (; t < n; ) {
              for (l = r; 128 < l; ) {
                if (e[t] != (127 & l | 128))
                  return o;
                t++, l >>= 7;
              }
              if (e[t++] != l)
                break;
              for (o++; 128 & (l = e[t++]); )
                ;
            }
          return o;
        }, jspb.utils.countFixedFields_ = function(e, t, n, r, o) {
          var l = 0;
          if (128 > r)
            for (; t < n && e[t++] == r; )
              l++, t += o;
          else
            for (; t < n; ) {
              for (var u = r; 128 < u; ) {
                if (e[t++] != (127 & u | 128))
                  return l;
                u >>= 7;
              }
              if (e[t++] != u)
                break;
              l++, t += o;
            }
          return l;
        }, jspb.utils.countFixed32Fields = function(e, t, n, r) {
          return jspb.utils.countFixedFields_(e, t, n, 8 * r + jspb.BinaryConstants.WireType.FIXED32, 4);
        }, jspb.utils.countFixed64Fields = function(e, t, n, r) {
          return jspb.utils.countFixedFields_(e, t, n, 8 * r + jspb.BinaryConstants.WireType.FIXED64, 8);
        }, jspb.utils.countDelimitedFields = function(e, t, n, r) {
          var o = 0;
          for (r = 8 * r + jspb.BinaryConstants.WireType.DELIMITED; t < n; ) {
            for (var l = r; 128 < l; ) {
              if (e[t++] != (127 & l | 128))
                return o;
              l >>= 7;
            }
            if (e[t++] != l)
              break;
            o++;
            for (var u = 0, s = 1; u += (127 & (l = e[t++])) * s, s *= 128, (128 & l) != 0; )
              ;
            t += u;
          }
          return o;
        }, jspb.utils.debugBytesToTextFormat = function(e) {
          var t = '"';
          if (e) {
            e = jspb.utils.byteSourceToUint8Array(e);
            for (var n = 0; n < e.length; n++)
              t += "\\x", 16 > e[n] && (t += "0"), t += e[n].toString(16);
          }
          return t + '"';
        }, jspb.utils.debugScalarToTextFormat = function(e) {
          return typeof e == "string" ? goog.string.quote(e) : e.toString();
        }, jspb.utils.stringToByteArray = function(e) {
          for (var t = new Uint8Array(e.length), n = 0; n < e.length; n++) {
            var r = e.charCodeAt(n);
            if (255 < r)
              throw Error("Conversion error: string contains codepoint outside of byte range");
            t[n] = r;
          }
          return t;
        }, jspb.utils.byteSourceToUint8Array = function(e) {
          return e.constructor === Uint8Array ? e : e.constructor === ArrayBuffer || Buffer !== void 0 && e.constructor === Buffer || e.constructor === Array ? new Uint8Array(e) : e.constructor === String ? goog.crypt.base64.decodeStringToUint8Array(e) : (goog.asserts.fail("Type not convertible to Uint8Array."), new Uint8Array(0));
        }, jspb.BinaryDecoder = function(e, t, n) {
          this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1, e && this.setBlock(e, t, n);
        }, jspb.BinaryDecoder.instanceCache_ = [], jspb.BinaryDecoder.alloc = function(e, t, n) {
          if (jspb.BinaryDecoder.instanceCache_.length) {
            var r = jspb.BinaryDecoder.instanceCache_.pop();
            return e && r.setBlock(e, t, n), r;
          }
          return new jspb.BinaryDecoder(e, t, n);
        }, jspb.BinaryDecoder.prototype.free = function() {
          this.clear(), 100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
        }, jspb.BinaryDecoder.prototype.clone = function() {
          return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
        }, jspb.BinaryDecoder.prototype.clear = function() {
          this.bytes_ = null, this.cursor_ = this.end_ = this.start_ = 0, this.error_ = !1;
        }, jspb.BinaryDecoder.prototype.getBuffer = function() {
          return this.bytes_;
        }, jspb.BinaryDecoder.prototype.setBlock = function(e, t, n) {
          this.bytes_ = jspb.utils.byteSourceToUint8Array(e), this.start_ = t !== void 0 ? t : 0, this.end_ = n !== void 0 ? this.start_ + n : this.bytes_.length, this.cursor_ = this.start_;
        }, jspb.BinaryDecoder.prototype.getEnd = function() {
          return this.end_;
        }, jspb.BinaryDecoder.prototype.setEnd = function(e) {
          this.end_ = e;
        }, jspb.BinaryDecoder.prototype.reset = function() {
          this.cursor_ = this.start_;
        }, jspb.BinaryDecoder.prototype.getCursor = function() {
          return this.cursor_;
        }, jspb.BinaryDecoder.prototype.setCursor = function(e) {
          this.cursor_ = e;
        }, jspb.BinaryDecoder.prototype.advance = function(e) {
          this.cursor_ += e, goog.asserts.assert(this.cursor_ <= this.end_);
        }, jspb.BinaryDecoder.prototype.atEnd = function() {
          return this.cursor_ == this.end_;
        }, jspb.BinaryDecoder.prototype.pastEnd = function() {
          return this.cursor_ > this.end_;
        }, jspb.BinaryDecoder.prototype.getError = function() {
          return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
        }, jspb.BinaryDecoder.prototype.readSplitVarint64 = function(e) {
          for (var t = 128, n = 0, r = 0, o = 0; 4 > o && 128 <= t; o++)
            n |= (127 & (t = this.bytes_[this.cursor_++])) << 7 * o;
          if (128 <= t && (n |= (127 & (t = this.bytes_[this.cursor_++])) << 28, r |= (127 & t) >> 4), 128 <= t)
            for (o = 0; 5 > o && 128 <= t; o++)
              r |= (127 & (t = this.bytes_[this.cursor_++])) << 7 * o + 3;
          if (128 > t)
            return e(n >>> 0, r >>> 0);
          goog.asserts.fail("Failed to read varint, encoding is invalid."), this.error_ = !0;
        }, jspb.BinaryDecoder.prototype.readSplitZigzagVarint64 = function(e) {
          return this.readSplitVarint64(function(t, n) {
            return jspb.utils.fromZigzag64(t, n, e);
          });
        }, jspb.BinaryDecoder.prototype.readSplitFixed64 = function(e) {
          var t = this.bytes_, n = this.cursor_;
          this.cursor_ += 8;
          for (var r = 0, o = 0, l = n + 7; l >= n; l--)
            r = r << 8 | t[l], o = o << 8 | t[l + 4];
          return e(r, o);
        }, jspb.BinaryDecoder.prototype.skipVarint = function() {
          for (; 128 & this.bytes_[this.cursor_]; )
            this.cursor_++;
          this.cursor_++;
        }, jspb.BinaryDecoder.prototype.unskipVarint = function(e) {
          for (; 128 < e; )
            this.cursor_--, e >>>= 7;
          this.cursor_--;
        }, jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {
          var e = this.bytes_, t = e[this.cursor_ + 0], n = 127 & t;
          return 128 > t ? (this.cursor_ += 1, goog.asserts.assert(this.cursor_ <= this.end_), n) : (n |= (127 & (t = e[this.cursor_ + 1])) << 7, 128 > t ? (this.cursor_ += 2, goog.asserts.assert(this.cursor_ <= this.end_), n) : (n |= (127 & (t = e[this.cursor_ + 2])) << 14, 128 > t ? (this.cursor_ += 3, goog.asserts.assert(this.cursor_ <= this.end_), n) : (n |= (127 & (t = e[this.cursor_ + 3])) << 21, 128 > t ? (this.cursor_ += 4, goog.asserts.assert(this.cursor_ <= this.end_), n) : (n |= (15 & (t = e[this.cursor_ + 4])) << 28, 128 > t ? (this.cursor_ += 5, goog.asserts.assert(this.cursor_ <= this.end_), n >>> 0) : (this.cursor_ += 5, 128 <= e[this.cursor_++] && 128 <= e[this.cursor_++] && 128 <= e[this.cursor_++] && 128 <= e[this.cursor_++] && 128 <= e[this.cursor_++] && goog.asserts.assert(!1), goog.asserts.assert(this.cursor_ <= this.end_), n)))));
        }, jspb.BinaryDecoder.prototype.readSignedVarint32 = jspb.BinaryDecoder.prototype.readUnsignedVarint32, jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {
          return this.readUnsignedVarint32().toString();
        }, jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {
          return this.readSignedVarint32().toString();
        }, jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {
          var e = this.readUnsignedVarint32();
          return e >>> 1 ^ -(1 & e);
        }, jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {
          return this.readSplitVarint64(jspb.utils.joinUint64);
        }, jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {
          return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString);
        }, jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {
          return this.readSplitVarint64(jspb.utils.joinInt64);
        }, jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {
          return this.readSplitVarint64(jspb.utils.joinSignedDecimalString);
        }, jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {
          return this.readSplitVarint64(jspb.utils.joinZigzag64);
        }, jspb.BinaryDecoder.prototype.readZigzagVarintHash64 = function() {
          return this.readSplitZigzagVarint64(jspb.utils.joinHash64);
        }, jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {
          return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString);
        }, jspb.BinaryDecoder.prototype.readUint8 = function() {
          var e = this.bytes_[this.cursor_ + 0];
          return this.cursor_ += 1, goog.asserts.assert(this.cursor_ <= this.end_), e;
        }, jspb.BinaryDecoder.prototype.readUint16 = function() {
          var e = this.bytes_[this.cursor_ + 0], t = this.bytes_[this.cursor_ + 1];
          return this.cursor_ += 2, goog.asserts.assert(this.cursor_ <= this.end_), e << 0 | t << 8;
        }, jspb.BinaryDecoder.prototype.readUint32 = function() {
          var e = this.bytes_[this.cursor_ + 0], t = this.bytes_[this.cursor_ + 1], n = this.bytes_[this.cursor_ + 2], r = this.bytes_[this.cursor_ + 3];
          return this.cursor_ += 4, goog.asserts.assert(this.cursor_ <= this.end_), (e << 0 | t << 8 | n << 16 | r << 24) >>> 0;
        }, jspb.BinaryDecoder.prototype.readUint64 = function() {
          var e = this.readUint32(), t = this.readUint32();
          return jspb.utils.joinUint64(e, t);
        }, jspb.BinaryDecoder.prototype.readUint64String = function() {
          var e = this.readUint32(), t = this.readUint32();
          return jspb.utils.joinUnsignedDecimalString(e, t);
        }, jspb.BinaryDecoder.prototype.readInt8 = function() {
          var e = this.bytes_[this.cursor_ + 0];
          return this.cursor_ += 1, goog.asserts.assert(this.cursor_ <= this.end_), e << 24 >> 24;
        }, jspb.BinaryDecoder.prototype.readInt16 = function() {
          var e = this.bytes_[this.cursor_ + 0], t = this.bytes_[this.cursor_ + 1];
          return this.cursor_ += 2, goog.asserts.assert(this.cursor_ <= this.end_), (e << 0 | t << 8) << 16 >> 16;
        }, jspb.BinaryDecoder.prototype.readInt32 = function() {
          var e = this.bytes_[this.cursor_ + 0], t = this.bytes_[this.cursor_ + 1], n = this.bytes_[this.cursor_ + 2], r = this.bytes_[this.cursor_ + 3];
          return this.cursor_ += 4, goog.asserts.assert(this.cursor_ <= this.end_), e << 0 | t << 8 | n << 16 | r << 24;
        }, jspb.BinaryDecoder.prototype.readInt64 = function() {
          var e = this.readUint32(), t = this.readUint32();
          return jspb.utils.joinInt64(e, t);
        }, jspb.BinaryDecoder.prototype.readInt64String = function() {
          var e = this.readUint32(), t = this.readUint32();
          return jspb.utils.joinSignedDecimalString(e, t);
        }, jspb.BinaryDecoder.prototype.readFloat = function() {
          var e = this.readUint32();
          return jspb.utils.joinFloat32(e, 0);
        }, jspb.BinaryDecoder.prototype.readDouble = function() {
          var e = this.readUint32(), t = this.readUint32();
          return jspb.utils.joinFloat64(e, t);
        }, jspb.BinaryDecoder.prototype.readBool = function() {
          return !!this.bytes_[this.cursor_++];
        }, jspb.BinaryDecoder.prototype.readEnum = function() {
          return this.readSignedVarint32();
        }, jspb.BinaryDecoder.prototype.readString = function(e) {
          var t = this.bytes_, n = this.cursor_;
          e = n + e;
          for (var r = [], o = ""; n < e; ) {
            var l = t[n++];
            if (128 > l)
              r.push(l);
            else {
              if (192 > l)
                continue;
              if (224 > l) {
                var u = t[n++];
                r.push((31 & l) << 6 | 63 & u);
              } else if (240 > l) {
                u = t[n++];
                var s = t[n++];
                r.push((15 & l) << 12 | (63 & u) << 6 | 63 & s);
              } else
                248 > l && (l = (7 & l) << 18 | (63 & (u = t[n++])) << 12 | (63 & (s = t[n++])) << 6 | 63 & t[n++], l -= 65536, r.push(55296 + (l >> 10 & 1023), 56320 + (1023 & l)));
            }
            8192 <= r.length && (o += String.fromCharCode.apply(null, r), r.length = 0);
          }
          return o += goog.crypt.byteArrayToString(r), this.cursor_ = n, o;
        }, jspb.BinaryDecoder.prototype.readStringWithLength = function() {
          var e = this.readUnsignedVarint32();
          return this.readString(e);
        }, jspb.BinaryDecoder.prototype.readBytes = function(e) {
          if (0 > e || this.cursor_ + e > this.bytes_.length)
            return this.error_ = !0, goog.asserts.fail("Invalid byte length!"), new Uint8Array(0);
          var t = this.bytes_.subarray(this.cursor_, this.cursor_ + e);
          return this.cursor_ += e, goog.asserts.assert(this.cursor_ <= this.end_), t;
        }, jspb.BinaryDecoder.prototype.readVarintHash64 = function() {
          return this.readSplitVarint64(jspb.utils.joinHash64);
        }, jspb.BinaryDecoder.prototype.readFixedHash64 = function() {
          var e = this.bytes_, t = this.cursor_, n = e[t + 0], r = e[t + 1], o = e[t + 2], l = e[t + 3], u = e[t + 4], s = e[t + 5], g = e[t + 6];
          return e = e[t + 7], this.cursor_ += 8, String.fromCharCode(n, r, o, l, u, s, g, e);
        }, jspb.BinaryReader = function(e, t, n) {
          this.decoder_ = jspb.BinaryDecoder.alloc(e, t, n), this.fieldCursor_ = this.decoder_.getCursor(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null;
        }, jspb.BinaryReader.instanceCache_ = [], jspb.BinaryReader.alloc = function(e, t, n) {
          if (jspb.BinaryReader.instanceCache_.length) {
            var r = jspb.BinaryReader.instanceCache_.pop();
            return e && r.decoder_.setBlock(e, t, n), r;
          }
          return new jspb.BinaryReader(e, t, n);
        }, jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc, jspb.BinaryReader.prototype.free = function() {
          this.decoder_.clear(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID, this.error_ = !1, this.readCallbacks_ = null, 100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
        }, jspb.BinaryReader.prototype.getFieldCursor = function() {
          return this.fieldCursor_;
        }, jspb.BinaryReader.prototype.getCursor = function() {
          return this.decoder_.getCursor();
        }, jspb.BinaryReader.prototype.getBuffer = function() {
          return this.decoder_.getBuffer();
        }, jspb.BinaryReader.prototype.getFieldNumber = function() {
          return this.nextField_;
        }, jspb.BinaryReader.prototype.getWireType = function() {
          return this.nextWireType_;
        }, jspb.BinaryReader.prototype.isDelimited = function() {
          return this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED;
        }, jspb.BinaryReader.prototype.isEndGroup = function() {
          return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
        }, jspb.BinaryReader.prototype.getError = function() {
          return this.error_ || this.decoder_.getError();
        }, jspb.BinaryReader.prototype.setBlock = function(e, t, n) {
          this.decoder_.setBlock(e, t, n), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
        }, jspb.BinaryReader.prototype.reset = function() {
          this.decoder_.reset(), this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER, this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
        }, jspb.BinaryReader.prototype.advance = function(e) {
          this.decoder_.advance(e);
        }, jspb.BinaryReader.prototype.nextField = function() {
          if (this.decoder_.atEnd())
            return !1;
          if (this.getError())
            return goog.asserts.fail("Decoder hit an error"), !1;
          this.fieldCursor_ = this.decoder_.getCursor();
          var e = this.decoder_.readUnsignedVarint32(), t = e >>> 3;
          return (e &= 7) != jspb.BinaryConstants.WireType.VARINT && e != jspb.BinaryConstants.WireType.FIXED32 && e != jspb.BinaryConstants.WireType.FIXED64 && e != jspb.BinaryConstants.WireType.DELIMITED && e != jspb.BinaryConstants.WireType.START_GROUP && e != jspb.BinaryConstants.WireType.END_GROUP ? (goog.asserts.fail("Invalid wire type: %s (at position %s)", e, this.fieldCursor_), this.error_ = !0, !1) : (this.nextField_ = t, this.nextWireType_ = e, !0);
        }, jspb.BinaryReader.prototype.unskipHeader = function() {
          this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
        }, jspb.BinaryReader.prototype.skipMatchingFields = function() {
          var e = this.nextField_;
          for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == e; )
            this.skipField();
          this.decoder_.atEnd() || this.unskipHeader();
        }, jspb.BinaryReader.prototype.skipVarintField = function() {
          this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (goog.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
        }, jspb.BinaryReader.prototype.skipDelimitedField = function() {
          if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED)
            goog.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();
          else {
            var e = this.decoder_.readUnsignedVarint32();
            this.decoder_.advance(e);
          }
        }, jspb.BinaryReader.prototype.skipFixed32Field = function() {
          this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (goog.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
        }, jspb.BinaryReader.prototype.skipFixed64Field = function() {
          this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (goog.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
        }, jspb.BinaryReader.prototype.skipGroup = function() {
          for (var e = this.nextField_; ; ) {
            if (!this.nextField()) {
              goog.asserts.fail("Unmatched start-group tag: stream EOF"), this.error_ = !0;
              break;
            }
            if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP) {
              this.nextField_ != e && (goog.asserts.fail("Unmatched end-group tag"), this.error_ = !0);
              break;
            }
            this.skipField();
          }
        }, jspb.BinaryReader.prototype.skipField = function() {
          switch (this.nextWireType_) {
            case jspb.BinaryConstants.WireType.VARINT:
              this.skipVarintField();
              break;
            case jspb.BinaryConstants.WireType.FIXED64:
              this.skipFixed64Field();
              break;
            case jspb.BinaryConstants.WireType.DELIMITED:
              this.skipDelimitedField();
              break;
            case jspb.BinaryConstants.WireType.FIXED32:
              this.skipFixed32Field();
              break;
            case jspb.BinaryConstants.WireType.START_GROUP:
              this.skipGroup();
              break;
            default:
              goog.asserts.fail("Invalid wire encoding for field.");
          }
        }, jspb.BinaryReader.prototype.registerReadCallback = function(e, t) {
          this.readCallbacks_ === null && (this.readCallbacks_ = {}), goog.asserts.assert(!this.readCallbacks_[e]), this.readCallbacks_[e] = t;
        }, jspb.BinaryReader.prototype.runReadCallback = function(e) {
          return goog.asserts.assert(this.readCallbacks_ !== null), e = this.readCallbacks_[e], goog.asserts.assert(e), e(this);
        }, jspb.BinaryReader.prototype.readAny = function(e) {
          this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(e);
          var t = jspb.BinaryConstants.FieldType;
          switch (e) {
            case t.DOUBLE:
              return this.readDouble();
            case t.FLOAT:
              return this.readFloat();
            case t.INT64:
              return this.readInt64();
            case t.UINT64:
              return this.readUint64();
            case t.INT32:
              return this.readInt32();
            case t.FIXED64:
              return this.readFixed64();
            case t.FIXED32:
              return this.readFixed32();
            case t.BOOL:
              return this.readBool();
            case t.STRING:
              return this.readString();
            case t.GROUP:
              goog.asserts.fail("Group field type not supported in readAny()");
            case t.MESSAGE:
              goog.asserts.fail("Message field type not supported in readAny()");
            case t.BYTES:
              return this.readBytes();
            case t.UINT32:
              return this.readUint32();
            case t.ENUM:
              return this.readEnum();
            case t.SFIXED32:
              return this.readSfixed32();
            case t.SFIXED64:
              return this.readSfixed64();
            case t.SINT32:
              return this.readSint32();
            case t.SINT64:
              return this.readSint64();
            case t.FHASH64:
              return this.readFixedHash64();
            case t.VHASH64:
              return this.readVarintHash64();
            default:
              goog.asserts.fail("Invalid field type in readAny()");
          }
          return 0;
        }, jspb.BinaryReader.prototype.readMessage = function(e, t) {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
          var n = this.decoder_.getEnd(), r = this.decoder_.readUnsignedVarint32();
          r = this.decoder_.getCursor() + r, this.decoder_.setEnd(r), t(e, this), this.decoder_.setCursor(r), this.decoder_.setEnd(n);
        }, jspb.BinaryReader.prototype.readGroup = function(e, t, n) {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP), goog.asserts.assert(this.nextField_ == e), n(t, this), this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (goog.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = !0);
        }, jspb.BinaryReader.prototype.getFieldDecoder = function() {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
          var e = this.decoder_.readUnsignedVarint32(), t = this.decoder_.getCursor(), n = t + e;
          return e = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), t, e), this.decoder_.setCursor(n), e;
        }, jspb.BinaryReader.prototype.readInt32 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32();
        }, jspb.BinaryReader.prototype.readInt32String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint32String();
        }, jspb.BinaryReader.prototype.readInt64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
        }, jspb.BinaryReader.prototype.readInt64String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64String();
        }, jspb.BinaryReader.prototype.readUint32 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32();
        }, jspb.BinaryReader.prototype.readUint32String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint32String();
        }, jspb.BinaryReader.prototype.readUint64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64();
        }, jspb.BinaryReader.prototype.readUint64String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readUnsignedVarint64String();
        }, jspb.BinaryReader.prototype.readSint32 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint32();
        }, jspb.BinaryReader.prototype.readSint64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64();
        }, jspb.BinaryReader.prototype.readSint64String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarint64String();
        }, jspb.BinaryReader.prototype.readFixed32 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readUint32();
        }, jspb.BinaryReader.prototype.readFixed64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64();
        }, jspb.BinaryReader.prototype.readFixed64String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readUint64String();
        }, jspb.BinaryReader.prototype.readSfixed32 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32();
        }, jspb.BinaryReader.prototype.readSfixed32String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readInt32().toString();
        }, jspb.BinaryReader.prototype.readSfixed64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64();
        }, jspb.BinaryReader.prototype.readSfixed64String = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readInt64String();
        }, jspb.BinaryReader.prototype.readFloat = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32), this.decoder_.readFloat();
        }, jspb.BinaryReader.prototype.readDouble = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readDouble();
        }, jspb.BinaryReader.prototype.readBool = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), !!this.decoder_.readUnsignedVarint32();
        }, jspb.BinaryReader.prototype.readEnum = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSignedVarint64();
        }, jspb.BinaryReader.prototype.readString = function() {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
          var e = this.decoder_.readUnsignedVarint32();
          return this.decoder_.readString(e);
        }, jspb.BinaryReader.prototype.readBytes = function() {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
          var e = this.decoder_.readUnsignedVarint32();
          return this.decoder_.readBytes(e);
        }, jspb.BinaryReader.prototype.readVarintHash64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readVarintHash64();
        }, jspb.BinaryReader.prototype.readSintHash64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readZigzagVarintHash64();
        }, jspb.BinaryReader.prototype.readSplitVarint64 = function(e) {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(e);
        }, jspb.BinaryReader.prototype.readSplitZigzagVarint64 = function(e) {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT), this.decoder_.readSplitVarint64(function(t, n) {
            return jspb.utils.fromZigzag64(t, n, e);
          });
        }, jspb.BinaryReader.prototype.readFixedHash64 = function() {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readFixedHash64();
        }, jspb.BinaryReader.prototype.readSplitFixed64 = function(e) {
          return goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64), this.decoder_.readSplitFixed64(e);
        }, jspb.BinaryReader.prototype.readPackedField_ = function(e) {
          goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
          var t = this.decoder_.readUnsignedVarint32();
          t = this.decoder_.getCursor() + t;
          for (var n = []; this.decoder_.getCursor() < t; )
            n.push(e.call(this.decoder_));
          return n;
        }, jspb.BinaryReader.prototype.readPackedInt32 = function() {
          return this.readPackedField_(this.decoder_.readSignedVarint32);
        }, jspb.BinaryReader.prototype.readPackedInt32String = function() {
          return this.readPackedField_(this.decoder_.readSignedVarint32String);
        }, jspb.BinaryReader.prototype.readPackedInt64 = function() {
          return this.readPackedField_(this.decoder_.readSignedVarint64);
        }, jspb.BinaryReader.prototype.readPackedInt64String = function() {
          return this.readPackedField_(this.decoder_.readSignedVarint64String);
        }, jspb.BinaryReader.prototype.readPackedUint32 = function() {
          return this.readPackedField_(this.decoder_.readUnsignedVarint32);
        }, jspb.BinaryReader.prototype.readPackedUint32String = function() {
          return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
        }, jspb.BinaryReader.prototype.readPackedUint64 = function() {
          return this.readPackedField_(this.decoder_.readUnsignedVarint64);
        }, jspb.BinaryReader.prototype.readPackedUint64String = function() {
          return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
        }, jspb.BinaryReader.prototype.readPackedSint32 = function() {
          return this.readPackedField_(this.decoder_.readZigzagVarint32);
        }, jspb.BinaryReader.prototype.readPackedSint64 = function() {
          return this.readPackedField_(this.decoder_.readZigzagVarint64);
        }, jspb.BinaryReader.prototype.readPackedSint64String = function() {
          return this.readPackedField_(this.decoder_.readZigzagVarint64String);
        }, jspb.BinaryReader.prototype.readPackedFixed32 = function() {
          return this.readPackedField_(this.decoder_.readUint32);
        }, jspb.BinaryReader.prototype.readPackedFixed64 = function() {
          return this.readPackedField_(this.decoder_.readUint64);
        }, jspb.BinaryReader.prototype.readPackedFixed64String = function() {
          return this.readPackedField_(this.decoder_.readUint64String);
        }, jspb.BinaryReader.prototype.readPackedSfixed32 = function() {
          return this.readPackedField_(this.decoder_.readInt32);
        }, jspb.BinaryReader.prototype.readPackedSfixed64 = function() {
          return this.readPackedField_(this.decoder_.readInt64);
        }, jspb.BinaryReader.prototype.readPackedSfixed64String = function() {
          return this.readPackedField_(this.decoder_.readInt64String);
        }, jspb.BinaryReader.prototype.readPackedFloat = function() {
          return this.readPackedField_(this.decoder_.readFloat);
        }, jspb.BinaryReader.prototype.readPackedDouble = function() {
          return this.readPackedField_(this.decoder_.readDouble);
        }, jspb.BinaryReader.prototype.readPackedBool = function() {
          return this.readPackedField_(this.decoder_.readBool);
        }, jspb.BinaryReader.prototype.readPackedEnum = function() {
          return this.readPackedField_(this.decoder_.readEnum);
        }, jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {
          return this.readPackedField_(this.decoder_.readVarintHash64);
        }, jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {
          return this.readPackedField_(this.decoder_.readFixedHash64);
        }, jspb.Map = function(e, t) {
          this.arr_ = e, this.valueCtor_ = t, this.map_ = {}, this.arrClean = !0, 0 < this.arr_.length && this.loadFromArray_();
        }, jspb.Map.prototype.loadFromArray_ = function() {
          for (var e = 0; e < this.arr_.length; e++) {
            var t = this.arr_[e], n = t[0];
            this.map_[n.toString()] = new jspb.Map.Entry_(n, t[1]);
          }
          this.arrClean = !0;
        }, jspb.Map.prototype.toArray = function() {
          if (this.arrClean) {
            if (this.valueCtor_) {
              var e, t = this.map_;
              for (e in t)
                if (Object.prototype.hasOwnProperty.call(t, e)) {
                  var n = t[e].valueWrapper;
                  n && n.toArray();
                }
            }
          } else {
            for (this.arr_.length = 0, (t = this.stringKeys_()).sort(), e = 0; e < t.length; e++) {
              var r = this.map_[t[e]];
              (n = r.valueWrapper) && n.toArray(), this.arr_.push([r.key, r.value]);
            }
            this.arrClean = !0;
          }
          return this.arr_;
        }, jspb.Map.prototype.toObject = function(e, t) {
          for (var n = this.toArray(), r = [], o = 0; o < n.length; o++) {
            var l = this.map_[n[o][0].toString()];
            this.wrapEntry_(l);
            var u = l.valueWrapper;
            u ? (goog.asserts.assert(t), r.push([l.key, t(e, u)])) : r.push([l.key, l.value]);
          }
          return r;
        }, jspb.Map.fromObject = function(e, t, n) {
          t = new jspb.Map([], t);
          for (var r = 0; r < e.length; r++) {
            var o = e[r][0], l = n(e[r][1]);
            t.set(o, l);
          }
          return t;
        }, jspb.Map.ArrayIteratorIterable_ = function(e) {
          this.idx_ = 0, this.arr_ = e;
        }, jspb.Map.ArrayIteratorIterable_.prototype.next = function() {
          return this.idx_ < this.arr_.length ? { done: !1, value: this.arr_[this.idx_++] } : { done: !0, value: void 0 };
        }, typeof Symbol < "u" && (jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {
          return this;
        }), jspb.Map.prototype.getLength = function() {
          return this.stringKeys_().length;
        }, jspb.Map.prototype.clear = function() {
          this.map_ = {}, this.arrClean = !1;
        }, jspb.Map.prototype.del = function(e) {
          e = e.toString();
          var t = this.map_.hasOwnProperty(e);
          return delete this.map_[e], this.arrClean = !1, t;
        }, jspb.Map.prototype.getEntryList = function() {
          var e = [], t = this.stringKeys_();
          t.sort();
          for (var n = 0; n < t.length; n++) {
            var r = this.map_[t[n]];
            e.push([r.key, r.value]);
          }
          return e;
        }, jspb.Map.prototype.entries = function() {
          var e = [], t = this.stringKeys_();
          t.sort();
          for (var n = 0; n < t.length; n++) {
            var r = this.map_[t[n]];
            e.push([r.key, this.wrapEntry_(r)]);
          }
          return new jspb.Map.ArrayIteratorIterable_(e);
        }, jspb.Map.prototype.keys = function() {
          var e = [], t = this.stringKeys_();
          t.sort();
          for (var n = 0; n < t.length; n++)
            e.push(this.map_[t[n]].key);
          return new jspb.Map.ArrayIteratorIterable_(e);
        }, jspb.Map.prototype.values = function() {
          var e = [], t = this.stringKeys_();
          t.sort();
          for (var n = 0; n < t.length; n++)
            e.push(this.wrapEntry_(this.map_[t[n]]));
          return new jspb.Map.ArrayIteratorIterable_(e);
        }, jspb.Map.prototype.forEach = function(e, t) {
          var n = this.stringKeys_();
          n.sort();
          for (var r = 0; r < n.length; r++) {
            var o = this.map_[n[r]];
            e.call(t, this.wrapEntry_(o), o.key, this);
          }
        }, jspb.Map.prototype.set = function(e, t) {
          var n = new jspb.Map.Entry_(e);
          return this.valueCtor_ ? (n.valueWrapper = t, n.value = t.toArray()) : n.value = t, this.map_[e.toString()] = n, this.arrClean = !1, this;
        }, jspb.Map.prototype.wrapEntry_ = function(e) {
          return this.valueCtor_ ? (e.valueWrapper || (e.valueWrapper = new this.valueCtor_(e.value)), e.valueWrapper) : e.value;
        }, jspb.Map.prototype.get = function(e) {
          if (e = this.map_[e.toString()])
            return this.wrapEntry_(e);
        }, jspb.Map.prototype.has = function(e) {
          return e.toString() in this.map_;
        }, jspb.Map.prototype.serializeBinary = function(e, t, n, r, o) {
          var l = this.stringKeys_();
          l.sort();
          for (var u = 0; u < l.length; u++) {
            var s = this.map_[l[u]];
            t.beginSubMessage(e), n.call(t, 1, s.key), this.valueCtor_ ? r.call(t, 2, this.wrapEntry_(s), o) : r.call(t, 2, s.value), t.endSubMessage();
          }
        }, jspb.Map.deserializeBinary = function(e, t, n, r, o, l, u) {
          for (; t.nextField() && !t.isEndGroup(); ) {
            var s = t.getFieldNumber();
            s == 1 ? l = n.call(t) : s == 2 && (e.valueCtor_ ? (goog.asserts.assert(o), u || (u = new e.valueCtor_()), r.call(t, u, o)) : u = r.call(t));
          }
          goog.asserts.assert(l != null), goog.asserts.assert(u != null), e.set(l, u);
        }, jspb.Map.prototype.stringKeys_ = function() {
          var e, t = this.map_, n = [];
          for (e in t)
            Object.prototype.hasOwnProperty.call(t, e) && n.push(e);
          return n;
        }, jspb.Map.Entry_ = function(e, t) {
          this.key = e, this.value = t, this.valueWrapper = void 0;
        }, jspb.ExtensionFieldInfo = function(e, t, n, r, o) {
          this.fieldIndex = e, this.fieldName = t, this.ctor = n, this.toObjectFn = r, this.isRepeated = o;
        }, jspb.ExtensionFieldBinaryInfo = function(e, t, n, r, o, l) {
          this.fieldInfo = e, this.binaryReaderFn = t, this.binaryWriterFn = n, this.binaryMessageSerializeFn = r, this.binaryMessageDeserializeFn = o, this.isPacked = l;
        }, jspb.ExtensionFieldInfo.prototype.isMessageType = function() {
          return !!this.ctor;
        }, jspb.Message = function() {
        }, jspb.Message.GENERATE_TO_OBJECT = !0, jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE, jspb.Message.GENERATE_TO_STRING = !0, jspb.Message.ASSUME_LOCAL_ARRAYS = !1, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS = !0, jspb.Message.SUPPORTS_UINT8ARRAY_ = typeof Uint8Array == "function", jspb.Message.prototype.getJsPbMessageId = function() {
          return this.messageId_;
        }, jspb.Message.getIndex_ = function(e, t) {
          return t + e.arrayIndexOffset_;
        }, jspb.Message.hiddenES6Property_ = function() {
        }, jspb.Message.getFieldNumber_ = function(e, t) {
          return t - e.arrayIndexOffset_;
        }, jspb.Message.initialize = function(e, t, n, r, o, l) {
          if (e.wrappers_ = null, t || (t = n ? [n] : []), e.messageId_ = n ? String(n) : void 0, e.arrayIndexOffset_ = n === 0 ? -1 : 0, e.array = t, jspb.Message.initPivotAndExtensionObject_(e, r), e.convertedPrimitiveFields_ = {}, jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS || (e.repeatedFields = o), o)
            for (t = 0; t < o.length; t++)
              (n = o[t]) < e.pivot_ ? (n = jspb.Message.getIndex_(e, n), e.array[n] = e.array[n] || jspb.Message.EMPTY_LIST_SENTINEL_) : (jspb.Message.maybeInitEmptyExtensionObject_(e), e.extensionObject_[n] = e.extensionObject_[n] || jspb.Message.EMPTY_LIST_SENTINEL_);
          if (l && l.length)
            for (t = 0; t < l.length; t++)
              jspb.Message.computeOneofCase(e, l[t]);
        }, jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [], jspb.Message.isArray_ = function(e) {
          return jspb.Message.ASSUME_LOCAL_ARRAYS ? e instanceof Array : Array.isArray(e);
        }, jspb.Message.isExtensionObject_ = function(e) {
          return !(e === null || typeof e != "object" || jspb.Message.isArray_(e) || jspb.Message.SUPPORTS_UINT8ARRAY_ && e instanceof Uint8Array);
        }, jspb.Message.initPivotAndExtensionObject_ = function(e, t) {
          var n = e.array.length, r = -1;
          if (n && (r = n - 1, n = e.array[r], jspb.Message.isExtensionObject_(n)))
            return e.pivot_ = jspb.Message.getFieldNumber_(e, r), void (e.extensionObject_ = n);
          -1 < t ? (e.pivot_ = Math.max(t, jspb.Message.getFieldNumber_(e, r + 1)), e.extensionObject_ = null) : e.pivot_ = Number.MAX_VALUE;
        }, jspb.Message.maybeInitEmptyExtensionObject_ = function(e) {
          var t = jspb.Message.getIndex_(e, e.pivot_);
          e.array[t] || (e.extensionObject_ = e.array[t] = {});
        }, jspb.Message.toObjectList = function(e, t, n) {
          for (var r = [], o = 0; o < e.length; o++)
            r[o] = t.call(e[o], n, e[o]);
          return r;
        }, jspb.Message.toObjectExtension = function(e, t, n, r, o) {
          for (var l in n) {
            var u = n[l], s = r.call(e, u);
            if (s != null) {
              for (var g in u.fieldName)
                if (u.fieldName.hasOwnProperty(g))
                  break;
              t[g] = u.toObjectFn ? u.isRepeated ? jspb.Message.toObjectList(s, u.toObjectFn, o) : u.toObjectFn(o, s) : s;
            }
          }
        }, jspb.Message.serializeBinaryExtensions = function(e, t, n, r) {
          for (var o in n) {
            var l = n[o], u = l.fieldInfo;
            if (!l.binaryWriterFn)
              throw Error("Message extension present that was generated without binary serialization support");
            var s = r.call(e, u);
            if (s != null)
              if (u.isMessageType()) {
                if (!l.binaryMessageSerializeFn)
                  throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                l.binaryWriterFn.call(t, u.fieldIndex, s, l.binaryMessageSerializeFn);
              } else
                l.binaryWriterFn.call(t, u.fieldIndex, s);
          }
        }, jspb.Message.readBinaryExtension = function(e, t, n, r, o) {
          var l = n[t.getFieldNumber()];
          if (l) {
            if (n = l.fieldInfo, !l.binaryReaderFn)
              throw Error("Deserializing extension whose generated code does not support binary format");
            if (n.isMessageType()) {
              var u = new n.ctor();
              l.binaryReaderFn.call(t, u, l.binaryMessageDeserializeFn);
            } else
              u = l.binaryReaderFn.call(t);
            n.isRepeated && !l.isPacked ? (t = r.call(e, n)) ? t.push(u) : o.call(e, n, [u]) : o.call(e, n, u);
          } else
            t.skipField();
        }, jspb.Message.getField = function(e, t) {
          if (t < e.pivot_) {
            t = jspb.Message.getIndex_(e, t);
            var n = e.array[t];
            return n === jspb.Message.EMPTY_LIST_SENTINEL_ ? e.array[t] = [] : n;
          }
          if (e.extensionObject_)
            return (n = e.extensionObject_[t]) === jspb.Message.EMPTY_LIST_SENTINEL_ ? e.extensionObject_[t] = [] : n;
        }, jspb.Message.getRepeatedField = function(e, t) {
          return jspb.Message.getField(e, t);
        }, jspb.Message.getOptionalFloatingPointField = function(e, t) {
          return (e = jspb.Message.getField(e, t)) == null ? e : +e;
        }, jspb.Message.getBooleanField = function(e, t) {
          return (e = jspb.Message.getField(e, t)) == null ? e : !!e;
        }, jspb.Message.getRepeatedFloatingPointField = function(e, t) {
          var n = jspb.Message.getRepeatedField(e, t);
          if (e.convertedPrimitiveFields_ || (e.convertedPrimitiveFields_ = {}), !e.convertedPrimitiveFields_[t]) {
            for (var r = 0; r < n.length; r++)
              n[r] = +n[r];
            e.convertedPrimitiveFields_[t] = !0;
          }
          return n;
        }, jspb.Message.getRepeatedBooleanField = function(e, t) {
          var n = jspb.Message.getRepeatedField(e, t);
          if (e.convertedPrimitiveFields_ || (e.convertedPrimitiveFields_ = {}), !e.convertedPrimitiveFields_[t]) {
            for (var r = 0; r < n.length; r++)
              n[r] = !!n[r];
            e.convertedPrimitiveFields_[t] = !0;
          }
          return n;
        }, jspb.Message.bytesAsB64 = function(e) {
          return e == null || typeof e == "string" ? e : jspb.Message.SUPPORTS_UINT8ARRAY_ && e instanceof Uint8Array ? goog.crypt.base64.encodeByteArray(e) : (goog.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(e)), null);
        }, jspb.Message.bytesAsU8 = function(e) {
          return e == null || e instanceof Uint8Array ? e : typeof e == "string" ? goog.crypt.base64.decodeStringToUint8Array(e) : (goog.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(e)), null);
        }, jspb.Message.bytesListAsB64 = function(e) {
          return jspb.Message.assertConsistentTypes_(e), e.length && typeof e[0] != "string" ? goog.array.map(e, jspb.Message.bytesAsB64) : e;
        }, jspb.Message.bytesListAsU8 = function(e) {
          return jspb.Message.assertConsistentTypes_(e), !e.length || e[0] instanceof Uint8Array ? e : goog.array.map(e, jspb.Message.bytesAsU8);
        }, jspb.Message.assertConsistentTypes_ = function(e) {
          if (goog.DEBUG && e && 1 < e.length) {
            var t = goog.typeOf(e[0]);
            goog.array.forEach(e, function(n) {
              goog.typeOf(n) != t && goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(n) + " expected " + t);
            });
          }
        }, jspb.Message.getFieldWithDefault = function(e, t, n) {
          return (e = jspb.Message.getField(e, t)) == null ? n : e;
        }, jspb.Message.getBooleanFieldWithDefault = function(e, t, n) {
          return (e = jspb.Message.getBooleanField(e, t)) == null ? n : e;
        }, jspb.Message.getFloatingPointFieldWithDefault = function(e, t, n) {
          return (e = jspb.Message.getOptionalFloatingPointField(e, t)) == null ? n : e;
        }, jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault, jspb.Message.getMapField = function(e, t, n, r) {
          if (e.wrappers_ || (e.wrappers_ = {}), t in e.wrappers_)
            return e.wrappers_[t];
          var o = jspb.Message.getField(e, t);
          if (!o) {
            if (n)
              return;
            o = [], jspb.Message.setField(e, t, o);
          }
          return e.wrappers_[t] = new jspb.Map(o, r);
        }, jspb.Message.setField = function(e, t, n) {
          return goog.asserts.assertInstanceof(e, jspb.Message), t < e.pivot_ ? e.array[jspb.Message.getIndex_(e, t)] = n : (jspb.Message.maybeInitEmptyExtensionObject_(e), e.extensionObject_[t] = n), e;
        }, jspb.Message.setProto3IntField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, 0);
        }, jspb.Message.setProto3FloatField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, 0);
        }, jspb.Message.setProto3BooleanField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, !1);
        }, jspb.Message.setProto3StringField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, "");
        }, jspb.Message.setProto3BytesField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, "");
        }, jspb.Message.setProto3EnumField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, 0);
        }, jspb.Message.setProto3StringIntField = function(e, t, n) {
          return jspb.Message.setFieldIgnoringDefault_(e, t, n, "0");
        }, jspb.Message.setFieldIgnoringDefault_ = function(e, t, n, r) {
          return goog.asserts.assertInstanceof(e, jspb.Message), n !== r ? jspb.Message.setField(e, t, n) : t < e.pivot_ ? e.array[jspb.Message.getIndex_(e, t)] = null : (jspb.Message.maybeInitEmptyExtensionObject_(e), delete e.extensionObject_[t]), e;
        }, jspb.Message.addToRepeatedField = function(e, t, n, r) {
          return goog.asserts.assertInstanceof(e, jspb.Message), t = jspb.Message.getRepeatedField(e, t), r != null ? t.splice(r, 0, n) : t.push(n), e;
        }, jspb.Message.setOneofField = function(e, t, n, r) {
          return goog.asserts.assertInstanceof(e, jspb.Message), (n = jspb.Message.computeOneofCase(e, n)) && n !== t && r !== void 0 && (e.wrappers_ && n in e.wrappers_ && (e.wrappers_[n] = void 0), jspb.Message.setField(e, n, void 0)), jspb.Message.setField(e, t, r);
        }, jspb.Message.computeOneofCase = function(e, t) {
          for (var n, r, o = 0; o < t.length; o++) {
            var l = t[o], u = jspb.Message.getField(e, l);
            u != null && (n = l, r = u, jspb.Message.setField(e, l, void 0));
          }
          return n ? (jspb.Message.setField(e, n, r), n) : 0;
        }, jspb.Message.getWrapperField = function(e, t, n, r) {
          if (e.wrappers_ || (e.wrappers_ = {}), !e.wrappers_[n]) {
            var o = jspb.Message.getField(e, n);
            (r || o) && (e.wrappers_[n] = new t(o));
          }
          return e.wrappers_[n];
        }, jspb.Message.getRepeatedWrapperField = function(e, t, n) {
          return jspb.Message.wrapRepeatedField_(e, t, n), (t = e.wrappers_[n]) == jspb.Message.EMPTY_LIST_SENTINEL_ && (t = e.wrappers_[n] = []), t;
        }, jspb.Message.wrapRepeatedField_ = function(e, t, n) {
          if (e.wrappers_ || (e.wrappers_ = {}), !e.wrappers_[n]) {
            for (var r = jspb.Message.getRepeatedField(e, n), o = [], l = 0; l < r.length; l++)
              o[l] = new t(r[l]);
            e.wrappers_[n] = o;
          }
        }, jspb.Message.setWrapperField = function(e, t, n) {
          goog.asserts.assertInstanceof(e, jspb.Message), e.wrappers_ || (e.wrappers_ = {});
          var r = n && n.toArray();
          return e.wrappers_[t] = n, jspb.Message.setField(e, t, r);
        }, jspb.Message.setOneofWrapperField = function(e, t, n, r) {
          goog.asserts.assertInstanceof(e, jspb.Message), e.wrappers_ || (e.wrappers_ = {});
          var o = r && r.toArray();
          return e.wrappers_[t] = r, jspb.Message.setOneofField(e, t, n, o);
        }, jspb.Message.setRepeatedWrapperField = function(e, t, n) {
          goog.asserts.assertInstanceof(e, jspb.Message), e.wrappers_ || (e.wrappers_ = {}), n = n || [];
          for (var r = [], o = 0; o < n.length; o++)
            r[o] = n[o].toArray();
          return e.wrappers_[t] = n, jspb.Message.setField(e, t, r);
        }, jspb.Message.addToRepeatedWrapperField = function(e, t, n, r, o) {
          jspb.Message.wrapRepeatedField_(e, r, t);
          var l = e.wrappers_[t];
          return l || (l = e.wrappers_[t] = []), n = n || new r(), e = jspb.Message.getRepeatedField(e, t), o != null ? (l.splice(o, 0, n), e.splice(o, 0, n.toArray())) : (l.push(n), e.push(n.toArray())), n;
        }, jspb.Message.toMap = function(e, t, n, r) {
          for (var o = {}, l = 0; l < e.length; l++)
            o[t.call(e[l])] = n ? n.call(e[l], r, e[l]) : e[l];
          return o;
        }, jspb.Message.prototype.syncMapFields_ = function() {
          if (this.wrappers_)
            for (var e in this.wrappers_) {
              var t = this.wrappers_[e];
              if (Array.isArray(t))
                for (var n = 0; n < t.length; n++)
                  t[n] && t[n].toArray();
              else
                t && t.toArray();
            }
        }, jspb.Message.prototype.toArray = function() {
          return this.syncMapFields_(), this.array;
        }, jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function() {
          return this.syncMapFields_(), this.array.toString();
        }), jspb.Message.prototype.getExtension = function(e) {
          if (this.extensionObject_) {
            this.wrappers_ || (this.wrappers_ = {});
            var t = e.fieldIndex;
            if (e.isRepeated) {
              if (e.isMessageType())
                return this.wrappers_[t] || (this.wrappers_[t] = goog.array.map(this.extensionObject_[t] || [], function(n) {
                  return new e.ctor(n);
                })), this.wrappers_[t];
            } else if (e.isMessageType())
              return !this.wrappers_[t] && this.extensionObject_[t] && (this.wrappers_[t] = new e.ctor(this.extensionObject_[t])), this.wrappers_[t];
            return this.extensionObject_[t];
          }
        }, jspb.Message.prototype.setExtension = function(e, t) {
          this.wrappers_ || (this.wrappers_ = {}), jspb.Message.maybeInitEmptyExtensionObject_(this);
          var n = e.fieldIndex;
          return e.isRepeated ? (t = t || [], e.isMessageType() ? (this.wrappers_[n] = t, this.extensionObject_[n] = goog.array.map(t, function(r) {
            return r.toArray();
          })) : this.extensionObject_[n] = t) : e.isMessageType() ? (this.wrappers_[n] = t, this.extensionObject_[n] = t && t.toArray()) : this.extensionObject_[n] = t, this;
        }, jspb.Message.difference = function(e, t) {
          if (!(e instanceof t.constructor))
            throw Error("Messages have different types.");
          var n = e.toArray();
          t = t.toArray();
          var r = [], o = 0, l = n.length > t.length ? n.length : t.length;
          for (e.getJsPbMessageId() && (r[0] = e.getJsPbMessageId(), o = 1); o < l; o++)
            jspb.Message.compareFields(n[o], t[o]) || (r[o] = t[o]);
          return new e.constructor(r);
        }, jspb.Message.equals = function(e, t) {
          return e == t || !(!e || !t) && e instanceof t.constructor && jspb.Message.compareFields(e.toArray(), t.toArray());
        }, jspb.Message.compareExtensions = function(e, t) {
          e = e || {}, t = t || {};
          var n, r = {};
          for (n in e)
            r[n] = 0;
          for (n in t)
            r[n] = 0;
          for (n in r)
            if (!jspb.Message.compareFields(e[n], t[n]))
              return !1;
          return !0;
        }, jspb.Message.compareFields = function(e, t) {
          if (e == t)
            return !0;
          if (!goog.isObject(e) || !goog.isObject(t))
            return !!(typeof e == "number" && isNaN(e) || typeof t == "number" && isNaN(t)) && String(e) == String(t);
          if (e.constructor != t.constructor)
            return !1;
          if (jspb.Message.SUPPORTS_UINT8ARRAY_ && e.constructor === Uint8Array) {
            if (e.length != t.length)
              return !1;
            for (var n = 0; n < e.length; n++)
              if (e[n] != t[n])
                return !1;
            return !0;
          }
          if (e.constructor === Array) {
            var r = void 0, o = void 0, l = Math.max(e.length, t.length);
            for (n = 0; n < l; n++) {
              var u = e[n], s = t[n];
              if (u && u.constructor == Object && (goog.asserts.assert(r === void 0), goog.asserts.assert(n === e.length - 1), r = u, u = void 0), s && s.constructor == Object && (goog.asserts.assert(o === void 0), goog.asserts.assert(n === t.length - 1), o = s, s = void 0), !jspb.Message.compareFields(u, s))
                return !1;
            }
            return !r && !o || (r = r || {}, o = o || {}, jspb.Message.compareExtensions(r, o));
          }
          if (e.constructor === Object)
            return jspb.Message.compareExtensions(e, t);
          throw Error("Invalid type in JSPB array");
        }, jspb.Message.prototype.cloneMessage = function() {
          return jspb.Message.cloneMessage(this);
        }, jspb.Message.prototype.clone = function() {
          return jspb.Message.cloneMessage(this);
        }, jspb.Message.clone = function(e) {
          return jspb.Message.cloneMessage(e);
        }, jspb.Message.cloneMessage = function(e) {
          return new e.constructor(jspb.Message.clone_(e.toArray()));
        }, jspb.Message.copyInto = function(e, t) {
          goog.asserts.assertInstanceof(e, jspb.Message), goog.asserts.assertInstanceof(t, jspb.Message), goog.asserts.assert(e.constructor == t.constructor, "Copy source and target message should have the same type."), e = jspb.Message.clone(e);
          for (var n = t.toArray(), r = e.toArray(), o = n.length = 0; o < r.length; o++)
            n[o] = r[o];
          t.wrappers_ = e.wrappers_, t.extensionObject_ = e.extensionObject_;
        }, jspb.Message.clone_ = function(e) {
          if (Array.isArray(e)) {
            for (var t = Array(e.length), n = 0; n < e.length; n++) {
              var r = e[n];
              r != null && (t[n] = typeof r == "object" ? jspb.Message.clone_(goog.asserts.assert(r)) : r);
            }
            return t;
          }
          if (jspb.Message.SUPPORTS_UINT8ARRAY_ && e instanceof Uint8Array)
            return new Uint8Array(e);
          for (n in t = {}, e)
            (r = e[n]) != null && (t[n] = typeof r == "object" ? jspb.Message.clone_(goog.asserts.assert(r)) : r);
          return t;
        }, jspb.Message.registerMessageType = function(e, t) {
          t.messageId = e;
        }, jspb.Message.messageSetExtensions = {}, jspb.Message.messageSetExtensionsBinary = {}, jspb.arith = {}, jspb.arith.UInt64 = function(e, t) {
          this.lo = e, this.hi = t;
        }, jspb.arith.UInt64.prototype.cmp = function(e) {
          return this.hi < e.hi || this.hi == e.hi && this.lo < e.lo ? -1 : this.hi == e.hi && this.lo == e.lo ? 0 : 1;
        }, jspb.arith.UInt64.prototype.rightShift = function() {
          return new jspb.arith.UInt64((this.lo >>> 1 | (1 & this.hi) << 31) >>> 0, this.hi >>> 1 >>> 0);
        }, jspb.arith.UInt64.prototype.leftShift = function() {
          return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
        }, jspb.arith.UInt64.prototype.msb = function() {
          return !!(2147483648 & this.hi);
        }, jspb.arith.UInt64.prototype.lsb = function() {
          return !!(1 & this.lo);
        }, jspb.arith.UInt64.prototype.zero = function() {
          return this.lo == 0 && this.hi == 0;
        }, jspb.arith.UInt64.prototype.add = function(e) {
          return new jspb.arith.UInt64((this.lo + e.lo & 4294967295) >>> 0 >>> 0, ((this.hi + e.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e.lo ? 1 : 0) >>> 0);
        }, jspb.arith.UInt64.prototype.sub = function(e) {
          return new jspb.arith.UInt64((this.lo - e.lo & 4294967295) >>> 0 >>> 0, ((this.hi - e.hi & 4294967295) >>> 0) - (0 > this.lo - e.lo ? 1 : 0) >>> 0);
        }, jspb.arith.UInt64.mul32x32 = function(e, t) {
          var n = 65535 & e, r = 65535 & t, o = t >>> 16;
          for (t = n * r + 65536 * (n * o & 65535) + 65536 * ((e >>>= 16) * r & 65535), n = e * o + (n * o >>> 16) + (e * r >>> 16); 4294967296 <= t; )
            t -= 4294967296, n += 1;
          return new jspb.arith.UInt64(t >>> 0, n >>> 0);
        }, jspb.arith.UInt64.prototype.mul = function(e) {
          var t = jspb.arith.UInt64.mul32x32(this.lo, e);
          return (e = jspb.arith.UInt64.mul32x32(this.hi, e)).hi = e.lo, e.lo = 0, t.add(e);
        }, jspb.arith.UInt64.prototype.div = function(e) {
          if (e == 0)
            return [];
          var t = new jspb.arith.UInt64(0, 0), n = new jspb.arith.UInt64(this.lo, this.hi);
          e = new jspb.arith.UInt64(e, 0);
          for (var r = new jspb.arith.UInt64(1, 0); !e.msb(); )
            e = e.leftShift(), r = r.leftShift();
          for (; !r.zero(); )
            0 >= e.cmp(n) && (t = t.add(r), n = n.sub(e)), e = e.rightShift(), r = r.rightShift();
          return [t, n];
        }, jspb.arith.UInt64.prototype.toString = function() {
          for (var e = "", t = this; !t.zero(); ) {
            var n = (t = t.div(10))[0];
            e = t[1].lo + e, t = n;
          }
          return e == "" && (e = "0"), e;
        }, jspb.arith.UInt64.fromString = function(e) {
          for (var t = new jspb.arith.UInt64(0, 0), n = new jspb.arith.UInt64(0, 0), r = 0; r < e.length; r++) {
            if ("0" > e[r] || "9" < e[r])
              return null;
            var o = parseInt(e[r], 10);
            n.lo = o, t = t.mul(10).add(n);
          }
          return t;
        }, jspb.arith.UInt64.prototype.clone = function() {
          return new jspb.arith.UInt64(this.lo, this.hi);
        }, jspb.arith.Int64 = function(e, t) {
          this.lo = e, this.hi = t;
        }, jspb.arith.Int64.prototype.add = function(e) {
          return new jspb.arith.Int64((this.lo + e.lo & 4294967295) >>> 0 >>> 0, ((this.hi + e.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + e.lo ? 1 : 0) >>> 0);
        }, jspb.arith.Int64.prototype.sub = function(e) {
          return new jspb.arith.Int64((this.lo - e.lo & 4294967295) >>> 0 >>> 0, ((this.hi - e.hi & 4294967295) >>> 0) - (0 > this.lo - e.lo ? 1 : 0) >>> 0);
        }, jspb.arith.Int64.prototype.clone = function() {
          return new jspb.arith.Int64(this.lo, this.hi);
        }, jspb.arith.Int64.prototype.toString = function() {
          var e = (2147483648 & this.hi) != 0, t = new jspb.arith.UInt64(this.lo, this.hi);
          return e && (t = new jspb.arith.UInt64(0, 0).sub(t)), (e ? "-" : "") + t.toString();
        }, jspb.arith.Int64.fromString = function(e) {
          var t = 0 < e.length && e[0] == "-";
          return t && (e = e.substring(1)), (e = jspb.arith.UInt64.fromString(e)) === null ? null : (t && (e = new jspb.arith.UInt64(0, 0).sub(e)), new jspb.arith.Int64(e.lo, e.hi));
        }, jspb.BinaryEncoder = function() {
          this.buffer_ = [];
        }, jspb.BinaryEncoder.prototype.length = function() {
          return this.buffer_.length;
        }, jspb.BinaryEncoder.prototype.end = function() {
          var e = this.buffer_;
          return this.buffer_ = [], e;
        }, jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(e, t) {
          for (goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(t == Math.floor(t)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_32); 0 < t || 127 < e; )
            this.buffer_.push(127 & e | 128), e = (e >>> 7 | t << 25) >>> 0, t >>>= 7;
          this.buffer_.push(e);
        }, jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(e, t) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(t == Math.floor(t)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_32), this.writeUint32(e), this.writeUint32(t);
        }, jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(e) {
          for (goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32); 127 < e; )
            this.buffer_.push(127 & e | 128), e >>>= 7;
          this.buffer_.push(e);
        }, jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(e) {
          if (goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), 0 <= e)
            this.writeUnsignedVarint32(e);
          else {
            for (var t = 0; 9 > t; t++)
              this.buffer_.push(127 & e | 128), e >>= 7;
            this.buffer_.push(1);
          }
        }, jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitInt64(e), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(e), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeUnsignedVarint32((e << 1 ^ e >> 31) >>> 0);
        }, jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitZigzag64(e), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(e) {
          this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(e));
        }, jspb.BinaryEncoder.prototype.writeZigzagVarintHash64 = function(e) {
          var t = this;
          jspb.utils.splitHash64(e), jspb.utils.toZigzag64(jspb.utils.split64Low, jspb.utils.split64High, function(n, r) {
            t.writeSplitVarint64(n >>> 0, r >>> 0);
          });
        }, jspb.BinaryEncoder.prototype.writeUint8 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && 256 > e), this.buffer_.push(e >>> 0 & 255);
        }, jspb.BinaryEncoder.prototype.writeUint16 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && 65536 > e), this.buffer_.push(e >>> 0 & 255), this.buffer_.push(e >>> 8 & 255);
        }, jspb.BinaryEncoder.prototype.writeUint32 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_32), this.buffer_.push(e >>> 0 & 255), this.buffer_.push(e >>> 8 & 255), this.buffer_.push(e >>> 16 & 255), this.buffer_.push(e >>> 24 & 255);
        }, jspb.BinaryEncoder.prototype.writeUint64 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(0 <= e && e < jspb.BinaryConstants.TWO_TO_64), jspb.utils.splitUint64(e), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeInt8 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(-128 <= e && 128 > e), this.buffer_.push(e >>> 0 & 255);
        }, jspb.BinaryEncoder.prototype.writeInt16 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(-32768 <= e && 32768 > e), this.buffer_.push(e >>> 0 & 255), this.buffer_.push(e >>> 8 & 255);
        }, jspb.BinaryEncoder.prototype.writeInt32 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.buffer_.push(e >>> 0 & 255), this.buffer_.push(e >>> 8 & 255), this.buffer_.push(e >>> 16 & 255), this.buffer_.push(e >>> 24 & 255);
        }, jspb.BinaryEncoder.prototype.writeInt64 = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_63 && e < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitInt64(e), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeInt64String = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(+e >= -jspb.BinaryConstants.TWO_TO_63 && +e < jspb.BinaryConstants.TWO_TO_63), jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(e)), this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeFloat = function(e) {
          goog.asserts.assert(1 / 0 === e || -1 / 0 === e || isNaN(e) || e >= -jspb.BinaryConstants.FLOAT32_MAX && e <= jspb.BinaryConstants.FLOAT32_MAX), jspb.utils.splitFloat32(e), this.writeUint32(jspb.utils.split64Low);
        }, jspb.BinaryEncoder.prototype.writeDouble = function(e) {
          goog.asserts.assert(1 / 0 === e || -1 / 0 === e || isNaN(e) || e >= -jspb.BinaryConstants.FLOAT64_MAX && e <= jspb.BinaryConstants.FLOAT64_MAX), jspb.utils.splitFloat64(e), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeBool = function(e) {
          goog.asserts.assert(typeof e == "boolean" || typeof e == "number"), this.buffer_.push(e ? 1 : 0);
        }, jspb.BinaryEncoder.prototype.writeEnum = function(e) {
          goog.asserts.assert(e == Math.floor(e)), goog.asserts.assert(e >= -jspb.BinaryConstants.TWO_TO_31 && e < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32(e);
        }, jspb.BinaryEncoder.prototype.writeBytes = function(e) {
          this.buffer_.push.apply(this.buffer_, e);
        }, jspb.BinaryEncoder.prototype.writeVarintHash64 = function(e) {
          jspb.utils.splitHash64(e), this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeFixedHash64 = function(e) {
          jspb.utils.splitHash64(e), this.writeUint32(jspb.utils.split64Low), this.writeUint32(jspb.utils.split64High);
        }, jspb.BinaryEncoder.prototype.writeString = function(e) {
          for (var t = this.buffer_.length, n = 0; n < e.length; n++) {
            var r = e.charCodeAt(n);
            if (128 > r)
              this.buffer_.push(r);
            else if (2048 > r)
              this.buffer_.push(r >> 6 | 192), this.buffer_.push(63 & r | 128);
            else if (65536 > r)
              if (55296 <= r && 56319 >= r && n + 1 < e.length) {
                var o = e.charCodeAt(n + 1);
                56320 <= o && 57343 >= o && (r = 1024 * (r - 55296) + o - 56320 + 65536, this.buffer_.push(r >> 18 | 240), this.buffer_.push(r >> 12 & 63 | 128), this.buffer_.push(r >> 6 & 63 | 128), this.buffer_.push(63 & r | 128), n++);
              } else
                this.buffer_.push(r >> 12 | 224), this.buffer_.push(r >> 6 & 63 | 128), this.buffer_.push(63 & r | 128);
          }
          return this.buffer_.length - t;
        }, jspb.BinaryWriter = function() {
          this.blocks_ = [], this.totalLength_ = 0, this.encoder_ = new jspb.BinaryEncoder(), this.bookmarks_ = [];
        }, jspb.BinaryWriter.prototype.appendUint8Array_ = function(e) {
          var t = this.encoder_.end();
          this.blocks_.push(t), this.blocks_.push(e), this.totalLength_ += t.length + e.length;
        }, jspb.BinaryWriter.prototype.beginDelimited_ = function(e) {
          return this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), e = this.encoder_.end(), this.blocks_.push(e), this.totalLength_ += e.length, e.push(this.totalLength_), e;
        }, jspb.BinaryWriter.prototype.endDelimited_ = function(e) {
          var t = e.pop();
          for (t = this.totalLength_ + this.encoder_.length() - t, goog.asserts.assert(0 <= t); 127 < t; )
            e.push(127 & t | 128), t >>>= 7, this.totalLength_++;
          e.push(t), this.totalLength_++;
        }, jspb.BinaryWriter.prototype.writeSerializedMessage = function(e, t, n) {
          this.appendUint8Array_(e.subarray(t, n));
        }, jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(e, t, n) {
          e != null && t != null && n != null && this.writeSerializedMessage(e, t, n);
        }, jspb.BinaryWriter.prototype.reset = function() {
          this.blocks_ = [], this.encoder_.end(), this.totalLength_ = 0, this.bookmarks_ = [];
        }, jspb.BinaryWriter.prototype.getResultBuffer = function() {
          goog.asserts.assert(this.bookmarks_.length == 0);
          for (var e = new Uint8Array(this.totalLength_ + this.encoder_.length()), t = this.blocks_, n = t.length, r = 0, o = 0; o < n; o++) {
            var l = t[o];
            e.set(l, r), r += l.length;
          }
          return t = this.encoder_.end(), e.set(t, r), r += t.length, goog.asserts.assert(r == e.length), this.blocks_ = [e], e;
        }, jspb.BinaryWriter.prototype.getResultBase64String = function(e) {
          return goog.crypt.base64.encodeByteArray(this.getResultBuffer(), e);
        }, jspb.BinaryWriter.prototype.beginSubMessage = function(e) {
          this.bookmarks_.push(this.beginDelimited_(e));
        }, jspb.BinaryWriter.prototype.endSubMessage = function() {
          goog.asserts.assert(0 <= this.bookmarks_.length), this.endDelimited_(this.bookmarks_.pop());
        }, jspb.BinaryWriter.prototype.writeFieldHeader_ = function(e, t) {
          goog.asserts.assert(1 <= e && e == Math.floor(e)), this.encoder_.writeUnsignedVarint32(8 * e + t);
        }, jspb.BinaryWriter.prototype.writeAny = function(e, t, n) {
          var r = jspb.BinaryConstants.FieldType;
          switch (e) {
            case r.DOUBLE:
              this.writeDouble(t, n);
              break;
            case r.FLOAT:
              this.writeFloat(t, n);
              break;
            case r.INT64:
              this.writeInt64(t, n);
              break;
            case r.UINT64:
              this.writeUint64(t, n);
              break;
            case r.INT32:
              this.writeInt32(t, n);
              break;
            case r.FIXED64:
              this.writeFixed64(t, n);
              break;
            case r.FIXED32:
              this.writeFixed32(t, n);
              break;
            case r.BOOL:
              this.writeBool(t, n);
              break;
            case r.STRING:
              this.writeString(t, n);
              break;
            case r.GROUP:
              goog.asserts.fail("Group field type not supported in writeAny()");
              break;
            case r.MESSAGE:
              goog.asserts.fail("Message field type not supported in writeAny()");
              break;
            case r.BYTES:
              this.writeBytes(t, n);
              break;
            case r.UINT32:
              this.writeUint32(t, n);
              break;
            case r.ENUM:
              this.writeEnum(t, n);
              break;
            case r.SFIXED32:
              this.writeSfixed32(t, n);
              break;
            case r.SFIXED64:
              this.writeSfixed64(t, n);
              break;
            case r.SINT32:
              this.writeSint32(t, n);
              break;
            case r.SINT64:
              this.writeSint64(t, n);
              break;
            case r.FHASH64:
              this.writeFixedHash64(t, n);
              break;
            case r.VHASH64:
              this.writeVarintHash64(t, n);
              break;
            default:
              goog.asserts.fail("Invalid field type in writeAny()");
          }
        }, jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(t));
        }, jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(t));
        }, jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(t));
        }, jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(t));
        }, jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(t));
        }, jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(t));
        }, jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(t));
        }, jspb.BinaryWriter.prototype.writeZigzagVarintHash64_ = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarintHash64(t));
        }, jspb.BinaryWriter.prototype.writeInt32 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_31 && t < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(e, t));
        }, jspb.BinaryWriter.prototype.writeInt32String = function(e, t) {
          t != null && (t = parseInt(t, 10), goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_31 && t < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(e, t));
        }, jspb.BinaryWriter.prototype.writeInt64 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_63 && t < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(e, t));
        }, jspb.BinaryWriter.prototype.writeInt64String = function(e, t) {
          t != null && (t = jspb.arith.Int64.fromString(t), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t.lo, t.hi));
        }, jspb.BinaryWriter.prototype.writeUint32 = function(e, t) {
          t != null && (goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(e, t));
        }, jspb.BinaryWriter.prototype.writeUint32String = function(e, t) {
          t != null && (t = parseInt(t, 10), goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(e, t));
        }, jspb.BinaryWriter.prototype.writeUint64 = function(e, t) {
          t != null && (goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(e, t));
        }, jspb.BinaryWriter.prototype.writeUint64String = function(e, t) {
          t != null && (t = jspb.arith.UInt64.fromString(t), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t.lo, t.hi));
        }, jspb.BinaryWriter.prototype.writeSint32 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_31 && t < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(e, t));
        }, jspb.BinaryWriter.prototype.writeSint64 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_63 && t < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(e, t));
        }, jspb.BinaryWriter.prototype.writeSintHash64 = function(e, t) {
          t != null && this.writeZigzagVarintHash64_(e, t);
        }, jspb.BinaryWriter.prototype.writeSint64String = function(e, t) {
          t != null && this.writeZigzagVarint64String_(e, t);
        }, jspb.BinaryWriter.prototype.writeFixed32 = function(e, t) {
          t != null && (goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(t));
        }, jspb.BinaryWriter.prototype.writeFixed64 = function(e, t) {
          t != null && (goog.asserts.assert(0 <= t && t < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(t));
        }, jspb.BinaryWriter.prototype.writeFixed64String = function(e, t) {
          t != null && (t = jspb.arith.UInt64.fromString(t), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t.lo, t.hi));
        }, jspb.BinaryWriter.prototype.writeSfixed32 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_31 && t < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(t));
        }, jspb.BinaryWriter.prototype.writeSfixed64 = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_63 && t < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(t));
        }, jspb.BinaryWriter.prototype.writeSfixed64String = function(e, t) {
          t != null && (t = jspb.arith.Int64.fromString(t), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t.lo, t.hi));
        }, jspb.BinaryWriter.prototype.writeFloat = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(t));
        }, jspb.BinaryWriter.prototype.writeDouble = function(e, t) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(t));
        }, jspb.BinaryWriter.prototype.writeBool = function(e, t) {
          t != null && (goog.asserts.assert(typeof t == "boolean" || typeof t == "number"), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(t));
        }, jspb.BinaryWriter.prototype.writeEnum = function(e, t) {
          t != null && (goog.asserts.assert(t >= -jspb.BinaryConstants.TWO_TO_31 && t < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(t));
        }, jspb.BinaryWriter.prototype.writeString = function(e, t) {
          t != null && (e = this.beginDelimited_(e), this.encoder_.writeString(t), this.endDelimited_(e));
        }, jspb.BinaryWriter.prototype.writeBytes = function(e, t) {
          t != null && (t = jspb.utils.byteSourceToUint8Array(t), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(t.length), this.appendUint8Array_(t));
        }, jspb.BinaryWriter.prototype.writeMessage = function(e, t, n) {
          t != null && (e = this.beginDelimited_(e), n(t, this), this.endDelimited_(e));
        }, jspb.BinaryWriter.prototype.writeMessageSet = function(e, t, n) {
          t != null && (this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.START_GROUP), this.writeFieldHeader_(2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(e), e = this.beginDelimited_(3), n(t, this), this.endDelimited_(e), this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.END_GROUP));
        }, jspb.BinaryWriter.prototype.writeGroup = function(e, t, n) {
          t != null && (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.START_GROUP), n(t, this), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.END_GROUP));
        }, jspb.BinaryWriter.prototype.writeFixedHash64 = function(e, t) {
          t != null && (goog.asserts.assert(t.length == 8), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(t));
        }, jspb.BinaryWriter.prototype.writeVarintHash64 = function(e, t) {
          t != null && (goog.asserts.assert(t.length == 8), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(t));
        }, jspb.BinaryWriter.prototype.writeSplitFixed64 = function(e, t, n) {
          this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(t, n);
        }, jspb.BinaryWriter.prototype.writeSplitVarint64 = function(e, t, n) {
          this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(t, n);
        }, jspb.BinaryWriter.prototype.writeSplitZigzagVarint64 = function(e, t, n) {
          this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.VARINT);
          var r = this.encoder_;
          jspb.utils.toZigzag64(t, n, function(o, l) {
            r.writeSplitVarint64(o >>> 0, l >>> 0);
          });
        }, jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeSignedVarint32_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeInt32String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeSignedVarint64_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64 = function(e, t, n, r) {
          if (t != null)
            for (var o = 0; o < t.length; o++)
              this.writeSplitFixed64(e, n(t[o]), r(t[o]));
        }, jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64 = function(e, t, n, r) {
          if (t != null)
            for (var o = 0; o < t.length; o++)
              this.writeSplitVarint64(e, n(t[o]), r(t[o]));
        }, jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64 = function(e, t, n, r) {
          if (t != null)
            for (var o = 0; o < t.length; o++)
              this.writeSplitZigzagVarint64(e, n(t[o]), r(t[o]));
        }, jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeInt64String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeUnsignedVarint32_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeUint32String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeUnsignedVarint64_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeUint64String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeZigzagVarint32_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeZigzagVarint64_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeZigzagVarint64String_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSintHash64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeZigzagVarintHash64_(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeFixed32(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeFixed64(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeFixed64String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeSfixed32(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeSfixed64(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeSfixed64String(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedFloat = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeFloat(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedDouble = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeDouble(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedBool = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeBool(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedEnum = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeEnum(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedString = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeString(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedBytes = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeBytes(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedMessage = function(e, t, n) {
          if (t != null)
            for (var r = 0; r < t.length; r++) {
              var o = this.beginDelimited_(e);
              n(t[r], this), this.endDelimited_(o);
            }
        }, jspb.BinaryWriter.prototype.writeRepeatedGroup = function(e, t, n) {
          if (t != null)
            for (var r = 0; r < t.length; r++)
              this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.START_GROUP), n(t[r], this), this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.END_GROUP);
        }, jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeFixedHash64(e, t[n]);
        }, jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function(e, t) {
          if (t != null)
            for (var n = 0; n < t.length; n++)
              this.writeVarintHash64(e, t[n]);
        }, jspb.BinaryWriter.prototype.writePackedInt32 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeSignedVarint32(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedInt32String = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeSignedVarint32(parseInt(t[n], 10));
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedInt64 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeSignedVarint64(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSplitFixed64 = function(e, t, n, r) {
          if (t != null) {
            e = this.beginDelimited_(e);
            for (var o = 0; o < t.length; o++)
              this.encoder_.writeSplitFixed64(n(t[o]), r(t[o]));
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSplitVarint64 = function(e, t, n, r) {
          if (t != null) {
            e = this.beginDelimited_(e);
            for (var o = 0; o < t.length; o++)
              this.encoder_.writeSplitVarint64(n(t[o]), r(t[o]));
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64 = function(e, t, n, r) {
          if (t != null) {
            e = this.beginDelimited_(e);
            for (var o = this.encoder_, l = 0; l < t.length; l++)
              jspb.utils.toZigzag64(n(t[l]), r(t[l]), function(u, s) {
                o.writeSplitVarint64(u >>> 0, s >>> 0);
              });
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedInt64String = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++) {
              var r = jspb.arith.Int64.fromString(t[n]);
              this.encoder_.writeSplitVarint64(r.lo, r.hi);
            }
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedUint32 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeUnsignedVarint32(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedUint32String = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeUnsignedVarint32(parseInt(t[n], 10));
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedUint64 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeUnsignedVarint64(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedUint64String = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++) {
              var r = jspb.arith.UInt64.fromString(t[n]);
              this.encoder_.writeSplitVarint64(r.lo, r.hi);
            }
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSint32 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeZigzagVarint32(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSint64 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeZigzagVarint64(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSint64String = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(t[n]));
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedSintHash64 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeZigzagVarintHash64(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedFixed32 = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeUint32(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedFixed64 = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeUint64(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedFixed64String = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++) {
              var n = jspb.arith.UInt64.fromString(t[e]);
              this.encoder_.writeSplitFixed64(n.lo, n.hi);
            }
        }, jspb.BinaryWriter.prototype.writePackedSfixed32 = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeInt32(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedSfixed64 = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeInt64(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedSfixed64String = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeInt64String(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedFloat = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeFloat(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedDouble = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeDouble(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedBool = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(t.length), e = 0; e < t.length; e++)
              this.encoder_.writeBool(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedEnum = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeEnum(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(e, t) {
          if (t != null && t.length)
            for (this.writeFieldHeader_(e, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * t.length), e = 0; e < t.length; e++)
              this.encoder_.writeFixedHash64(t[e]);
        }, jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(e, t) {
          if (t != null && t.length) {
            e = this.beginDelimited_(e);
            for (var n = 0; n < t.length; n++)
              this.encoder_.writeVarintHash64(t[n]);
            this.endDelimited_(e);
          }
        }, jspb.Export = {}, exports.Map = jspb.Map, exports.Message = jspb.Message, exports.BinaryReader = jspb.BinaryReader, exports.BinaryWriter = jspb.BinaryWriter, exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo, exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo, exports.exportSymbol = goog.exportSymbol, exports.inherits = goog.inherits, exports.object = { extend: goog.object.extend }, exports.typeOf = goog.typeOf;
      }).call(this, __webpack_require__(6), __webpack_require__(5).Buffer);
    }, function(e, t, n) {
      const { AbortController: r, AbortSignal: o } = typeof self < "u" ? self : typeof window < "u" ? window : void 0;
      e.exports = r, e.exports.AbortSignal = o, e.exports.default = r;
    }, function(e, t) {
      var n = function(r) {
        function o() {
          this.fetch = !1, this.DOMException = r.DOMException;
        }
        return o.prototype = r, new o();
      }(typeof self < "u" ? self : this);
      (function(r) {
        (function(o) {
          var l = "URLSearchParams" in r, u = "Symbol" in r && "iterator" in Symbol, s = "FileReader" in r && "Blob" in r && function() {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          }(), g = "FormData" in r, c = "ArrayBuffer" in r;
          if (c)
            var d = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], T = ArrayBuffer.isView || function(C) {
              return C && d.indexOf(Object.prototype.toString.call(C)) > -1;
            };
          function b(C) {
            if (typeof C != "string" && (C = String(C)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(C))
              throw new TypeError("Invalid character in header field name");
            return C.toLowerCase();
          }
          function h(C) {
            return typeof C != "string" && (C = String(C)), C;
          }
          function f(C) {
            var w = { next: function() {
              var x = C.shift();
              return { done: x === void 0, value: x };
            } };
            return u && (w[Symbol.iterator] = function() {
              return w;
            }), w;
          }
          function v(C) {
            this.map = {}, C instanceof v ? C.forEach(function(w, x) {
              this.append(x, w);
            }, this) : Array.isArray(C) ? C.forEach(function(w) {
              this.append(w[0], w[1]);
            }, this) : C && Object.getOwnPropertyNames(C).forEach(function(w) {
              this.append(w, C[w]);
            }, this);
          }
          function E(C) {
            if (C.bodyUsed)
              return Promise.reject(new TypeError("Already read"));
            C.bodyUsed = !0;
          }
          function j(C) {
            return new Promise(function(w, x) {
              C.onload = function() {
                w(C.result);
              }, C.onerror = function() {
                x(C.error);
              };
            });
          }
          function B(C) {
            var w = new FileReader(), x = j(w);
            return w.readAsArrayBuffer(C), x;
          }
          function I(C) {
            if (C.slice)
              return C.slice(0);
            var w = new Uint8Array(C.byteLength);
            return w.set(new Uint8Array(C)), w.buffer;
          }
          function R() {
            return this.bodyUsed = !1, this._initBody = function(C) {
              var w;
              this._bodyInit = C, C ? typeof C == "string" ? this._bodyText = C : s && Blob.prototype.isPrototypeOf(C) ? this._bodyBlob = C : g && FormData.prototype.isPrototypeOf(C) ? this._bodyFormData = C : l && URLSearchParams.prototype.isPrototypeOf(C) ? this._bodyText = C.toString() : c && s && (w = C) && DataView.prototype.isPrototypeOf(w) ? (this._bodyArrayBuffer = I(C.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : c && (ArrayBuffer.prototype.isPrototypeOf(C) || T(C)) ? this._bodyArrayBuffer = I(C) : this._bodyText = C = Object.prototype.toString.call(C) : this._bodyText = "", this.headers.get("content-type") || (typeof C == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : l && URLSearchParams.prototype.isPrototypeOf(C) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }, s && (this.blob = function() {
              var C = E(this);
              if (C)
                return C;
              if (this._bodyBlob)
                return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }, this.arrayBuffer = function() {
              return this._bodyArrayBuffer ? E(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(B);
            }), this.text = function() {
              var C, w, x, H = E(this);
              if (H)
                return H;
              if (this._bodyBlob)
                return C = this._bodyBlob, w = new FileReader(), x = j(w), w.readAsText(C), x;
              if (this._bodyArrayBuffer)
                return Promise.resolve(function(L) {
                  for (var N = new Uint8Array(L), P = new Array(N.length), z = 0; z < N.length; z++)
                    P[z] = String.fromCharCode(N[z]);
                  return P.join("");
                }(this._bodyArrayBuffer));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }, g && (this.formData = function() {
              return this.text().then($);
            }), this.json = function() {
              return this.text().then(JSON.parse);
            }, this;
          }
          v.prototype.append = function(C, w) {
            C = b(C), w = h(w);
            var x = this.map[C];
            this.map[C] = x ? x + ", " + w : w;
          }, v.prototype.delete = function(C) {
            delete this.map[b(C)];
          }, v.prototype.get = function(C) {
            return C = b(C), this.has(C) ? this.map[C] : null;
          }, v.prototype.has = function(C) {
            return this.map.hasOwnProperty(b(C));
          }, v.prototype.set = function(C, w) {
            this.map[b(C)] = h(w);
          }, v.prototype.forEach = function(C, w) {
            for (var x in this.map)
              this.map.hasOwnProperty(x) && C.call(w, this.map[x], x, this);
          }, v.prototype.keys = function() {
            var C = [];
            return this.forEach(function(w, x) {
              C.push(x);
            }), f(C);
          }, v.prototype.values = function() {
            var C = [];
            return this.forEach(function(w) {
              C.push(w);
            }), f(C);
          }, v.prototype.entries = function() {
            var C = [];
            return this.forEach(function(w, x) {
              C.push([x, w]);
            }), f(C);
          }, u && (v.prototype[Symbol.iterator] = v.prototype.entries);
          var p = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function M(C, w) {
            var x, H, L = (w = w || {}).body;
            if (C instanceof M) {
              if (C.bodyUsed)
                throw new TypeError("Already read");
              this.url = C.url, this.credentials = C.credentials, w.headers || (this.headers = new v(C.headers)), this.method = C.method, this.mode = C.mode, this.signal = C.signal, L || C._bodyInit == null || (L = C._bodyInit, C.bodyUsed = !0);
            } else
              this.url = String(C);
            if (this.credentials = w.credentials || this.credentials || "same-origin", !w.headers && this.headers || (this.headers = new v(w.headers)), this.method = (x = w.method || this.method || "GET", H = x.toUpperCase(), p.indexOf(H) > -1 ? H : x), this.mode = w.mode || this.mode || null, this.signal = w.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && L)
              throw new TypeError("Body not allowed for GET or HEAD requests");
            this._initBody(L);
          }
          function $(C) {
            var w = new FormData();
            return C.trim().split("&").forEach(function(x) {
              if (x) {
                var H = x.split("="), L = H.shift().replace(/\+/g, " "), N = H.join("=").replace(/\+/g, " ");
                w.append(decodeURIComponent(L), decodeURIComponent(N));
              }
            }), w;
          }
          function Z(C, w) {
            w || (w = {}), this.type = "default", this.status = w.status === void 0 ? 200 : w.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in w ? w.statusText : "OK", this.headers = new v(w.headers), this.url = w.url || "", this._initBody(C);
          }
          M.prototype.clone = function() {
            return new M(this, { body: this._bodyInit });
          }, R.call(M.prototype), R.call(Z.prototype), Z.prototype.clone = function() {
            return new Z(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new v(this.headers), url: this.url });
          }, Z.error = function() {
            var C = new Z(null, { status: 0, statusText: "" });
            return C.type = "error", C;
          };
          var _ = [301, 302, 303, 307, 308];
          Z.redirect = function(C, w) {
            if (_.indexOf(w) === -1)
              throw new RangeError("Invalid status code");
            return new Z(null, { status: w, headers: { location: C } });
          }, o.DOMException = r.DOMException;
          try {
            new o.DOMException();
          } catch {
            o.DOMException = function(w, x) {
              this.message = w, this.name = x;
              var H = Error(w);
              this.stack = H.stack;
            }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
          }
          function y(C, w) {
            return new Promise(function(x, H) {
              var L = new M(C, w);
              if (L.signal && L.signal.aborted)
                return H(new o.DOMException("Aborted", "AbortError"));
              var N = new XMLHttpRequest();
              function P() {
                N.abort();
              }
              N.onload = function() {
                var z, O, m = { status: N.status, statusText: N.statusText, headers: (z = N.getAllResponseHeaders() || "", O = new v(), z.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(V) {
                  var Q = V.split(":"), ee = Q.shift().trim();
                  if (ee) {
                    var ne = Q.join(":").trim();
                    O.append(ee, ne);
                  }
                }), O) };
                m.url = "responseURL" in N ? N.responseURL : m.headers.get("X-Request-URL");
                var F = "response" in N ? N.response : N.responseText;
                x(new Z(F, m));
              }, N.onerror = function() {
                H(new TypeError("Network request failed"));
              }, N.ontimeout = function() {
                H(new TypeError("Network request failed"));
              }, N.onabort = function() {
                H(new o.DOMException("Aborted", "AbortError"));
              }, N.open(L.method, L.url, !0), L.credentials === "include" ? N.withCredentials = !0 : L.credentials === "omit" && (N.withCredentials = !1), "responseType" in N && s && (N.responseType = "blob"), L.headers.forEach(function(z, O) {
                N.setRequestHeader(O, z);
              }), L.signal && (L.signal.addEventListener("abort", P), N.onreadystatechange = function() {
                N.readyState === 4 && L.signal.removeEventListener("abort", P);
              }), N.send(L._bodyInit === void 0 ? null : L._bodyInit);
            });
          }
          y.polyfill = !0, r.fetch || (r.fetch = y, r.Headers = v, r.Request = M, r.Response = Z), o.Headers = v, o.Request = M, o.Response = Z, o.fetch = y;
        })({});
      })(n), delete n.fetch.polyfill, (t = n.fetch).default = n.fetch, t.fetch = n.fetch, t.Headers = n.Headers, t.Request = n.Request, t.Response = n.Response, e.exports = t;
    }, function(e, t, n) {
      (function(r) {
        const o = n(211), l = n(52), u = (s, g, c) => ({ from: u, EnvVarError: n(52), get: function(d) {
          if (!d)
            return s;
          if (arguments.length > 1)
            throw new l("It looks like you passed more than one argument to env.get(). Since env-var@6.0.0 this is no longer supported. To set a default value use env.get(TARGET).default(DEFAULT)");
          return o(s, d, g || {}, c || function() {
          });
        }, accessors: n(94), logger: n(225)(console.log, s.NODE_ENV) });
        e.exports = u(r.env);
      }).call(this, n(2));
    }, function(e, t, n) {
      var r = n(13), o = n(73), l = n(3).LEVEL, u = e.exports = function() {
        var s = this, g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        o.call(this, { objectMode: !0, highWaterMark: g.highWaterMark }), this.format = g.format, this.level = g.level, this.handleExceptions = g.handleExceptions, this.silent = g.silent, g.log && (this.log = g.log), g.logv && (this.logv = g.logv), g.close && (this.close = g.close), this.once("pipe", function(c) {
          s.levels = c.levels, s.parent = c;
        }), this.once("unpipe", function(c) {
          c === s.parent && (s.parent = null, s.close && s.close());
        });
      };
      r.inherits(u, o), u.prototype._write = function(s, g, c) {
        if (this.silent || s.exception === !0 && !this.handleExceptions)
          return c(null);
        var d = this.level || this.parent && this.parent.level;
        if (!d || this.levels[d] >= this.levels[s[l]]) {
          if (s && !this.format)
            return this.log(s, c);
          var T = void 0, b = void 0;
          try {
            b = this.format.transform(Object.assign({}, s), this.format.options);
          } catch (h) {
            T = h;
          }
          if (T || !b) {
            if (c(), T)
              throw T;
            return;
          }
          return this.log(b, c);
        }
        return c(null);
      }, u.prototype._writev = function(s, g) {
        if (this.logv) {
          var c = s.filter(this._accept, this);
          return c.length ? this.logv(c, g) : g(null);
        }
        for (var d = 0; d < s.length; d++)
          if (this._accept(s[d]))
            if (!s[d].chunk || this.format) {
              var T = void 0, b = void 0;
              try {
                b = this.format.transform(Object.assign({}, s[d].chunk), this.format.options);
              } catch (h) {
                T = h;
              }
              if (T || !b) {
                if (s[d].callback(), T)
                  throw g(null), T;
              } else
                this.log(b, s[d].callback);
            } else
              this.log(s[d].chunk, s[d].callback);
        return g(null);
      }, u.prototype._accept = function(s) {
        var g = s.chunk;
        if (this.silent)
          return !1;
        var c = this.level || this.parent && this.parent.level;
        return !(g.exception !== !0 && c && !(this.levels[c] >= this.levels[g[l]]) || !this.handleExceptions && g.exception === !0);
      }, u.prototype._nop = function() {
      };
    }, function(e, t, n) {
      (function(r) {
        const o = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, l = typeof AbortController == "function" ? AbortController : class {
          constructor() {
            this.signal = new g();
          }
          abort() {
            this.signal.dispatchEvent("abort");
          }
        }, u = typeof AbortSignal == "function", s = typeof l.AbortSignal == "function", g = u ? AbortSignal : s ? l.AbortController : class {
          constructor() {
            this.aborted = !1, this._listeners = [];
          }
          dispatchEvent(R) {
            if (R === "abort") {
              this.aborted = !0;
              const p = { type: R, target: this };
              this.onabort(p), this._listeners.forEach((M) => M(p), this);
            }
          }
          onabort() {
          }
          addEventListener(R, p) {
            R === "abort" && this._listeners.push(p);
          }
          removeEventListener(R, p) {
            R === "abort" && (this._listeners = this._listeners.filter((M) => M !== p));
          }
        }, c = /* @__PURE__ */ new Set(), d = (R, p) => {
          const M = `LRU_CACHE_OPTION_${R}`;
          h(M) && f(M, `${R} option`, `options.${p}`, I);
        }, T = (R, p) => {
          const M = `LRU_CACHE_METHOD_${R}`;
          if (h(M)) {
            const { prototype: $ } = I, { get: Z } = Object.getOwnPropertyDescriptor($, R);
            f(M, `${R} method`, `cache.${p}()`, Z);
          }
        }, b = (...R) => {
          typeof r == "object" && r && typeof r.emitWarning == "function" ? r.emitWarning(...R) : console.error(...R);
        }, h = (R) => !c.has(R), f = (R, p, M, $) => {
          c.add(R), b(`The ${p} is deprecated. Please use ${M} instead.`, "DeprecationWarning", R, $);
        }, v = (R) => R && R === Math.floor(R) && R > 0 && isFinite(R), E = (R) => v(R) ? R <= Math.pow(2, 8) ? Uint8Array : R <= Math.pow(2, 16) ? Uint16Array : R <= Math.pow(2, 32) ? Uint32Array : R <= Number.MAX_SAFE_INTEGER ? j : null : null;
        class j extends Array {
          constructor(p) {
            super(p), this.fill(0);
          }
        }
        class B {
          constructor(p) {
            if (p === 0)
              return [];
            const M = E(p);
            this.heap = new M(p), this.length = 0;
          }
          push(p) {
            this.heap[this.length++] = p;
          }
          pop() {
            return this.heap[--this.length];
          }
        }
        class I {
          constructor(p = {}) {
            const { max: M = 0, ttl: $, ttlResolution: Z = 1, ttlAutopurge: _, updateAgeOnGet: y, updateAgeOnHas: C, allowStale: w, dispose: x, disposeAfter: H, noDisposeOnSet: L, noUpdateTTL: N, maxSize: P = 0, maxEntrySize: z = 0, sizeCalculation: O, fetchMethod: m, fetchContext: F, noDeleteOnFetchRejection: V, noDeleteOnStaleGet: Q } = p, { length: ee, maxAge: ne, stale: Y } = p instanceof I ? {} : p;
            if (M !== 0 && !v(M))
              throw new TypeError("max option must be a nonnegative integer");
            const G = M ? E(M) : Array;
            if (!G)
              throw new Error("invalid max value: " + M);
            if (this.max = M, this.maxSize = P, this.maxEntrySize = z || this.maxSize, this.sizeCalculation = O || ee, this.sizeCalculation) {
              if (!this.maxSize && !this.maxEntrySize)
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
              if (typeof this.sizeCalculation != "function")
                throw new TypeError("sizeCalculation set to non-function");
            }
            if (this.fetchMethod = m || null, this.fetchMethod && typeof this.fetchMethod != "function")
              throw new TypeError("fetchMethod must be a function if specified");
            if (this.fetchContext = F, !this.fetchMethod && F !== void 0)
              throw new TypeError("cannot set fetchContext without fetchMethod");
            if (this.keyMap = /* @__PURE__ */ new Map(), this.keyList = new Array(M).fill(null), this.valList = new Array(M).fill(null), this.next = new G(M), this.prev = new G(M), this.head = 0, this.tail = 0, this.free = new B(M), this.initialFill = 1, this.size = 0, typeof x == "function" && (this.dispose = x), typeof H == "function" ? (this.disposeAfter = H, this.disposed = []) : (this.disposeAfter = null, this.disposed = null), this.noDisposeOnSet = !!L, this.noUpdateTTL = !!N, this.noDeleteOnFetchRejection = !!V, this.maxEntrySize !== 0) {
              if (this.maxSize !== 0 && !v(this.maxSize))
                throw new TypeError("maxSize must be a positive integer if specified");
              if (!v(this.maxEntrySize))
                throw new TypeError("maxEntrySize must be a positive integer if specified");
              this.initializeSizeTracking();
            }
            if (this.allowStale = !!w || !!Y, this.noDeleteOnStaleGet = !!Q, this.updateAgeOnGet = !!y, this.updateAgeOnHas = !!C, this.ttlResolution = v(Z) || Z === 0 ? Z : 1, this.ttlAutopurge = !!_, this.ttl = $ || ne || 0, this.ttl) {
              if (!v(this.ttl))
                throw new TypeError("ttl must be a positive integer if specified");
              this.initializeTTLTracking();
            }
            if (this.max === 0 && this.ttl === 0 && this.maxSize === 0)
              throw new TypeError("At least one of max, maxSize, or ttl is required");
            if (!this.ttlAutopurge && !this.max && !this.maxSize) {
              const S = "LRU_CACHE_UNBOUNDED";
              h(S) && (c.add(S), b("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", S, I));
            }
            Y && d("stale", "allowStale"), ne && d("maxAge", "ttl"), ee && d("length", "sizeCalculation");
          }
          getRemainingTTL(p) {
            return this.has(p, { updateAgeOnHas: !1 }) ? 1 / 0 : 0;
          }
          initializeTTLTracking() {
            this.ttls = new j(this.max), this.starts = new j(this.max), this.setItemTTL = ($, Z, _ = o.now()) => {
              if (this.starts[$] = Z !== 0 ? _ : 0, this.ttls[$] = Z, Z !== 0 && this.ttlAutopurge) {
                const y = setTimeout(() => {
                  this.isStale($) && this.delete(this.keyList[$]);
                }, Z + 1);
                y.unref && y.unref();
              }
            }, this.updateItemAge = ($) => {
              this.starts[$] = this.ttls[$] !== 0 ? o.now() : 0;
            };
            let p = 0;
            const M = () => {
              const $ = o.now();
              if (this.ttlResolution > 0) {
                p = $;
                const Z = setTimeout(() => p = 0, this.ttlResolution);
                Z.unref && Z.unref();
              }
              return $;
            };
            this.getRemainingTTL = ($) => {
              const Z = this.keyMap.get($);
              return Z === void 0 ? 0 : this.ttls[Z] === 0 || this.starts[Z] === 0 ? 1 / 0 : this.starts[Z] + this.ttls[Z] - (p || M());
            }, this.isStale = ($) => this.ttls[$] !== 0 && this.starts[$] !== 0 && (p || M()) - this.starts[$] > this.ttls[$];
          }
          updateItemAge(p) {
          }
          setItemTTL(p, M, $) {
          }
          isStale(p) {
            return !1;
          }
          initializeSizeTracking() {
            this.calculatedSize = 0, this.sizes = new j(this.max), this.removeItemSize = (p) => {
              this.calculatedSize -= this.sizes[p], this.sizes[p] = 0;
            }, this.requireSize = (p, M, $, Z) => {
              if (!v($)) {
                if (!Z)
                  throw new TypeError("invalid size value (must be positive integer)");
                if (typeof Z != "function")
                  throw new TypeError("sizeCalculation must be a function");
                if ($ = Z(M, p), !v($))
                  throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
              return $;
            }, this.addItemSize = (p, M) => {
              this.sizes[p] = M;
              const $ = this.maxSize - this.sizes[p];
              for (; this.calculatedSize > $; )
                this.evict(!0);
              this.calculatedSize += this.sizes[p];
            };
          }
          removeItemSize(p) {
          }
          addItemSize(p, M) {
          }
          requireSize(p, M, $, Z) {
            if ($ || Z)
              throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          *indexes({ allowStale: p = this.allowStale } = {}) {
            if (this.size)
              for (let M = this.tail; this.isValidIndex(M) && (!p && this.isStale(M) || (yield M), M !== this.head); )
                M = this.prev[M];
          }
          *rindexes({ allowStale: p = this.allowStale } = {}) {
            if (this.size)
              for (let M = this.head; this.isValidIndex(M) && (!p && this.isStale(M) || (yield M), M !== this.tail); )
                M = this.next[M];
          }
          isValidIndex(p) {
            return this.keyMap.get(this.keyList[p]) === p;
          }
          *entries() {
            for (const p of this.indexes())
              yield [this.keyList[p], this.valList[p]];
          }
          *rentries() {
            for (const p of this.rindexes())
              yield [this.keyList[p], this.valList[p]];
          }
          *keys() {
            for (const p of this.indexes())
              yield this.keyList[p];
          }
          *rkeys() {
            for (const p of this.rindexes())
              yield this.keyList[p];
          }
          *values() {
            for (const p of this.indexes())
              yield this.valList[p];
          }
          *rvalues() {
            for (const p of this.rindexes())
              yield this.valList[p];
          }
          [Symbol.iterator]() {
            return this.entries();
          }
          find(p, M = {}) {
            for (const $ of this.indexes())
              if (p(this.valList[$], this.keyList[$], this))
                return this.get(this.keyList[$], M);
          }
          forEach(p, M = this) {
            for (const $ of this.indexes())
              p.call(M, this.valList[$], this.keyList[$], this);
          }
          rforEach(p, M = this) {
            for (const $ of this.rindexes())
              p.call(M, this.valList[$], this.keyList[$], this);
          }
          get prune() {
            return T("prune", "purgeStale"), this.purgeStale;
          }
          purgeStale() {
            let p = !1;
            for (const M of this.rindexes({ allowStale: !0 }))
              this.isStale(M) && (this.delete(this.keyList[M]), p = !0);
            return p;
          }
          dump() {
            const p = [];
            for (const M of this.indexes({ allowStale: !0 })) {
              const $ = this.keyList[M], Z = this.valList[M], _ = { value: this.isBackgroundFetch(Z) ? Z.__staleWhileFetching : Z };
              if (this.ttls) {
                _.ttl = this.ttls[M];
                const y = o.now() - this.starts[M];
                _.start = Math.floor(Date.now() - y);
              }
              this.sizes && (_.size = this.sizes[M]), p.unshift([$, _]);
            }
            return p;
          }
          load(p) {
            this.clear();
            for (const [M, $] of p) {
              if ($.start) {
                const Z = Date.now() - $.start;
                $.start = o.now() - Z;
              }
              this.set(M, $.value, $);
            }
          }
          dispose(p, M, $) {
          }
          set(p, M, { ttl: $ = this.ttl, start: Z, noDisposeOnSet: _ = this.noDisposeOnSet, size: y = 0, sizeCalculation: C = this.sizeCalculation, noUpdateTTL: w = this.noUpdateTTL } = {}) {
            if (y = this.requireSize(p, M, y, C), this.maxEntrySize && y > this.maxEntrySize)
              return this;
            let x = this.size === 0 ? void 0 : this.keyMap.get(p);
            if (x === void 0)
              x = this.newIndex(), this.keyList[x] = p, this.valList[x] = M, this.keyMap.set(p, x), this.next[this.tail] = x, this.prev[x] = this.tail, this.tail = x, this.size++, this.addItemSize(x, y), w = !1;
            else {
              const H = this.valList[x];
              M !== H && (this.isBackgroundFetch(H) ? H.__abortController.abort() : _ || (this.dispose(H, p, "set"), this.disposeAfter && this.disposed.push([H, p, "set"])), this.removeItemSize(x), this.valList[x] = M, this.addItemSize(x, y)), this.moveToTail(x);
            }
            if ($ === 0 || this.ttl !== 0 || this.ttls || this.initializeTTLTracking(), w || this.setItemTTL(x, $, Z), this.disposeAfter)
              for (; this.disposed.length; )
                this.disposeAfter(...this.disposed.shift());
            return this;
          }
          newIndex() {
            return this.size === 0 ? this.tail : this.size === this.max && this.max !== 0 ? this.evict(!1) : this.free.length !== 0 ? this.free.pop() : this.initialFill++;
          }
          pop() {
            if (this.size) {
              const p = this.valList[this.head];
              return this.evict(!0), p;
            }
          }
          evict(p) {
            const M = this.head, $ = this.keyList[M], Z = this.valList[M];
            return this.isBackgroundFetch(Z) ? Z.__abortController.abort() : (this.dispose(Z, $, "evict"), this.disposeAfter && this.disposed.push([Z, $, "evict"])), this.removeItemSize(M), p && (this.keyList[M] = null, this.valList[M] = null, this.free.push(M)), this.head = this.next[M], this.keyMap.delete($), this.size--, M;
          }
          has(p, { updateAgeOnHas: M = this.updateAgeOnHas } = {}) {
            const $ = this.keyMap.get(p);
            return $ !== void 0 && !this.isStale($) && (M && this.updateItemAge($), !0);
          }
          peek(p, { allowStale: M = this.allowStale } = {}) {
            const $ = this.keyMap.get(p);
            if ($ !== void 0 && (M || !this.isStale($))) {
              const Z = this.valList[$];
              return this.isBackgroundFetch(Z) ? Z.__staleWhileFetching : Z;
            }
          }
          backgroundFetch(p, M, $, Z) {
            const _ = M === void 0 ? void 0 : this.valList[M];
            if (this.isBackgroundFetch(_))
              return _;
            const y = new l(), C = { signal: y.signal, options: $, context: Z }, w = new Promise((x) => x(this.fetchMethod(p, _, C))).then((x) => (y.signal.aborted || this.set(p, x, C.options), x), (x) => {
              if (this.valList[M] === w && (!$.noDeleteOnFetchRejection || w.__staleWhileFetching === void 0 ? this.delete(p) : this.valList[M] = w.__staleWhileFetching), w.__returned === w)
                throw x;
            });
            return w.__abortController = y, w.__staleWhileFetching = _, w.__returned = null, M === void 0 ? (this.set(p, w, C.options), M = this.keyMap.get(p)) : this.valList[M] = w, w;
          }
          isBackgroundFetch(p) {
            return p && typeof p == "object" && typeof p.then == "function" && Object.prototype.hasOwnProperty.call(p, "__staleWhileFetching") && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
          }
          async fetch(p, { allowStale: M = this.allowStale, updateAgeOnGet: $ = this.updateAgeOnGet, noDeleteOnStaleGet: Z = this.noDeleteOnStaleGet, ttl: _ = this.ttl, noDisposeOnSet: y = this.noDisposeOnSet, size: C = 0, sizeCalculation: w = this.sizeCalculation, noUpdateTTL: x = this.noUpdateTTL, noDeleteOnFetchRejection: H = this.noDeleteOnFetchRejection, fetchContext: L = this.fetchContext, forceRefresh: N = !1 } = {}) {
            if (!this.fetchMethod)
              return this.get(p, { allowStale: M, updateAgeOnGet: $, noDeleteOnStaleGet: Z });
            const P = { allowStale: M, updateAgeOnGet: $, noDeleteOnStaleGet: Z, ttl: _, noDisposeOnSet: y, size: C, sizeCalculation: w, noUpdateTTL: x, noDeleteOnFetchRejection: H };
            let z = this.keyMap.get(p);
            if (z === void 0) {
              const O = this.backgroundFetch(p, z, P, L);
              return O.__returned = O;
            }
            {
              const O = this.valList[z];
              if (this.isBackgroundFetch(O))
                return M && O.__staleWhileFetching !== void 0 ? O.__staleWhileFetching : O.__returned = O;
              if (!N && !this.isStale(z))
                return this.moveToTail(z), $ && this.updateItemAge(z), O;
              const m = this.backgroundFetch(p, z, P, L);
              return M && m.__staleWhileFetching !== void 0 ? m.__staleWhileFetching : m.__returned = m;
            }
          }
          get(p, { allowStale: M = this.allowStale, updateAgeOnGet: $ = this.updateAgeOnGet, noDeleteOnStaleGet: Z = this.noDeleteOnStaleGet } = {}) {
            const _ = this.keyMap.get(p);
            if (_ !== void 0) {
              const y = this.valList[_], C = this.isBackgroundFetch(y);
              return this.isStale(_) ? C ? M ? y.__staleWhileFetching : void 0 : (Z || this.delete(p), M ? y : void 0) : C ? void 0 : (this.moveToTail(_), $ && this.updateItemAge(_), y);
            }
          }
          connect(p, M) {
            this.prev[M] = p, this.next[p] = M;
          }
          moveToTail(p) {
            p !== this.tail && (p === this.head ? this.head = this.next[p] : this.connect(this.prev[p], this.next[p]), this.connect(this.tail, p), this.tail = p);
          }
          get del() {
            return T("del", "delete"), this.delete;
          }
          delete(p) {
            let M = !1;
            if (this.size !== 0) {
              const $ = this.keyMap.get(p);
              if ($ !== void 0)
                if (M = !0, this.size === 1)
                  this.clear();
                else {
                  this.removeItemSize($);
                  const Z = this.valList[$];
                  this.isBackgroundFetch(Z) ? Z.__abortController.abort() : (this.dispose(Z, p, "delete"), this.disposeAfter && this.disposed.push([Z, p, "delete"])), this.keyMap.delete(p), this.keyList[$] = null, this.valList[$] = null, $ === this.tail ? this.tail = this.prev[$] : $ === this.head ? this.head = this.next[$] : (this.next[this.prev[$]] = this.next[$], this.prev[this.next[$]] = this.prev[$]), this.size--, this.free.push($);
                }
            }
            if (this.disposed)
              for (; this.disposed.length; )
                this.disposeAfter(...this.disposed.shift());
            return M;
          }
          clear() {
            for (const p of this.rindexes({ allowStale: !0 })) {
              const M = this.valList[p];
              if (this.isBackgroundFetch(M))
                M.__abortController.abort();
              else {
                const $ = this.keyList[p];
                this.dispose(M, $, "delete"), this.disposeAfter && this.disposed.push([M, $, "delete"]);
              }
            }
            if (this.keyMap.clear(), this.valList.fill(null), this.keyList.fill(null), this.ttls && (this.ttls.fill(0), this.starts.fill(0)), this.sizes && this.sizes.fill(0), this.head = 0, this.tail = 0, this.initialFill = 1, this.free.length = 0, this.calculatedSize = 0, this.size = 0, this.disposed)
              for (; this.disposed.length; )
                this.disposeAfter(...this.disposed.shift());
          }
          get reset() {
            return T("reset", "clear"), this.clear;
          }
          get length() {
            return ((p, M) => {
              const $ = `LRU_CACHE_PROPERTY_${p}`;
              if (h($)) {
                const { prototype: Z } = I, { get: _ } = Object.getOwnPropertyDescriptor(Z, p);
                f($, `${p} property`, `cache.${M}`, _);
              }
            })("length", "size"), this.size;
          }
          static get AbortController() {
            return l;
          }
          static get AbortSignal() {
            return g;
          }
        }
        e.exports = I;
      }).call(this, n(2));
    }, function(e, t, n) {
      var r = n(41).Colorizer;
      e.exports = function(o) {
        return r.addColors(o.colors || o), o;
      };
    }, function(e, t, n) {
      var r = {};
      e.exports = r, r.themes = {};
      var o = n(13), l = r.styles = n(109), u = Object.defineProperties, s = new RegExp(/[\r\n]+/g);
      r.supportsColor = n(110).supportsColor, r.enabled === void 0 && (r.enabled = r.supportsColor() !== !1), r.enable = function() {
        r.enabled = !0;
      }, r.disable = function() {
        r.enabled = !1;
      }, r.stripColors = r.strip = function(E) {
        return ("" + E).replace(/\x1B\[\d+m/g, "");
      }, r.stylize = function(E, j) {
        return r.enabled ? l[j].open + E + l[j].close : E + "";
      };
      var g = /[|\\{}()[\]^$+*?.]/g;
      function c(E) {
        var j = function B() {
          return h.apply(B, arguments);
        };
        return j._styles = E, j.__proto__ = b, j;
      }
      var d, T = (d = {}, l.grey = l.gray, Object.keys(l).forEach(function(E) {
        l[E].closeRe = new RegExp(function(j) {
          if (typeof j != "string")
            throw new TypeError("Expected a string");
          return j.replace(g, "\\$&");
        }(l[E].close), "g"), d[E] = { get: function() {
          return c(this._styles.concat(E));
        } };
      }), d), b = u(function() {
      }, T);
      function h() {
        var E = Array.prototype.slice.call(arguments), j = E.map(function(M) {
          return M !== void 0 && M.constructor === String ? M : o.inspect(M);
        }).join(" ");
        if (!r.enabled || !j)
          return j;
        for (var B = j.indexOf(`
`) != -1, I = this._styles, R = I.length; R--; ) {
          var p = l[I[R]];
          j = p.open + j.replace(p.closeRe, p.open) + p.close, B && (j = j.replace(s, function(M) {
            return p.close + M + p.open;
          }));
        }
        return j;
      }
      r.setTheme = function(E) {
        if (typeof E != "string")
          for (var j in E)
            (function(B) {
              r[B] = function(I) {
                if (typeof E[B] == "object") {
                  var R = I;
                  for (var p in E[B])
                    R = r[E[B][p]](R);
                  return R;
                }
                return r[E[B]](I);
              };
            })(j);
        else
          console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
      };
      var f = function(E, j) {
        var B = j.split("");
        return (B = B.map(E)).join("");
      };
      for (var v in r.trap = n(112), r.zalgo = n(113), r.maps = {}, r.maps.america = n(114)(r), r.maps.zebra = n(115)(r), r.maps.rainbow = n(116)(r), r.maps.random = n(117)(r), r.maps)
        (function(E) {
          r[E] = function(j) {
            return f(r.maps[E], j);
          };
        })(v);
      u(r, function() {
        var E = {};
        return Object.keys(T).forEach(function(j) {
          E[j] = { get: function() {
            return c([j]);
          } };
        }), E;
      }());
    }, function(e, t) {
      e.exports = function(n) {
        return n && typeof n == "object" && typeof n.copy == "function" && typeof n.fill == "function" && typeof n.readUInt8 == "function";
      };
    }, function(e, t) {
      typeof Object.create == "function" ? e.exports = function(n, r) {
        n.super_ = r, n.prototype = Object.create(r.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } });
      } : e.exports = function(n, r) {
        n.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, n.prototype = new o(), n.prototype.constructor = n;
      };
    }, function(e, t) {
      var n = {};
      e.exports = n;
      var r = { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], grey: [90, 39], bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], blackBG: [40, 49], redBG: [41, 49], greenBG: [42, 49], yellowBG: [43, 49], blueBG: [44, 49], magentaBG: [45, 49], cyanBG: [46, 49], whiteBG: [47, 49] };
      Object.keys(r).forEach(function(o) {
        var l = r[o], u = n[o] = [];
        u.open = "\x1B[" + l[0] + "m", u.close = "\x1B[" + l[1] + "m";
      });
    }, function(e, t, n) {
      (function(r) {
        var o = n(18), l = n(111), u = r.env, s = void 0;
        function g(c) {
          return function(d) {
            return d !== 0 && { level: d, hasBasic: !0, has256: d >= 2, has16m: d >= 3 };
          }(function(d) {
            if (s === !1)
              return 0;
            if (l("color=16m") || l("color=full") || l("color=truecolor"))
              return 3;
            if (l("color=256"))
              return 2;
            if (d && !d.isTTY && s !== !0)
              return 0;
            var T = s ? 1 : 0;
            if (r.platform === "win32") {
              var b = o.release().split(".");
              return Number(r.versions.node.split(".")[0]) >= 8 && Number(b[0]) >= 10 && Number(b[2]) >= 10586 ? Number(b[2]) >= 14931 ? 3 : 2 : 1;
            }
            return "CI" in u ? ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(h) {
              return h in u;
            }) || u.CI_NAME === "codeship" ? 1 : T : "TEAMCITY_VERSION" in u ? /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(u.TEAMCITY_VERSION) ? 1 : 0 : "TERM_PROGRAM" in u ? (parseInt("445".split(".")[0], 10), 2) : /-256(color)?$/i.test("xterm-256color") ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test("xterm-256color") || "COLORTERM" in u ? 1 : T;
          }(c));
        }
        l("no-color") || l("no-colors") || l("color=false") ? s = !1 : (l("color") || l("colors") || l("color=true") || l("color=always")) && (s = !0), "FORCE_COLOR" in u && (s = u.FORCE_COLOR.length === 0 || parseInt(u.FORCE_COLOR, 10) !== 0), e.exports = { supportsColor: g, stdout: g(r.stdout), stderr: g(r.stderr) };
      }).call(this, n(2));
    }, function(e, t, n) {
      (function(r) {
        e.exports = function(o, l) {
          var u = (l = l || r.argv).indexOf("--"), s = /^-{1,2}/.test(o) ? "" : "--", g = l.indexOf(s + o);
          return g !== -1 && (u === -1 || g < u);
        };
      }).call(this, n(2));
    }, function(e, t) {
      e.exports = function(n, r) {
        var o = "";
        n = (n = n || "Run the trap, drop the bass").split("");
        var l = { a: ["@", "Ą", "Ⱥ", "Ʌ", "Δ", "Λ", "Д"], b: ["ß", "Ɓ", "Ƀ", "ɮ", "β", "฿"], c: ["©", "Ȼ", "Ͼ"], d: ["Ð", "Ɗ", "Ԁ", "ԁ", "Ԃ", "ԃ"], e: ["Ë", "ĕ", "Ǝ", "ɘ", "Σ", "ξ", "Ҽ", "੬"], f: ["Ӻ"], g: ["ɢ"], h: ["Ħ", "ƕ", "Ң", "Һ", "Ӈ", "Ԋ"], i: ["༏"], j: ["Ĵ"], k: ["ĸ", "Ҡ", "Ӄ", "Ԟ"], l: ["Ĺ"], m: ["ʍ", "Ӎ", "ӎ", "Ԡ", "ԡ", "൩"], n: ["Ñ", "ŋ", "Ɲ", "Ͷ", "Π", "Ҋ"], o: ["Ø", "õ", "ø", "Ǿ", "ʘ", "Ѻ", "ם", "۝", "๏"], p: ["Ƿ", "Ҏ"], q: ["্"], r: ["®", "Ʀ", "Ȑ", "Ɍ", "ʀ", "Я"], s: ["§", "Ϟ", "ϟ", "Ϩ"], t: ["Ł", "Ŧ", "ͳ"], u: ["Ʊ", "Ս"], v: ["ט"], w: ["Ш", "Ѡ", "Ѽ", "൰"], x: ["Ҳ", "Ӿ", "Ӽ", "ӽ"], y: ["¥", "Ұ", "Ӌ"], z: ["Ƶ", "ɀ"] };
        return n.forEach(function(u) {
          u = u.toLowerCase();
          var s = l[u] || [" "], g = Math.floor(Math.random() * s.length);
          o += l[u] !== void 0 ? l[u][g] : u;
        }), o;
      };
    }, function(e, t) {
      e.exports = function(n, r) {
        n = n || "   he is here   ";
        var o = { up: ["̍", "̎", "̄", "̅", "̿", "̑", "̆", "̐", "͒", "͗", "͑", "̇", "̈", "̊", "͂", "̓", "̈", "͊", "͋", "͌", "̃", "̂", "̌", "͐", "̀", "́", "̋", "̏", "̒", "̓", "̔", "̽", "̉", "ͣ", "ͤ", "ͥ", "ͦ", "ͧ", "ͨ", "ͩ", "ͪ", "ͫ", "ͬ", "ͭ", "ͮ", "ͯ", "̾", "͛", "͆", "̚"], down: ["̖", "̗", "̘", "̙", "̜", "̝", "̞", "̟", "̠", "̤", "̥", "̦", "̩", "̪", "̫", "̬", "̭", "̮", "̯", "̰", "̱", "̲", "̳", "̹", "̺", "̻", "̼", "ͅ", "͇", "͈", "͉", "͍", "͎", "͓", "͔", "͕", "͖", "͙", "͚", "̣"], mid: ["̕", "̛", "̀", "́", "͘", "̡", "̢", "̧", "̨", "̴", "̵", "̶", "͜", "͝", "͞", "͟", "͠", "͢", "̸", "̷", "͡", " ҉"] }, l = [].concat(o.up, o.down, o.mid);
        function u(g) {
          return Math.floor(Math.random() * g);
        }
        function s(g) {
          var c = !1;
          return l.filter(function(d) {
            c = d === g;
          }), c;
        }
        return function(g, c) {
          var d, T, b = "";
          for (T in (c = c || {}).up = c.up === void 0 || c.up, c.mid = c.mid === void 0 || c.mid, c.down = c.down === void 0 || c.down, c.size = c.size !== void 0 ? c.size : "maxi", g = g.split(""))
            if (!s(T)) {
              switch (b += g[T], d = { up: 0, down: 0, mid: 0 }, c.size) {
                case "mini":
                  d.up = u(8), d.mid = u(2), d.down = u(8);
                  break;
                case "maxi":
                  d.up = u(16) + 3, d.mid = u(4) + 1, d.down = u(64) + 3;
                  break;
                default:
                  d.up = u(8) + 1, d.mid = u(6) / 2, d.down = u(8) + 1;
              }
              var h = ["up", "mid", "down"];
              for (var f in h)
                for (var v = h[f], E = 0; E <= d[v]; E++)
                  c[v] && (b += o[v][u(o[v].length)]);
            }
          return b;
        }(n, r);
      };
    }, function(e, t) {
      e.exports = function(n) {
        return function(r, o, l) {
          if (r === " ")
            return r;
          switch (o % 3) {
            case 0:
              return n.red(r);
            case 1:
              return n.white(r);
            case 2:
              return n.blue(r);
          }
        };
      };
    }, function(e, t) {
      e.exports = function(n) {
        return function(r, o, l) {
          return o % 2 == 0 ? r : n.inverse(r);
        };
      };
    }, function(e, t) {
      e.exports = function(n) {
        var r = ["red", "yellow", "green", "blue", "magenta"];
        return function(o, l, u) {
          return o === " " ? o : n[r[l++ % r.length]](o);
        };
      };
    }, function(e, t) {
      e.exports = function(n) {
        var r = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
        return function(o, l, u) {
          return o === " " ? o : n[r[Math.round(Math.random() * (r.length - 2))]](o);
        };
      };
    }, function(e, t, n) {
      Object.defineProperty(t, "cli", { value: n(119) }), Object.defineProperty(t, "npm", { value: n(120) }), Object.defineProperty(t, "syslog", { value: n(121) });
    }, function(e, t, n) {
      t.levels = { error: 0, warn: 1, help: 2, data: 3, info: 4, debug: 5, prompt: 6, verbose: 7, input: 8, silly: 9 }, t.colors = { error: "red", warn: "yellow", help: "cyan", data: "grey", info: "green", debug: "blue", prompt: "grey", verbose: "cyan", input: "grey", silly: "magenta" };
    }, function(e, t, n) {
      t.levels = { error: 0, warn: 1, info: 2, http: 3, verbose: 4, debug: 5, silly: 6 }, t.colors = { error: "red", warn: "yellow", info: "green", http: "green", verbose: "cyan", debug: "blue", silly: "magenta" };
    }, function(e, t, n) {
      t.levels = { emerg: 0, alert: 1, crit: 2, error: 3, warning: 4, notice: 5, info: 6, debug: 7 }, t.colors = { emerg: "red", alert: "yellow", crit: "red", error: "red", warning: "red", notice: "yellow", info: "green", debug: "blue" };
    }, function(e, t, n) {
      var r = n(12);
      e.exports = r(function(o) {
        return o.message = "	".concat(o.message), o;
      });
    }, function(e, t, n) {
      function r(T, b) {
        if (!(T instanceof b))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(T, b) {
        for (var h = 0; h < b.length; h++) {
          var f = b[h];
          f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(T, f.key, f);
        }
      }
      var l = n(41).Colorizer, u = n(60).Padder, s = n(3), g = s.configs, c = s.MESSAGE, d = function() {
        function T() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          r(this, T), f.levels || (f.levels = g.npm.levels), this.colorizer = new l(f), this.padder = new u(f), this.options = f;
        }
        var b, h;
        return b = T, (h = [{ key: "transform", value: function(f, v) {
          return this.colorizer.transform(this.padder.transform(f, v), v), f[c] = "".concat(f.level, ":").concat(f.message), f;
        } }]) && o(b.prototype, h), T;
      }();
      e.exports = function(T) {
        return new d(T);
      }, e.exports.Format = d;
    }, function(e, t, n) {
      var r = n(12);
      function o(u) {
        if (u.every(l))
          return function(s) {
            for (var g = s, c = 0; c < u.length; c++)
              if (!(g = u[c].transform(g, u[c].options)))
                return !1;
            return g;
          };
      }
      function l(u) {
        if (typeof u.transform != "function")
          throw new Error(["No transform function found on format. Did you create a format instance?", "const myFormat = format(formatFn);", "const instance = myFormat();"].join(`
`));
        return !0;
      }
      e.exports = function() {
        for (var u = arguments.length, s = new Array(u), g = 0; g < u; g++)
          s[g] = arguments[g];
        var c = r(o(s)), d = c();
        return d.Format = c.Format, d;
      }, e.exports.cascade = o;
    }, function(e, t, n) {
      (function(r) {
        var o = n(12), l = n(3).MESSAGE, u = n(35);
        function s(g, c) {
          return c instanceof r ? c.toString("base64") : typeof c == "bigint" ? c.toString() : c;
        }
        e.exports = o(function(g) {
          var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return g[l] = (c.stable ? u.stableStringify : u)(g, c.replacer || s, c.space), g;
        });
      }).call(this, n(5).Buffer);
    }, function(e, t, n) {
      t.byteLength = function(T) {
        var b = c(T), h = b[0], f = b[1];
        return 3 * (h + f) / 4 - f;
      }, t.toByteArray = function(T) {
        for (var b, h = c(T), f = h[0], v = h[1], E = new l(function(R, p, M) {
          return 3 * (p + M) / 4 - M;
        }(0, f, v)), j = 0, B = v > 0 ? f - 4 : f, I = 0; I < B; I += 4)
          b = o[T.charCodeAt(I)] << 18 | o[T.charCodeAt(I + 1)] << 12 | o[T.charCodeAt(I + 2)] << 6 | o[T.charCodeAt(I + 3)], E[j++] = b >> 16 & 255, E[j++] = b >> 8 & 255, E[j++] = 255 & b;
        return v === 2 && (b = o[T.charCodeAt(I)] << 2 | o[T.charCodeAt(I + 1)] >> 4, E[j++] = 255 & b), v === 1 && (b = o[T.charCodeAt(I)] << 10 | o[T.charCodeAt(I + 1)] << 4 | o[T.charCodeAt(I + 2)] >> 2, E[j++] = b >> 8 & 255, E[j++] = 255 & b), E;
      }, t.fromByteArray = function(T) {
        for (var b, h = T.length, f = h % 3, v = [], E = 0, j = h - f; E < j; E += 16383)
          v.push(d(T, E, E + 16383 > j ? j : E + 16383));
        return f === 1 ? (b = T[h - 1], v.push(r[b >> 2] + r[b << 4 & 63] + "==")) : f === 2 && (b = (T[h - 2] << 8) + T[h - 1], v.push(r[b >> 10] + r[b >> 4 & 63] + r[b << 2 & 63] + "=")), v.join("");
      };
      for (var r = [], o = [], l = typeof Uint8Array < "u" ? Uint8Array : Array, u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, g = u.length; s < g; ++s)
        r[s] = u[s], o[u.charCodeAt(s)] = s;
      function c(T) {
        var b = T.length;
        if (b % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var h = T.indexOf("=");
        return h === -1 && (h = b), [h, h === b ? 0 : 4 - h % 4];
      }
      function d(T, b, h) {
        for (var f, v, E = [], j = b; j < h; j += 3)
          f = (T[j] << 16 & 16711680) + (T[j + 1] << 8 & 65280) + (255 & T[j + 2]), E.push(r[(v = f) >> 18 & 63] + r[v >> 12 & 63] + r[v >> 6 & 63] + r[63 & v]);
        return E.join("");
      }
      o["-".charCodeAt(0)] = 62, o["_".charCodeAt(0)] = 63;
    }, function(e, t) {
      t.read = function(n, r, o, l, u) {
        var s, g, c = 8 * u - l - 1, d = (1 << c) - 1, T = d >> 1, b = -7, h = o ? u - 1 : 0, f = o ? -1 : 1, v = n[r + h];
        for (h += f, s = v & (1 << -b) - 1, v >>= -b, b += c; b > 0; s = 256 * s + n[r + h], h += f, b -= 8)
          ;
        for (g = s & (1 << -b) - 1, s >>= -b, b += l; b > 0; g = 256 * g + n[r + h], h += f, b -= 8)
          ;
        if (s === 0)
          s = 1 - T;
        else {
          if (s === d)
            return g ? NaN : 1 / 0 * (v ? -1 : 1);
          g += Math.pow(2, l), s -= T;
        }
        return (v ? -1 : 1) * g * Math.pow(2, s - l);
      }, t.write = function(n, r, o, l, u, s) {
        var g, c, d, T = 8 * s - u - 1, b = (1 << T) - 1, h = b >> 1, f = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, v = l ? 0 : s - 1, E = l ? 1 : -1, j = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (c = isNaN(r) ? 1 : 0, g = b) : (g = Math.floor(Math.log(r) / Math.LN2), r * (d = Math.pow(2, -g)) < 1 && (g--, d *= 2), (r += g + h >= 1 ? f / d : f * Math.pow(2, 1 - h)) * d >= 2 && (g++, d /= 2), g + h >= b ? (c = 0, g = b) : g + h >= 1 ? (c = (r * d - 1) * Math.pow(2, u), g += h) : (c = r * Math.pow(2, h - 1) * Math.pow(2, u), g = 0)); u >= 8; n[o + v] = 255 & c, v += E, c /= 256, u -= 8)
          ;
        for (g = g << u | c, T += u; T > 0; n[o + v] = 255 & g, v += E, g /= 256, T -= 8)
          ;
        n[o + v - E] |= 128 * j;
      };
    }, function(e, t, n) {
      var r = n(12);
      e.exports = r(function(o, l) {
        return l.message ? (o.message = "[".concat(l.label, "] ").concat(o.message), o) : (o.label = l.label, o);
      });
    }, function(e, t, n) {
      var r = n(12), o = n(3).MESSAGE, l = n(35);
      e.exports = r(function(u) {
        var s = {};
        return u.message && (s["@message"] = u.message, delete u.message), u.timestamp && (s["@timestamp"] = u.timestamp, delete u.timestamp), s["@fields"] = u, u[o] = l(s), u;
      });
    }, function(e, t, n) {
      var r = n(12);
      function o(u, s, g) {
        var c, d, T, b = s.reduce(function(f, v) {
          return f[v] = u[v], delete u[v], f;
        }, {}), h = Object.keys(u).reduce(function(f, v) {
          return f[v] = u[v], delete u[v], f;
        }, {});
        return Object.assign(u, b, (T = h, (d = g) in (c = {}) ? Object.defineProperty(c, d, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : c[d] = T, c)), u;
      }
      function l(u, s, g) {
        return u[g] = s.reduce(function(c, d) {
          return c[d] = u[d], delete u[d], c;
        }, {}), u;
      }
      e.exports = r(function(u) {
        var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = "metadata";
        s.key && (g = s.key);
        var c = [];
        return s.fillExcept || s.fillWith || (c.push("level"), c.push("message")), s.fillExcept && (c = s.fillExcept), c.length > 0 ? o(u, c, g) : s.fillWith ? l(u, s.fillWith, g) : u;
      });
    }, function(e, t, n) {
      var r = n(13).inspect, o = n(12), l = n(3), u = l.LEVEL, s = l.MESSAGE, g = l.SPLAT;
      e.exports = o(function(c) {
        var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, T = Object.assign({}, c);
        return delete T[u], delete T[s], delete T[g], c[s] = r(T, !1, d.depth || null, d.colorize), c;
      });
    }, function(e, t, n) {
      function r(u, s) {
        for (var g = 0; g < s.length; g++) {
          var c = s[g];
          c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(u, c.key, c);
        }
      }
      var o = n(3).MESSAGE, l = function() {
        function u(c) {
          (function(d, T) {
            if (!(d instanceof T))
              throw new TypeError("Cannot call a class as a function");
          })(this, u), this.template = c;
        }
        var s, g;
        return s = u, (g = [{ key: "transform", value: function(c) {
          return c[o] = this.template(c), c;
        } }]) && r(s.prototype, g), u;
      }();
      e.exports = function(u) {
        return new l(u);
      }, e.exports.Printf = e.exports.Format = l;
    }, function(e, t, n) {
      var r = n(12), o = n(3).MESSAGE, l = n(35);
      e.exports = r(function(u) {
        var s = l(Object.assign({}, u, { level: void 0, message: void 0, splat: void 0 })), g = u.padding && u.padding[u.level] || "";
        return u[o] = s !== "{}" ? "".concat(u.level, ":").concat(g, " ").concat(u.message, " ").concat(s) : "".concat(u.level, ":").concat(g, " ").concat(u.message), u;
      });
    }, function(e, t, n) {
      function r(T) {
        return function(b) {
          if (Array.isArray(b))
            return o(b);
        }(T) || function(b) {
          if (typeof Symbol < "u" && Symbol.iterator in Object(b))
            return Array.from(b);
        }(T) || function(b, h) {
          if (b) {
            if (typeof b == "string")
              return o(b, h);
            var f = Object.prototype.toString.call(b).slice(8, -1);
            if (f === "Object" && b.constructor && (f = b.constructor.name), f === "Map" || f === "Set")
              return Array.from(b);
            if (f === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(f))
              return o(b, h);
          }
        }(T) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function o(T, b) {
        (b == null || b > T.length) && (b = T.length);
        for (var h = 0, f = new Array(b); h < b; h++)
          f[h] = T[h];
        return f;
      }
      function l(T, b) {
        for (var h = 0; h < b.length; h++) {
          var f = b[h];
          f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(T, f.key, f);
        }
      }
      var u = n(13), s = n(3).SPLAT, g = /%[scdjifoO%]/g, c = /%%/g, d = function() {
        function T(f) {
          (function(v, E) {
            if (!(v instanceof E))
              throw new TypeError("Cannot call a class as a function");
          })(this, T), this.options = f;
        }
        var b, h;
        return b = T, (h = [{ key: "_splat", value: function(f, v) {
          var E = f.message, j = f[s] || f.splat || [], B = E.match(c), I = B && B.length || 0, R = v.length - I - j.length, p = R < 0 ? j.splice(R, -1 * R) : [], M = p.length;
          if (M)
            for (var $ = 0; $ < M; $++)
              Object.assign(f, p[$]);
          return f.message = u.format.apply(u, [E].concat(r(j))), f;
        } }, { key: "transform", value: function(f) {
          var v = f.message, E = f[s] || f.splat;
          if (!E || !E.length)
            return f;
          var j = v && v.match && v.match(g);
          if (!j && (E || E.length)) {
            var B = E.length > 1 ? E.splice(0) : E, I = B.length;
            if (I)
              for (var R = 0; R < I; R++)
                Object.assign(f, B[R]);
            return f;
          }
          return j ? this._splat(f, j) : f;
        } }]) && l(b.prototype, h), T;
      }();
      e.exports = function(T) {
        return new d(T);
      };
    }, function(e, t, n) {
      var r = n(136), o = n(12);
      e.exports = o(function(l) {
        var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return u.format && (l.timestamp = typeof u.format == "function" ? u.format() : r.format(/* @__PURE__ */ new Date(), u.format)), l.timestamp || (l.timestamp = (/* @__PURE__ */ new Date()).toISOString()), u.alias && (l[u.alias] = l.timestamp), l;
      });
    }, function(e, t, n) {
      n.r(t), n.d(t, "assign", function() {
        return g;
      }), n.d(t, "format", function() {
        return y;
      }), n.d(t, "parse", function() {
        return C;
      }), n.d(t, "defaultI18n", function() {
        return b;
      }), n.d(t, "setGlobalDateI18n", function() {
        return f;
      }), n.d(t, "setGlobalDateMasks", function() {
        return _;
      });
      var r = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g, o = "[^\\s]+", l = /\[([^]*?)\]/gm;
      function u(x, H) {
        for (var L = [], N = 0, P = x.length; N < P; N++)
          L.push(x[N].substr(0, H));
        return L;
      }
      var s = function(x) {
        return function(H, L) {
          var N = L[x].map(function(P) {
            return P.toLowerCase();
          }).indexOf(H.toLowerCase());
          return N > -1 ? N : null;
        };
      };
      function g(x) {
        for (var H = [], L = 1; L < arguments.length; L++)
          H[L - 1] = arguments[L];
        for (var N = 0, P = H; N < P.length; N++) {
          var z = P[N];
          for (var O in z)
            x[O] = z[O];
        }
        return x;
      }
      var c = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], d = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], T = u(d, 3), b = { dayNamesShort: u(c, 3), dayNames: c, monthNamesShort: T, monthNames: d, amPm: ["am", "pm"], DoFn: function(x) {
        return x + ["th", "st", "nd", "rd"][x % 10 > 3 ? 0 : (x - x % 10 != 10 ? 1 : 0) * x % 10];
      } }, h = g({}, b), f = function(x) {
        return h = g(h, x);
      }, v = function(x) {
        return x.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
      }, E = function(x, H) {
        for (H === void 0 && (H = 2), x = String(x); x.length < H; )
          x = "0" + x;
        return x;
      }, j = { D: function(x) {
        return String(x.getDate());
      }, DD: function(x) {
        return E(x.getDate());
      }, Do: function(x, H) {
        return H.DoFn(x.getDate());
      }, d: function(x) {
        return String(x.getDay());
      }, dd: function(x) {
        return E(x.getDay());
      }, ddd: function(x, H) {
        return H.dayNamesShort[x.getDay()];
      }, dddd: function(x, H) {
        return H.dayNames[x.getDay()];
      }, M: function(x) {
        return String(x.getMonth() + 1);
      }, MM: function(x) {
        return E(x.getMonth() + 1);
      }, MMM: function(x, H) {
        return H.monthNamesShort[x.getMonth()];
      }, MMMM: function(x, H) {
        return H.monthNames[x.getMonth()];
      }, YY: function(x) {
        return E(String(x.getFullYear()), 4).substr(2);
      }, YYYY: function(x) {
        return E(x.getFullYear(), 4);
      }, h: function(x) {
        return String(x.getHours() % 12 || 12);
      }, hh: function(x) {
        return E(x.getHours() % 12 || 12);
      }, H: function(x) {
        return String(x.getHours());
      }, HH: function(x) {
        return E(x.getHours());
      }, m: function(x) {
        return String(x.getMinutes());
      }, mm: function(x) {
        return E(x.getMinutes());
      }, s: function(x) {
        return String(x.getSeconds());
      }, ss: function(x) {
        return E(x.getSeconds());
      }, S: function(x) {
        return String(Math.round(x.getMilliseconds() / 100));
      }, SS: function(x) {
        return E(Math.round(x.getMilliseconds() / 10), 2);
      }, SSS: function(x) {
        return E(x.getMilliseconds(), 3);
      }, a: function(x, H) {
        return x.getHours() < 12 ? H.amPm[0] : H.amPm[1];
      }, A: function(x, H) {
        return x.getHours() < 12 ? H.amPm[0].toUpperCase() : H.amPm[1].toUpperCase();
      }, ZZ: function(x) {
        var H = x.getTimezoneOffset();
        return (H > 0 ? "-" : "+") + E(100 * Math.floor(Math.abs(H) / 60) + Math.abs(H) % 60, 4);
      }, Z: function(x) {
        var H = x.getTimezoneOffset();
        return (H > 0 ? "-" : "+") + E(Math.floor(Math.abs(H) / 60), 2) + ":" + E(Math.abs(H) % 60, 2);
      } }, B = function(x) {
        return +x - 1;
      }, I = [null, "[1-9]\\d?"], R = [null, o], p = ["isPm", o, function(x, H) {
        var L = x.toLowerCase();
        return L === H.amPm[0] ? 0 : L === H.amPm[1] ? 1 : null;
      }], M = ["timezoneOffset", "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?", function(x) {
        var H = (x + "").match(/([+-]|\d\d)/gi);
        if (H) {
          var L = 60 * +H[1] + parseInt(H[2], 10);
          return H[0] === "+" ? L : -L;
        }
        return 0;
      }], $ = { D: ["day", "[1-9]\\d?"], DD: ["day", "\\d\\d"], Do: ["day", "[1-9]\\d?" + o, function(x) {
        return parseInt(x, 10);
      }], M: ["month", "[1-9]\\d?", B], MM: ["month", "\\d\\d", B], YY: ["year", "\\d\\d", function(x) {
        var H = +("" + (/* @__PURE__ */ new Date()).getFullYear()).substr(0, 2);
        return +("" + (+x > 68 ? H - 1 : H) + x);
      }], h: ["hour", "[1-9]\\d?", void 0, "isPm"], hh: ["hour", "\\d\\d", void 0, "isPm"], H: ["hour", "[1-9]\\d?"], HH: ["hour", "\\d\\d"], m: ["minute", "[1-9]\\d?"], mm: ["minute", "\\d\\d"], s: ["second", "[1-9]\\d?"], ss: ["second", "\\d\\d"], YYYY: ["year", "\\d{4}"], S: ["millisecond", "\\d", function(x) {
        return 100 * +x;
      }], SS: ["millisecond", "\\d\\d", function(x) {
        return 10 * +x;
      }], SSS: ["millisecond", "\\d{3}"], d: I, dd: I, ddd: R, dddd: R, MMM: ["month", o, s("monthNamesShort")], MMMM: ["month", o, s("monthNames")], a: p, A: p, ZZ: M, Z: M }, Z = { default: "ddd MMM DD YYYY HH:mm:ss", shortDate: "M/D/YY", mediumDate: "MMM D, YYYY", longDate: "MMMM D, YYYY", fullDate: "dddd, MMMM D, YYYY", isoDate: "YYYY-MM-DD", isoDateTime: "YYYY-MM-DDTHH:mm:ssZ", shortTime: "HH:mm", mediumTime: "HH:mm:ss", longTime: "HH:mm:ss.SSS" }, _ = function(x) {
        return g(Z, x);
      }, y = function(x, H, L) {
        if (H === void 0 && (H = Z.default), L === void 0 && (L = {}), typeof x == "number" && (x = new Date(x)), Object.prototype.toString.call(x) !== "[object Date]" || isNaN(x.getTime()))
          throw new Error("Invalid Date pass to format");
        var N = [];
        H = (H = Z[H] || H).replace(l, function(z, O) {
          return N.push(O), "@@@";
        });
        var P = g(g({}, h), L);
        return (H = H.replace(r, function(z) {
          return j[z](x, P);
        })).replace(/@@@/g, function() {
          return N.shift();
        });
      };
      function C(x, H, L) {
        if (L === void 0 && (L = {}), typeof H != "string")
          throw new Error("Invalid format in fecha parse");
        if (H = Z[H] || H, x.length > 1e3)
          return null;
        var N = { year: (/* @__PURE__ */ new Date()).getFullYear(), month: 0, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0, isPm: null, timezoneOffset: null }, P = [], z = [], O = H.replace(l, function(K, re) {
          return z.push(v(re)), "@@@";
        }), m = {}, F = {};
        O = v(O).replace(r, function(K) {
          var re = $[K], se = re[0], fe = re[1], we = re[3];
          if (m[se])
            throw new Error("Invalid format. " + se + " specified twice in format");
          return m[se] = !0, we && (F[we] = !0), P.push(re), "(" + fe + ")";
        }), Object.keys(F).forEach(function(K) {
          if (!m[K])
            throw new Error("Invalid format. " + K + " is required in specified format");
        }), O = O.replace(/@@@/g, function() {
          return z.shift();
        });
        var V = x.match(new RegExp(O, "i"));
        if (!V)
          return null;
        for (var Q = g(g({}, h), L), ee = 1; ee < V.length; ee++) {
          var ne = P[ee - 1], Y = ne[0], G = ne[2], S = G ? G(V[ee], Q) : +V[ee];
          if (S == null)
            return null;
          N[Y] = S;
        }
        N.isPm === 1 && N.hour != null && +N.hour != 12 ? N.hour = +N.hour + 12 : N.isPm === 0 && +N.hour == 12 && (N.hour = 0);
        for (var A = new Date(N.year, N.month, N.day, N.hour, N.minute, N.second, N.millisecond), U = [["month", "getMonth"], ["day", "getDate"], ["hour", "getHours"], ["minute", "getMinutes"], ["second", "getSeconds"]], J = (ee = 0, U.length); ee < J; ee++)
          if (m[U[ee][0]] && N[U[ee][0]] !== A[U[ee][1]]())
            return null;
        return N.timezoneOffset == null ? A : new Date(Date.UTC(N.year, N.month, N.day, N.hour, N.minute - N.timezoneOffset, N.second, N.millisecond));
      }
      var w = { format: y, parse: C, defaultI18n: b, setGlobalDateI18n: f, setGlobalDateMasks: _ };
      t.default = w;
    }, function(e, t, n) {
      var r = n(59), o = n(12), l = n(3).MESSAGE;
      e.exports = o(function(u, s) {
        return s.level !== !1 && (u.level = r.strip(u.level)), s.message !== !1 && (u.message = r.strip(u.message)), s.raw !== !1 && u[l] && (u[l] = r.strip(u[l])), u;
      });
    }, function(e) {
      e.exports = JSON.parse('{"name":"winston","description":"A logger for just about everything.","version":"3.3.3","author":"Charlie Robbins <charlie.robbins@gmail.com>","maintainers":["Jarrett Cruger <jcrugzz@gmail.com>","Chris Alderson <chrisalderson@protonmail.com>","David Hyde <dabh@stanford.edu>"],"repository":{"type":"git","url":"https://github.com/winstonjs/winston.git"},"keywords":["winston","logger","logging","logs","sysadmin","bunyan","pino","loglevel","tools","json","stream"],"dependencies":{"async":"^3.1.0","@dabh/diagnostics":"^2.0.2","is-stream":"^2.0.0","logform":"^2.2.0","one-time":"^1.0.0","readable-stream":"^3.4.0","stack-trace":"0.0.x","triple-beam":"^1.3.0","winston-transport":"^4.4.0"},"devDependencies":{"@babel/cli":"^7.10.3","@babel/core":"^7.10.3","@babel/preset-env":"^7.10.3","@types/node":"^14.0.13","abstract-winston-transport":"^0.5.1","assume":"^2.2.0","colors":"^1.4.0","cross-spawn-async":"^2.2.5","eslint-config-populist":"^4.2.0","hock":"^1.4.1","mocha":"^8.0.1","nyc":"^15.1.0","rimraf":"^3.0.2","split2":"^3.1.1","std-mocks":"^1.0.1","through2":"^3.0.1","winston-compat":"^0.1.5"},"main":"./lib/winston","browser":"./dist/winston","types":"./index.d.ts","scripts":{"lint":"populist lib/*.js lib/winston/*.js lib/winston/**/*.js","pretest":"npm run lint","test":"nyc --reporter=text --reporter lcov npm run test:mocha","test:mocha":"mocha test/*.test.js test/**/*.test.js --exit","build":"./node_modules/.bin/rimraf dist && babel lib -d dist","prepublishOnly":"npm run build"},"engines":{"node":">= 6.4.0"},"license":"MIT"}');
    }, function(e, t, n) {
      Object.defineProperty(t, "Console", { configurable: !0, enumerable: !0, get: function() {
        return n(140);
      } }), Object.defineProperty(t, "File", { configurable: !0, enumerable: !0, get: function() {
        return n(149);
      } }), Object.defineProperty(t, "Http", { configurable: !0, enumerable: !0, get: function() {
        return n(189);
      } }), Object.defineProperty(t, "Stream", { configurable: !0, enumerable: !0, get: function() {
        return n(201);
      } });
    }, function(e, t, n) {
      (function(r) {
        function o(E) {
          return (o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(j) {
            return typeof j;
          } : function(j) {
            return j && typeof Symbol == "function" && j.constructor === Symbol && j !== Symbol.prototype ? "symbol" : typeof j;
          })(E);
        }
        function l(E, j) {
          if (!(E instanceof j))
            throw new TypeError("Cannot call a class as a function");
        }
        function u(E, j) {
          for (var B = 0; B < j.length; B++) {
            var I = j[B];
            I.enumerable = I.enumerable || !1, I.configurable = !0, "value" in I && (I.writable = !0), Object.defineProperty(E, I.key, I);
          }
        }
        function s(E, j) {
          return (s = Object.setPrototypeOf || function(B, I) {
            return B.__proto__ = I, B;
          })(E, j);
        }
        function g(E) {
          var j = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return !1;
            if (typeof Proxy == "function")
              return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          }();
          return function() {
            var B, I = d(E);
            if (j) {
              var R = d(this).constructor;
              B = Reflect.construct(I, arguments, R);
            } else
              B = I.apply(this, arguments);
            return c(this, B);
          };
        }
        function c(E, j) {
          return !j || o(j) !== "object" && typeof j != "function" ? function(B) {
            if (B === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return B;
          }(E) : j;
        }
        function d(E) {
          return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(j) {
            return j.__proto__ || Object.getPrototypeOf(j);
          })(E);
        }
        var T = n(18), b = n(3), h = b.LEVEL, f = b.MESSAGE, v = n(20);
        e.exports = function(E) {
          (function(p, M) {
            if (typeof M != "function" && M !== null)
              throw new TypeError("Super expression must either be null or a function");
            p.prototype = Object.create(M && M.prototype, { constructor: { value: p, writable: !0, configurable: !0 } }), M && s(p, M);
          })(R, E);
          var j, B, I = g(R);
          function R() {
            var p, M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return l(this, R), (p = I.call(this, M)).name = M.name || "console", p.stderrLevels = p._stringArrayToSet(M.stderrLevels), p.consoleWarnLevels = p._stringArrayToSet(M.consoleWarnLevels), p.eol = M.eol || T.EOL, p.setMaxListeners(30), p;
          }
          return j = R, (B = [{ key: "log", value: function(p, M) {
            var $ = this;
            return r(function() {
              return $.emit("logged", p);
            }), this.stderrLevels[p[h]] ? (console._stderr ? console._stderr.write("".concat(p[f]).concat(this.eol)) : console.error(p[f]), void (M && M())) : this.consoleWarnLevels[p[h]] ? (console._stderr ? console._stderr.write("".concat(p[f]).concat(this.eol)) : console.warn(p[f]), void (M && M())) : (console._stdout ? console._stdout.write("".concat(p[f]).concat(this.eol)) : console.log(p[f]), void (M && M()));
          } }, { key: "_stringArrayToSet", value: function(p, M) {
            if (!p)
              return {};
            if (M = M || "Cannot make set from type other than Array of string elements", !Array.isArray(p))
              throw new Error(M);
            return p.reduce(function($, Z) {
              if (typeof Z != "string")
                throw new Error(M);
              return $[Z] = !0, $;
            }, {});
          } }]) && u(j.prototype, B), R;
        }(v);
      }).call(this, n(15).setImmediate);
    }, function(e, t, n) {
      (function(r, o) {
        (function(l, u) {
          if (!l.setImmediate) {
            var s, g, c, d, T, b = 1, h = {}, f = !1, v = l.document, E = Object.getPrototypeOf && Object.getPrototypeOf(l);
            E = E && E.setTimeout ? E : l, {}.toString.call(l.process) === "[object process]" ? s = function(I) {
              o.nextTick(function() {
                B(I);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var I = !0, R = l.onmessage;
                return l.onmessage = function() {
                  I = !1;
                }, l.postMessage("", "*"), l.onmessage = R, I;
              }
            }() ? (d = "setImmediate$" + Math.random() + "$", T = function(I) {
              I.source === l && typeof I.data == "string" && I.data.indexOf(d) === 0 && B(+I.data.slice(d.length));
            }, l.addEventListener ? l.addEventListener("message", T, !1) : l.attachEvent("onmessage", T), s = function(I) {
              l.postMessage(d + I, "*");
            }) : l.MessageChannel ? ((c = new MessageChannel()).port1.onmessage = function(I) {
              B(I.data);
            }, s = function(I) {
              c.port2.postMessage(I);
            }) : v && "onreadystatechange" in v.createElement("script") ? (g = v.documentElement, s = function(I) {
              var R = v.createElement("script");
              R.onreadystatechange = function() {
                B(I), R.onreadystatechange = null, g.removeChild(R), R = null;
              }, g.appendChild(R);
            }) : s = function(I) {
              setTimeout(B, 0, I);
            }, E.setImmediate = function(I) {
              typeof I != "function" && (I = new Function("" + I));
              for (var R = new Array(arguments.length - 1), p = 0; p < R.length; p++)
                R[p] = arguments[p + 1];
              var M = { callback: I, args: R };
              return h[b] = M, s(b), b++;
            }, E.clearImmediate = j;
          }
          function j(I) {
            delete h[I];
          }
          function B(I) {
            if (f)
              setTimeout(B, 0, I);
            else {
              var R = h[I];
              if (R) {
                f = !0;
                try {
                  (function(p) {
                    var M = p.callback, $ = p.args;
                    switch ($.length) {
                      case 0:
                        M();
                        break;
                      case 1:
                        M($[0]);
                        break;
                      case 2:
                        M($[0], $[1]);
                        break;
                      case 3:
                        M($[0], $[1], $[2]);
                        break;
                      default:
                        M.apply(void 0, $);
                    }
                  })(R);
                } finally {
                  j(I), f = !1;
                }
              }
            }
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, n(6), n(2));
    }, function(e, t, n) {
      e.exports = n(62);
    }, function(e, t, n) {
      (function(r, o) {
        var l = n(16);
        e.exports = R;
        var u, s = n(42);
        R.ReadableState = I, n(21).EventEmitter;
        var g = function(O, m) {
          return O.listeners(m).length;
        }, c = n(63), d = n(44).Buffer, T = r.Uint8Array || function() {
        }, b = Object.create(n(17));
        b.inherits = n(7);
        var h = n(144), f = void 0;
        f = h && h.debuglog ? h.debuglog("stream") : function() {
        };
        var v, E = n(145), j = n(64);
        b.inherits(R, c);
        var B = ["error", "close", "destroy", "pause", "resume"];
        function I(O, m) {
          O = O || {};
          var F = m instanceof (u = u || n(36));
          this.objectMode = !!O.objectMode, F && (this.objectMode = this.objectMode || !!O.readableObjectMode);
          var V = O.highWaterMark, Q = O.readableHighWaterMark, ee = this.objectMode ? 16 : 16384;
          this.highWaterMark = V || V === 0 ? V : F && (Q || Q === 0) ? Q : ee, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new E(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = O.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, O.encoding && (v || (v = n(22).StringDecoder), this.decoder = new v(O.encoding), this.encoding = O.encoding);
        }
        function R(O) {
          if (u = u || n(36), !(this instanceof R))
            return new R(O);
          this._readableState = new I(O, this), this.readable = !0, O && (typeof O.read == "function" && (this._read = O.read), typeof O.destroy == "function" && (this._destroy = O.destroy)), c.call(this);
        }
        function p(O, m, F, V, Q) {
          var ee, ne = O._readableState;
          return m === null ? (ne.reading = !1, function(Y, G) {
            if (!G.ended) {
              if (G.decoder) {
                var S = G.decoder.end();
                S && S.length && (G.buffer.push(S), G.length += G.objectMode ? 1 : S.length);
              }
              G.ended = !0, Z(Y);
            }
          }(O, ne)) : (Q || (ee = function(Y, G) {
            var S;
            A = G, d.isBuffer(A) || A instanceof T || typeof G == "string" || G === void 0 || Y.objectMode || (S = new TypeError("Invalid non-string/buffer chunk"));
            var A;
            return S;
          }(ne, m)), ee ? O.emit("error", ee) : ne.objectMode || m && m.length > 0 ? (typeof m == "string" || ne.objectMode || Object.getPrototypeOf(m) === d.prototype || (m = function(Y) {
            return d.from(Y);
          }(m)), V ? ne.endEmitted ? O.emit("error", new Error("stream.unshift() after end event")) : M(O, ne, m, !0) : ne.ended ? O.emit("error", new Error("stream.push() after EOF")) : (ne.reading = !1, ne.decoder && !F ? (m = ne.decoder.write(m), ne.objectMode || m.length !== 0 ? M(O, ne, m, !1) : y(O, ne)) : M(O, ne, m, !1))) : V || (ne.reading = !1)), function(Y) {
            return !Y.ended && (Y.needReadable || Y.length < Y.highWaterMark || Y.length === 0);
          }(ne);
        }
        function M(O, m, F, V) {
          m.flowing && m.length === 0 && !m.sync ? (O.emit("data", F), O.read(0)) : (m.length += m.objectMode ? 1 : F.length, V ? m.buffer.unshift(F) : m.buffer.push(F), m.needReadable && Z(O)), y(O, m);
        }
        Object.defineProperty(R.prototype, "destroyed", { get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(O) {
          this._readableState && (this._readableState.destroyed = O);
        } }), R.prototype.destroy = j.destroy, R.prototype._undestroy = j.undestroy, R.prototype._destroy = function(O, m) {
          this.push(null), m(O);
        }, R.prototype.push = function(O, m) {
          var F, V = this._readableState;
          return V.objectMode ? F = !0 : typeof O == "string" && ((m = m || V.defaultEncoding) !== V.encoding && (O = d.from(O, m), m = ""), F = !0), p(this, O, m, !1, F);
        }, R.prototype.unshift = function(O) {
          return p(this, O, null, !0, !1);
        }, R.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        }, R.prototype.setEncoding = function(O) {
          return v || (v = n(22).StringDecoder), this._readableState.decoder = new v(O), this._readableState.encoding = O, this;
        };
        function $(O, m) {
          return O <= 0 || m.length === 0 && m.ended ? 0 : m.objectMode ? 1 : O != O ? m.flowing && m.length ? m.buffer.head.data.length : m.length : (O > m.highWaterMark && (m.highWaterMark = function(F) {
            return F >= 8388608 ? F = 8388608 : (F--, F |= F >>> 1, F |= F >>> 2, F |= F >>> 4, F |= F >>> 8, F |= F >>> 16, F++), F;
          }(O)), O <= m.length ? O : m.ended ? m.length : (m.needReadable = !0, 0));
        }
        function Z(O) {
          var m = O._readableState;
          m.needReadable = !1, m.emittedReadable || (f("emitReadable", m.flowing), m.emittedReadable = !0, m.sync ? l.nextTick(_, O) : _(O));
        }
        function _(O) {
          f("emit readable"), O.emit("readable"), H(O);
        }
        function y(O, m) {
          m.readingMore || (m.readingMore = !0, l.nextTick(C, O, m));
        }
        function C(O, m) {
          for (var F = m.length; !m.reading && !m.flowing && !m.ended && m.length < m.highWaterMark && (f("maybeReadMore read 0"), O.read(0), F !== m.length); )
            F = m.length;
          m.readingMore = !1;
        }
        function w(O) {
          f("readable nexttick read 0"), O.read(0);
        }
        function x(O, m) {
          m.reading || (f("resume read 0"), O.read(0)), m.resumeScheduled = !1, m.awaitDrain = 0, O.emit("resume"), H(O), m.flowing && !m.reading && O.read(0);
        }
        function H(O) {
          var m = O._readableState;
          for (f("flow", m.flowing); m.flowing && O.read() !== null; )
            ;
        }
        function L(O, m) {
          return m.length === 0 ? null : (m.objectMode ? F = m.buffer.shift() : !O || O >= m.length ? (F = m.decoder ? m.buffer.join("") : m.buffer.length === 1 ? m.buffer.head.data : m.buffer.concat(m.length), m.buffer.clear()) : F = function(V, Q, ee) {
            var ne;
            return V < Q.head.data.length ? (ne = Q.head.data.slice(0, V), Q.head.data = Q.head.data.slice(V)) : ne = V === Q.head.data.length ? Q.shift() : ee ? function(Y, G) {
              var S = G.head, A = 1, U = S.data;
              for (Y -= U.length; S = S.next; ) {
                var J = S.data, K = Y > J.length ? J.length : Y;
                if (K === J.length ? U += J : U += J.slice(0, Y), (Y -= K) === 0) {
                  K === J.length ? (++A, S.next ? G.head = S.next : G.head = G.tail = null) : (G.head = S, S.data = J.slice(K));
                  break;
                }
                ++A;
              }
              return G.length -= A, U;
            }(V, Q) : function(Y, G) {
              var S = d.allocUnsafe(Y), A = G.head, U = 1;
              for (A.data.copy(S), Y -= A.data.length; A = A.next; ) {
                var J = A.data, K = Y > J.length ? J.length : Y;
                if (J.copy(S, S.length - Y, 0, K), (Y -= K) === 0) {
                  K === J.length ? (++U, A.next ? G.head = A.next : G.head = G.tail = null) : (G.head = A, A.data = J.slice(K));
                  break;
                }
                ++U;
              }
              return G.length -= U, S;
            }(V, Q), ne;
          }(O, m.buffer, m.decoder), F);
          var F;
        }
        function N(O) {
          var m = O._readableState;
          if (m.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          m.endEmitted || (m.ended = !0, l.nextTick(P, m, O));
        }
        function P(O, m) {
          O.endEmitted || O.length !== 0 || (O.endEmitted = !0, m.readable = !1, m.emit("end"));
        }
        function z(O, m) {
          for (var F = 0, V = O.length; F < V; F++)
            if (O[F] === m)
              return F;
          return -1;
        }
        R.prototype.read = function(O) {
          f("read", O), O = parseInt(O, 10);
          var m = this._readableState, F = O;
          if (O !== 0 && (m.emittedReadable = !1), O === 0 && m.needReadable && (m.length >= m.highWaterMark || m.ended))
            return f("read: emitReadable", m.length, m.ended), m.length === 0 && m.ended ? N(this) : Z(this), null;
          if ((O = $(O, m)) === 0 && m.ended)
            return m.length === 0 && N(this), null;
          var V, Q = m.needReadable;
          return f("need readable", Q), (m.length === 0 || m.length - O < m.highWaterMark) && f("length less than watermark", Q = !0), m.ended || m.reading ? f("reading or ended", Q = !1) : Q && (f("do read"), m.reading = !0, m.sync = !0, m.length === 0 && (m.needReadable = !0), this._read(m.highWaterMark), m.sync = !1, m.reading || (O = $(F, m))), (V = O > 0 ? L(O, m) : null) === null ? (m.needReadable = !0, O = 0) : m.length -= O, m.length === 0 && (m.ended || (m.needReadable = !0), F !== O && m.ended && N(this)), V !== null && this.emit("data", V), V;
        }, R.prototype._read = function(O) {
          this.emit("error", new Error("_read() is not implemented"));
        }, R.prototype.pipe = function(O, m) {
          var F = this, V = this._readableState;
          switch (V.pipesCount) {
            case 0:
              V.pipes = O;
              break;
            case 1:
              V.pipes = [V.pipes, O];
              break;
            default:
              V.pipes.push(O);
          }
          V.pipesCount += 1, f("pipe count=%d opts=%j", V.pipesCount, m);
          var Q = (!m || m.end !== !1) && O !== o.stdout && O !== o.stderr ? ne : re;
          function ee(se, fe) {
            f("onunpipe"), se === F && fe && fe.hasUnpiped === !1 && (fe.hasUnpiped = !0, f("cleanup"), O.removeListener("close", J), O.removeListener("finish", K), O.removeListener("drain", Y), O.removeListener("error", U), O.removeListener("unpipe", ee), F.removeListener("end", ne), F.removeListener("end", re), F.removeListener("data", A), G = !0, !V.awaitDrain || O._writableState && !O._writableState.needDrain || Y());
          }
          function ne() {
            f("onend"), O.end();
          }
          V.endEmitted ? l.nextTick(Q) : F.once("end", Q), O.on("unpipe", ee);
          var Y = function(se) {
            return function() {
              var fe = se._readableState;
              f("pipeOnDrain", fe.awaitDrain), fe.awaitDrain && fe.awaitDrain--, fe.awaitDrain === 0 && g(se, "data") && (fe.flowing = !0, H(se));
            };
          }(F);
          O.on("drain", Y);
          var G = !1, S = !1;
          function A(se) {
            f("ondata"), S = !1, O.write(se) !== !1 || S || ((V.pipesCount === 1 && V.pipes === O || V.pipesCount > 1 && z(V.pipes, O) !== -1) && !G && (f("false write response, pause", F._readableState.awaitDrain), F._readableState.awaitDrain++, S = !0), F.pause());
          }
          function U(se) {
            f("onerror", se), re(), O.removeListener("error", U), g(O, "error") === 0 && O.emit("error", se);
          }
          function J() {
            O.removeListener("finish", K), re();
          }
          function K() {
            f("onfinish"), O.removeListener("close", J), re();
          }
          function re() {
            f("unpipe"), F.unpipe(O);
          }
          return F.on("data", A), function(se, fe, we) {
            if (typeof se.prependListener == "function")
              return se.prependListener(fe, we);
            se._events && se._events[fe] ? s(se._events[fe]) ? se._events[fe].unshift(we) : se._events[fe] = [we, se._events[fe]] : se.on(fe, we);
          }(O, "error", U), O.once("close", J), O.once("finish", K), O.emit("pipe", F), V.flowing || (f("pipe resume"), F.resume()), O;
        }, R.prototype.unpipe = function(O) {
          var m = this._readableState, F = { hasUnpiped: !1 };
          if (m.pipesCount === 0)
            return this;
          if (m.pipesCount === 1)
            return O && O !== m.pipes || (O || (O = m.pipes), m.pipes = null, m.pipesCount = 0, m.flowing = !1, O && O.emit("unpipe", this, F)), this;
          if (!O) {
            var V = m.pipes, Q = m.pipesCount;
            m.pipes = null, m.pipesCount = 0, m.flowing = !1;
            for (var ee = 0; ee < Q; ee++)
              V[ee].emit("unpipe", this, F);
            return this;
          }
          var ne = z(m.pipes, O);
          return ne === -1 || (m.pipes.splice(ne, 1), m.pipesCount -= 1, m.pipesCount === 1 && (m.pipes = m.pipes[0]), O.emit("unpipe", this, F)), this;
        }, R.prototype.on = function(O, m) {
          var F = c.prototype.on.call(this, O, m);
          if (O === "data")
            this._readableState.flowing !== !1 && this.resume();
          else if (O === "readable") {
            var V = this._readableState;
            V.endEmitted || V.readableListening || (V.readableListening = V.needReadable = !0, V.emittedReadable = !1, V.reading ? V.length && Z(this) : l.nextTick(w, this));
          }
          return F;
        }, R.prototype.addListener = R.prototype.on, R.prototype.resume = function() {
          var O = this._readableState;
          return O.flowing || (f("resume"), O.flowing = !0, function(m, F) {
            F.resumeScheduled || (F.resumeScheduled = !0, l.nextTick(x, m, F));
          }(this, O)), this;
        }, R.prototype.pause = function() {
          return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        }, R.prototype.wrap = function(O) {
          var m = this, F = this._readableState, V = !1;
          for (var Q in O.on("end", function() {
            if (f("wrapped end"), F.decoder && !F.ended) {
              var ne = F.decoder.end();
              ne && ne.length && m.push(ne);
            }
            m.push(null);
          }), O.on("data", function(ne) {
            f("wrapped data"), F.decoder && (ne = F.decoder.write(ne)), F.objectMode && ne == null || (F.objectMode || ne && ne.length) && (m.push(ne) || (V = !0, O.pause()));
          }), O)
            this[Q] === void 0 && typeof O[Q] == "function" && (this[Q] = function(ne) {
              return function() {
                return O[ne].apply(O, arguments);
              };
            }(Q));
          for (var ee = 0; ee < B.length; ee++)
            O.on(B[ee], this.emit.bind(this, B[ee]));
          return this._read = function(ne) {
            f("wrapped _read", ne), V && (V = !1, O.resume());
          }, this;
        }, Object.defineProperty(R.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
          return this._readableState.highWaterMark;
        } }), R._fromList = L;
      }).call(this, n(6), n(2));
    }, function(e, t) {
    }, function(e, t, n) {
      var r = n(44).Buffer, o = n(146);
      e.exports = function() {
        function l() {
          (function(u, s) {
            if (!(u instanceof s))
              throw new TypeError("Cannot call a class as a function");
          })(this, l), this.head = null, this.tail = null, this.length = 0;
        }
        return l.prototype.push = function(u) {
          var s = { data: u, next: null };
          this.length > 0 ? this.tail.next = s : this.head = s, this.tail = s, ++this.length;
        }, l.prototype.unshift = function(u) {
          var s = { data: u, next: this.head };
          this.length === 0 && (this.tail = s), this.head = s, ++this.length;
        }, l.prototype.shift = function() {
          if (this.length !== 0) {
            var u = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, u;
          }
        }, l.prototype.clear = function() {
          this.head = this.tail = null, this.length = 0;
        }, l.prototype.join = function(u) {
          if (this.length === 0)
            return "";
          for (var s = this.head, g = "" + s.data; s = s.next; )
            g += u + s.data;
          return g;
        }, l.prototype.concat = function(u) {
          if (this.length === 0)
            return r.alloc(0);
          if (this.length === 1)
            return this.head.data;
          for (var s, g, c, d = r.allocUnsafe(u >>> 0), T = this.head, b = 0; T; )
            s = T.data, g = d, c = b, s.copy(g, c), b += T.data.length, T = T.next;
          return d;
        }, l;
      }(), o && o.inspect && o.inspect.custom && (e.exports.prototype[o.inspect.custom] = function() {
        var l = o.inspect({ length: this.length });
        return this.constructor.name + " " + l;
      });
    }, function(e, t) {
    }, function(e, t, n) {
      var r = n(5), o = r.Buffer;
      function l(s, g) {
        for (var c in s)
          g[c] = s[c];
      }
      function u(s, g, c) {
        return o(s, g, c);
      }
      o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = r : (l(r, t), t.Buffer = u), l(o, u), u.from = function(s, g, c) {
        if (typeof s == "number")
          throw new TypeError("Argument must not be a number");
        return o(s, g, c);
      }, u.alloc = function(s, g, c) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        var d = o(s);
        return g !== void 0 ? typeof c == "string" ? d.fill(g, c) : d.fill(g) : d.fill(0), d;
      }, u.allocUnsafe = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return o(s);
      }, u.allocUnsafeSlow = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return r.SlowBuffer(s);
      };
    }, function(e, t, n) {
      var r = n(13), o = n(3).LEVEL, l = n(20), u = e.exports = function() {
        var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (l.call(this, s), !s.transport || typeof s.transport.log != "function")
          throw new Error("Invalid transport, must be an object with a log method.");
        function g(c) {
          this.emit("error", c, this.transport);
        }
        this.transport = s.transport, this.level = this.level || s.transport.level, this.handleExceptions = this.handleExceptions || s.transport.handleExceptions, this._deprecated(), this.transport.__winstonError || (this.transport.__winstonError = g.bind(this), this.transport.on("error", this.transport.__winstonError));
      };
      r.inherits(u, l), u.prototype._write = function(s, g, c) {
        if (this.silent || s.exception === !0 && !this.handleExceptions)
          return c(null);
        (!this.level || this.levels[this.level] >= this.levels[s[o]]) && this.transport.log(s[o], s.message, s, this._nop), c(null);
      }, u.prototype._writev = function(s, g) {
        for (var c = 0; c < s.length; c++)
          this._accept(s[c]) && (this.transport.log(s[c].chunk[o], s[c].chunk.message, s[c].chunk, this._nop), s[c].callback());
        return g(null);
      }, u.prototype._deprecated = function() {
        console.error([this.transport.name + " is a legacy winston transport. Consider upgrading: ", "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"].join(`
`));
      }, u.prototype.close = function() {
        this.transport.close && this.transport.close(), this.transport.__winstonError && (this.transport.removeListener("error", this.transport.__winstonError), this.transport.__winstonError = null);
      };
    }, function(e, t, n) {
      (function(r, o) {
        function l(_) {
          return (l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y) {
            return typeof y;
          } : function(y) {
            return y && typeof Symbol == "function" && y.constructor === Symbol && y !== Symbol.prototype ? "symbol" : typeof y;
          })(_);
        }
        function u(_, y) {
          if (!(_ instanceof y))
            throw new TypeError("Cannot call a class as a function");
        }
        function s(_, y) {
          for (var C = 0; C < y.length; C++) {
            var w = y[C];
            w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(_, w.key, w);
          }
        }
        function g(_, y) {
          return (g = Object.setPrototypeOf || function(C, w) {
            return C.__proto__ = w, C;
          })(_, y);
        }
        function c(_) {
          var y = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return !1;
            if (typeof Proxy == "function")
              return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          }();
          return function() {
            var C, w = b(_);
            if (y) {
              var x = b(this).constructor;
              C = Reflect.construct(w, arguments, x);
            } else
              C = w.apply(this, arguments);
            return d(this, C);
          };
        }
        function d(_, y) {
          return !y || l(y) !== "object" && typeof y != "function" ? T(_) : y;
        }
        function T(_) {
          if (_ === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return _;
        }
        function b(_) {
          return (b = Object.setPrototypeOf ? Object.getPrototypeOf : function(y) {
            return y.__proto__ || Object.getPrototypeOf(y);
          })(_);
        }
        var h = n(65), f = n(56), v = n(150), E = n(160), j = n(3).MESSAGE, B = n(32), I = B.Stream, R = B.PassThrough, p = n(20), M = n(38)("winston:file"), $ = n(18), Z = n(188);
        e.exports = function(_) {
          (function(H, L) {
            if (typeof L != "function" && L !== null)
              throw new TypeError("Super expression must either be null or a function");
            H.prototype = Object.create(L && L.prototype, { constructor: { value: H, writable: !0, configurable: !0 } }), L && g(H, L);
          })(x, _);
          var y, C, w = c(x);
          function x() {
            var H, L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            function N(P) {
              for (var z = arguments.length, O = new Array(z > 1 ? z - 1 : 0), m = 1; m < z; m++)
                O[m - 1] = arguments[m];
              O.slice(1).forEach(function(F) {
                if (L[F])
                  throw new Error("Cannot set ".concat(F, " and ").concat(P, " together"));
              });
            }
            if (u(this, x), (H = w.call(this, L)).name = L.name || "file", H._stream = new R(), H._stream.setMaxListeners(30), H._onError = H._onError.bind(T(H)), L.filename || L.dirname)
              N("filename or dirname", "stream"), H._basename = H.filename = L.filename ? f.basename(L.filename) : "winston.log", H.dirname = L.dirname || f.dirname(L.filename), H.options = L.options || { flags: "a" };
            else {
              if (!L.stream)
                throw new Error("Cannot log to file without filename or stream.");
              console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream"), N("stream", "filename", "maxsize"), H._dest = H._stream.pipe(H._setupStream(L.stream)), H.dirname = f.dirname(H._dest.path);
            }
            return H.maxsize = L.maxsize || null, H.rotationFormat = L.rotationFormat || !1, H.zippedArchive = L.zippedArchive || !1, H.maxFiles = L.maxFiles || null, H.eol = L.eol || $.EOL, H.tailable = L.tailable || !1, H._size = 0, H._pendingSize = 0, H._created = 0, H._drain = !1, H._opening = !1, H._ending = !1, H.dirname && H._createLogDirIfNotExist(H.dirname), H.open(), H;
          }
          return y = x, (C = [{ key: "finishIfEnding", value: function() {
            var H = this;
            this._ending && (this._opening ? this.once("open", function() {
              H._stream.once("finish", function() {
                return H.emit("finish");
              }), r(function() {
                return H._stream.end();
              });
            }) : (this._stream.once("finish", function() {
              return H.emit("finish");
            }), r(function() {
              return H._stream.end();
            })));
          } }, { key: "log", value: function(H) {
            var L = this, N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
            };
            if (this.silent)
              return N(), !0;
            if (this._drain)
              this._stream.once("drain", function() {
                L._drain = !1, L.log(H, N);
              });
            else {
              if (!this._rotate) {
                var P = "".concat(H[j]).concat(this.eol), z = o.byteLength(P);
                this._pendingSize += z, this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize) && (this.rotatedWhileOpening = !0);
                var O = this._stream.write(P, m.bind(this));
                return O ? N() : (this._drain = !0, this._stream.once("drain", function() {
                  L._drain = !1, N();
                })), M("written", O, this._drain), this.finishIfEnding(), O;
              }
              this._stream.once("rotate", function() {
                L._rotate = !1, L.log(H, N);
              });
            }
            function m() {
              var F = this;
              this._size += z, this._pendingSize -= z, M("logged %s %s", this._size, P), this.emit("logged", H), this._opening || this._needsNewFile() && (this._rotate = !0, this._endStream(function() {
                return F._rotateFile();
              }));
            }
          } }, { key: "query", value: function(H, L) {
            typeof H == "function" && (L = H, H = {}), H = function(V) {
              return (V = V || {}).rows = V.rows || V.limit || 10, V.start = V.start || 0, V.until = V.until || /* @__PURE__ */ new Date(), l(V.until) !== "object" && (V.until = new Date(V.until)), V.from = V.from || V.until - 864e5, l(V.from) !== "object" && (V.from = new Date(V.from)), V.order = V.order || "desc", V;
            }(H);
            var N = f.join(this.dirname, this.filename), P = "", z = [], O = 0, m = h.createReadStream(N, { encoding: "utf8" });
            function F(V, Q) {
              try {
                var ee = JSON.parse(V);
                (function(ne) {
                  if (ne && l(ne) === "object") {
                    var Y = new Date(ne.timestamp);
                    if (!(H.from && Y < H.from || H.until && Y > H.until || H.level && H.level !== ne.level))
                      return !0;
                  }
                })(ee) && function(ne) {
                  H.rows && z.length >= H.rows && H.order !== "desc" ? m.readable && m.destroy() : (H.fields && (ne = H.fields.reduce(function(Y, G) {
                    return Y[G] = ne[G], Y;
                  }, {})), H.order === "desc" && z.length >= H.rows && z.shift(), z.push(ne));
                }(ee);
              } catch (ne) {
                Q || m.emit("error", ne);
              }
            }
            m.on("error", function(V) {
              if (m.readable && m.destroy(), L)
                return V.code !== "ENOENT" ? L(V) : L(null, z);
            }), m.on("data", function(V) {
              for (var Q = (V = (P + V).split(/\n+/)).length - 1, ee = 0; ee < Q; ee++)
                (!H.start || O >= H.start) && F(V[ee]), O++;
              P = V[Q];
            }), m.on("close", function() {
              P && F(P, !0), H.order === "desc" && (z = z.reverse()), L && L(null, z);
            });
          } }, { key: "stream", value: function() {
            var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, L = f.join(this.dirname, this.filename), N = new I(), P = { file: L, start: H.start };
            return N.destroy = Z(P, function(z, O) {
              if (z)
                return N.emit("error", z);
              try {
                N.emit("data", O), O = JSON.parse(O), N.emit("log", O);
              } catch (m) {
                N.emit("error", m);
              }
            }), N;
          } }, { key: "open", value: function() {
            var H = this;
            this.filename && (this._opening || (this._opening = !0, this.stat(function(L, N) {
              if (L)
                return H.emit("error", L);
              M("stat done: %s { size: %s }", H.filename, N), H._size = N, H._dest = H._createStream(H._stream), H._opening = !1, H.once("open", function() {
                H._stream.eventNames().includes("rotate") ? H._stream.emit("rotate") : H._rotate = !1;
              });
            })));
          } }, { key: "stat", value: function(H) {
            var L = this, N = this._getFile(), P = f.join(this.dirname, N);
            h.stat(P, function(z, O) {
              return z && z.code === "ENOENT" ? (M("ENOENT ok", P), L.filename = N, H(null, 0)) : z ? (M("err ".concat(z.code, " ").concat(P)), H(z)) : !O || L._needsNewFile(O.size) ? L._incFile(function() {
                return L.stat(H);
              }) : (L.filename = N, void H(null, O.size));
            });
          } }, { key: "close", value: function(H) {
            var L = this;
            this._stream && this._stream.end(function() {
              H && H(), L.emit("flush"), L.emit("closed");
            });
          } }, { key: "_needsNewFile", value: function(H) {
            return H = H || this._size, this.maxsize && H >= this.maxsize;
          } }, { key: "_onError", value: function(H) {
            this.emit("error", H);
          } }, { key: "_setupStream", value: function(H) {
            return H.on("error", this._onError), H;
          } }, { key: "_cleanupStream", value: function(H) {
            return H.removeListener("error", this._onError), H;
          } }, { key: "_rotateFile", value: function() {
            var H = this;
            this._incFile(function() {
              return H.open();
            });
          } }, { key: "_endStream", value: function() {
            var H = this, L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
            };
            this._dest ? (this._stream.unpipe(this._dest), this._dest.end(function() {
              H._cleanupStream(H._dest), L();
            })) : L();
          } }, { key: "_createStream", value: function(H) {
            var L = this, N = f.join(this.dirname, this.filename);
            M("create stream start", N, this.options);
            var P = h.createWriteStream(N, this.options).on("error", function(O) {
              return M(O);
            }).on("close", function() {
              return M("close", P.path, P.bytesWritten);
            }).on("open", function() {
              M("file open ok", N), L.emit("open", N), H.pipe(P), L.rotatedWhileOpening && (L._stream = new R(), L._stream.setMaxListeners(30), L._rotateFile(), L.rotatedWhileOpening = !1, L._cleanupStream(P), H.end());
            });
            if (M("create stream ok", N), this.zippedArchive) {
              var z = E.createGzip();
              return z.pipe(P), z;
            }
            return P;
          } }, { key: "_incFile", value: function(H) {
            M("_incFile", this.filename);
            var L = f.extname(this._basename), N = f.basename(this._basename, L);
            this.tailable ? this._checkMaxFilesTailable(L, N, H) : (this._created += 1, this._checkMaxFilesIncrementing(L, N, H));
          } }, { key: "_getFile", value: function() {
            var H = f.extname(this._basename), L = f.basename(this._basename, H), N = this.rotationFormat ? this.rotationFormat() : this._created, P = !this.tailable && this._created ? "".concat(L).concat(N).concat(H) : "".concat(L).concat(H);
            return this.zippedArchive && !this.tailable ? "".concat(P, ".gz") : P;
          } }, { key: "_checkMaxFilesIncrementing", value: function(H, L, N) {
            if (!this.maxFiles || this._created < this.maxFiles)
              return r(N);
            var P = this._created - this.maxFiles, z = P !== 0 ? P : "", O = this.zippedArchive ? ".gz" : "", m = "".concat(L).concat(z).concat(H).concat(O), F = f.join(this.dirname, m);
            h.unlink(F, N);
          } }, { key: "_checkMaxFilesTailable", value: function(H, L, N) {
            var P = this, z = [];
            if (this.maxFiles) {
              for (var O = this.zippedArchive ? ".gz" : "", m = this.maxFiles - 1; m > 1; m--)
                z.push(function(F, V) {
                  var Q = this, ee = "".concat(L).concat(F - 1).concat(H).concat(O), ne = f.join(this.dirname, ee);
                  h.exists(ne, function(Y) {
                    if (!Y)
                      return V(null);
                    ee = "".concat(L).concat(F).concat(H).concat(O), h.rename(ne, f.join(Q.dirname, ee), V);
                  });
                }.bind(this, m));
              v(z, function() {
                h.rename(f.join(P.dirname, "".concat(L).concat(H)), f.join(P.dirname, "".concat(L, "1").concat(H).concat(O)), N);
              });
            }
          } }, { key: "_createLogDirIfNotExist", value: function(H) {
            h.existsSync(H) || h.mkdirSync(H, { recursive: !0 });
          } }]) && s(y.prototype, C), x;
        }(p);
      }).call(this, n(15).setImmediate, n(5).Buffer);
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(u, s) {
        return (0, r.default)(o.default, u, s);
      };
      var r = l(n(151)), o = l(n(155));
      function l(u) {
        return u && u.__esModule ? u : { default: u };
      }
      e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = u(n(45)), o = u(n(25)), l = u(n(30));
      function u(s) {
        return s && s.__esModule ? s : { default: s };
      }
      t.default = (0, l.default)((s, g, c) => {
        var d = (0, r.default)(g) ? [] : {};
        s(g, (T, b, h) => {
          (0, o.default)(T)((f, ...v) => {
            v.length < 2 && ([v] = v), d[b] = v, h(f);
          });
        }, (T) => c(T, d));
      }, 3), e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(c) {
        return (0, l.isAsync)(c) ? function(...d) {
          const T = d.pop();
          return s(c.apply(this, d), T);
        } : (0, r.default)(function(d, T) {
          var b;
          try {
            b = c.apply(this, d);
          } catch (h) {
            return T(h);
          }
          if (b && typeof b.then == "function")
            return s(b, T);
          T(null, b);
        });
      };
      var r = u(n(153)), o = u(n(154)), l = n(25);
      function u(c) {
        return c && c.__esModule ? c : { default: c };
      }
      function s(c, d) {
        return c.then((T) => {
          g(d, null, T);
        }, (T) => {
          g(d, T && T.message ? T : new Error(T));
        });
      }
      function g(c, d, T) {
        try {
          c(d, T);
        } catch (b) {
          (0, o.default)((h) => {
            throw h;
          }, b);
        }
      }
      e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        return function(...o) {
          var l = o.pop();
          return r.call(this, o, l);
        };
      }, e.exports = t.default;
    }, function(e, t, n) {
      (function(r, o) {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.fallback = c, t.wrap = d;
        var l, u = t.hasQueueMicrotask = typeof queueMicrotask == "function" && queueMicrotask, s = t.hasSetImmediate = typeof r == "function" && r, g = t.hasNextTick = typeof o == "object" && typeof o.nextTick == "function";
        function c(T) {
          setTimeout(T, 0);
        }
        function d(T) {
          return (b, ...h) => T(() => b(...h));
        }
        l = u ? queueMicrotask : s ? r : g ? o.nextTick : c, t.default = d(l);
      }).call(this, n(15).setImmediate, n(2));
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = l(n(66)), o = l(n(30));
      function l(u) {
        return u && u.__esModule ? u : { default: u };
      }
      t.default = (0, o.default)(function(u, s, g) {
        return (0, r.default)(u, 1, s, g);
      }, 3), e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = c(n(67)), o = c(n(157)), l = c(n(68)), u = n(25), s = c(n(159)), g = c(n(46));
      function c(d) {
        return d && d.__esModule ? d : { default: d };
      }
      t.default = (d) => (T, b, h) => {
        if (h = (0, r.default)(h), d <= 0)
          throw new RangeError("concurrency limit cannot be less than 1");
        if (!T)
          return h(null);
        if ((0, u.isAsyncGenerator)(T))
          return (0, s.default)(T, d, b, h);
        if ((0, u.isAsyncIterable)(T))
          return (0, s.default)(T[Symbol.asyncIterator](), d, b, h);
        var f = (0, o.default)(T), v = !1, E = !1, j = 0, B = !1;
        function I(p, M) {
          if (!E)
            if (j -= 1, p)
              v = !0, h(p);
            else if (p === !1)
              v = !0, E = !0;
            else {
              if (M === g.default || v && j <= 0)
                return v = !0, h(null);
              B || R();
            }
        }
        function R() {
          for (B = !0; j < d && !v; ) {
            var p = f();
            if (p === null)
              return v = !0, void (j <= 0 && h(null));
            j += 1, b(p.value, p.key, (0, l.default)(I));
          }
          B = !1;
        }
        R();
      }, e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(u) {
        if ((0, r.default)(u))
          return function(b) {
            var h = -1, f = b.length;
            return function() {
              return ++h < f ? { value: b[h], key: h } : null;
            };
          }(u);
        var s = (0, o.default)(u);
        return s ? function(b) {
          var h = -1;
          return function() {
            var f = b.next();
            return f.done ? null : (h++, { value: f.value, key: h });
          };
        }(s) : (g = u, c = g ? Object.keys(g) : [], d = -1, T = c.length, function b() {
          var h = c[++d];
          return h === "__proto__" ? b() : d < T ? { value: g[h], key: h } : null;
        });
        var g, c, d, T;
      };
      var r = l(n(45)), o = l(n(158));
      function l(u) {
        return u && u.__esModule ? u : { default: u };
      }
      e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        return r[Symbol.iterator] && r[Symbol.iterator]();
      }, e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(u, s, g, c) {
        let d = !1, T = !1, b = !1, h = 0, f = 0;
        function v() {
          h >= s || b || d || (b = !0, u.next().then(({ value: B, done: I }) => {
            if (!T && !d) {
              if (b = !1, I)
                return d = !0, void (h <= 0 && c(null));
              h++, g(B, f, E), f++, v();
            }
          }).catch(j));
        }
        function E(B, I) {
          if (h -= 1, !T)
            return B ? j(B) : B === !1 ? (d = !0, void (T = !0)) : I === l.default || d && h <= 0 ? (d = !0, c(null)) : void v();
        }
        function j(B) {
          T || (b = !1, d = !0, c(B));
        }
        v();
      };
      var r, o = n(46), l = (r = o) && r.__esModule ? r : { default: r };
      e.exports = t.default;
    }, function(e, t, n) {
      (function(r) {
        var o = n(5).Buffer, l = n(161).Transform, u = n(169), s = n(13), g = n(74).ok, c = n(5).kMaxLength, d = "Cannot create final Buffer. It would be larger than 0x" + c.toString(16) + " bytes";
        u.Z_MIN_WINDOWBITS = 8, u.Z_MAX_WINDOWBITS = 15, u.Z_DEFAULT_WINDOWBITS = 15, u.Z_MIN_CHUNK = 64, u.Z_MAX_CHUNK = 1 / 0, u.Z_DEFAULT_CHUNK = 16384, u.Z_MIN_MEMLEVEL = 1, u.Z_MAX_MEMLEVEL = 9, u.Z_DEFAULT_MEMLEVEL = 8, u.Z_MIN_LEVEL = -1, u.Z_MAX_LEVEL = 9, u.Z_DEFAULT_LEVEL = u.Z_DEFAULT_COMPRESSION;
        for (var T = Object.keys(u), b = 0; b < T.length; b++) {
          var h = T[b];
          h.match(/^Z/) && Object.defineProperty(t, h, { enumerable: !0, value: u[h], writable: !1 });
        }
        for (var f = { Z_OK: u.Z_OK, Z_STREAM_END: u.Z_STREAM_END, Z_NEED_DICT: u.Z_NEED_DICT, Z_ERRNO: u.Z_ERRNO, Z_STREAM_ERROR: u.Z_STREAM_ERROR, Z_DATA_ERROR: u.Z_DATA_ERROR, Z_MEM_ERROR: u.Z_MEM_ERROR, Z_BUF_ERROR: u.Z_BUF_ERROR, Z_VERSION_ERROR: u.Z_VERSION_ERROR }, v = Object.keys(f), E = 0; E < v.length; E++) {
          var j = v[E];
          f[f[j]] = j;
        }
        function B(L, N, P) {
          var z = [], O = 0;
          function m() {
            for (var V; (V = L.read()) !== null; )
              z.push(V), O += V.length;
            L.once("readable", m);
          }
          function F() {
            var V, Q = null;
            O >= c ? Q = new RangeError(d) : V = o.concat(z, O), z = [], L.close(), P(Q, V);
          }
          L.on("error", function(V) {
            L.removeListener("end", F), L.removeListener("readable", m), P(V);
          }), L.on("end", F), L.end(N), m();
        }
        function I(L, N) {
          if (typeof N == "string" && (N = o.from(N)), !o.isBuffer(N))
            throw new TypeError("Not a string or buffer");
          var P = L._finishFlushFlag;
          return L._processChunk(N, P);
        }
        function R(L) {
          if (!(this instanceof R))
            return new R(L);
          w.call(this, L, u.DEFLATE);
        }
        function p(L) {
          if (!(this instanceof p))
            return new p(L);
          w.call(this, L, u.INFLATE);
        }
        function M(L) {
          if (!(this instanceof M))
            return new M(L);
          w.call(this, L, u.GZIP);
        }
        function $(L) {
          if (!(this instanceof $))
            return new $(L);
          w.call(this, L, u.GUNZIP);
        }
        function Z(L) {
          if (!(this instanceof Z))
            return new Z(L);
          w.call(this, L, u.DEFLATERAW);
        }
        function _(L) {
          if (!(this instanceof _))
            return new _(L);
          w.call(this, L, u.INFLATERAW);
        }
        function y(L) {
          if (!(this instanceof y))
            return new y(L);
          w.call(this, L, u.UNZIP);
        }
        function C(L) {
          return L === u.Z_NO_FLUSH || L === u.Z_PARTIAL_FLUSH || L === u.Z_SYNC_FLUSH || L === u.Z_FULL_FLUSH || L === u.Z_FINISH || L === u.Z_BLOCK;
        }
        function w(L, N) {
          var P = this;
          if (this._opts = L = L || {}, this._chunkSize = L.chunkSize || t.Z_DEFAULT_CHUNK, l.call(this, L), L.flush && !C(L.flush))
            throw new Error("Invalid flush flag: " + L.flush);
          if (L.finishFlush && !C(L.finishFlush))
            throw new Error("Invalid flush flag: " + L.finishFlush);
          if (this._flushFlag = L.flush || u.Z_NO_FLUSH, this._finishFlushFlag = L.finishFlush !== void 0 ? L.finishFlush : u.Z_FINISH, L.chunkSize && (L.chunkSize < t.Z_MIN_CHUNK || L.chunkSize > t.Z_MAX_CHUNK))
            throw new Error("Invalid chunk size: " + L.chunkSize);
          if (L.windowBits && (L.windowBits < t.Z_MIN_WINDOWBITS || L.windowBits > t.Z_MAX_WINDOWBITS))
            throw new Error("Invalid windowBits: " + L.windowBits);
          if (L.level && (L.level < t.Z_MIN_LEVEL || L.level > t.Z_MAX_LEVEL))
            throw new Error("Invalid compression level: " + L.level);
          if (L.memLevel && (L.memLevel < t.Z_MIN_MEMLEVEL || L.memLevel > t.Z_MAX_MEMLEVEL))
            throw new Error("Invalid memLevel: " + L.memLevel);
          if (L.strategy && L.strategy != t.Z_FILTERED && L.strategy != t.Z_HUFFMAN_ONLY && L.strategy != t.Z_RLE && L.strategy != t.Z_FIXED && L.strategy != t.Z_DEFAULT_STRATEGY)
            throw new Error("Invalid strategy: " + L.strategy);
          if (L.dictionary && !o.isBuffer(L.dictionary))
            throw new Error("Invalid dictionary: it should be a Buffer instance");
          this._handle = new u.Zlib(N);
          var z = this;
          this._hadError = !1, this._handle.onerror = function(F, V) {
            x(z), z._hadError = !0;
            var Q = new Error(F);
            Q.errno = V, Q.code = t.codes[V], z.emit("error", Q);
          };
          var O = t.Z_DEFAULT_COMPRESSION;
          typeof L.level == "number" && (O = L.level);
          var m = t.Z_DEFAULT_STRATEGY;
          typeof L.strategy == "number" && (m = L.strategy), this._handle.init(L.windowBits || t.Z_DEFAULT_WINDOWBITS, O, L.memLevel || t.Z_DEFAULT_MEMLEVEL, m, L.dictionary), this._buffer = o.allocUnsafe(this._chunkSize), this._offset = 0, this._level = O, this._strategy = m, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
            return !P._handle;
          }, configurable: !0, enumerable: !0 });
        }
        function x(L, N) {
          N && r.nextTick(N), L._handle && (L._handle.close(), L._handle = null);
        }
        function H(L) {
          L.emit("close");
        }
        Object.defineProperty(t, "codes", { enumerable: !0, value: Object.freeze(f), writable: !1 }), t.Deflate = R, t.Inflate = p, t.Gzip = M, t.Gunzip = $, t.DeflateRaw = Z, t.InflateRaw = _, t.Unzip = y, t.createDeflate = function(L) {
          return new R(L);
        }, t.createInflate = function(L) {
          return new p(L);
        }, t.createDeflateRaw = function(L) {
          return new Z(L);
        }, t.createInflateRaw = function(L) {
          return new _(L);
        }, t.createGzip = function(L) {
          return new M(L);
        }, t.createGunzip = function(L) {
          return new $(L);
        }, t.createUnzip = function(L) {
          return new y(L);
        }, t.deflate = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new R(N), L, P);
        }, t.deflateSync = function(L, N) {
          return I(new R(N), L);
        }, t.gzip = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new M(N), L, P);
        }, t.gzipSync = function(L, N) {
          return I(new M(N), L);
        }, t.deflateRaw = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new Z(N), L, P);
        }, t.deflateRawSync = function(L, N) {
          return I(new Z(N), L);
        }, t.unzip = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new y(N), L, P);
        }, t.unzipSync = function(L, N) {
          return I(new y(N), L);
        }, t.inflate = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new p(N), L, P);
        }, t.inflateSync = function(L, N) {
          return I(new p(N), L);
        }, t.gunzip = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new $(N), L, P);
        }, t.gunzipSync = function(L, N) {
          return I(new $(N), L);
        }, t.inflateRaw = function(L, N, P) {
          return typeof N == "function" && (P = N, N = {}), B(new _(N), L, P);
        }, t.inflateRawSync = function(L, N) {
          return I(new _(N), L);
        }, s.inherits(w, l), w.prototype.params = function(L, N, P) {
          if (L < t.Z_MIN_LEVEL || L > t.Z_MAX_LEVEL)
            throw new RangeError("Invalid compression level: " + L);
          if (N != t.Z_FILTERED && N != t.Z_HUFFMAN_ONLY && N != t.Z_RLE && N != t.Z_FIXED && N != t.Z_DEFAULT_STRATEGY)
            throw new TypeError("Invalid strategy: " + N);
          if (this._level !== L || this._strategy !== N) {
            var z = this;
            this.flush(u.Z_SYNC_FLUSH, function() {
              g(z._handle, "zlib binding closed"), z._handle.params(L, N), z._hadError || (z._level = L, z._strategy = N, P && P());
            });
          } else
            r.nextTick(P);
        }, w.prototype.reset = function() {
          return g(this._handle, "zlib binding closed"), this._handle.reset();
        }, w.prototype._flush = function(L) {
          this._transform(o.alloc(0), "", L);
        }, w.prototype.flush = function(L, N) {
          var P = this, z = this._writableState;
          (typeof L == "function" || L === void 0 && !N) && (N = L, L = u.Z_FULL_FLUSH), z.ended ? N && r.nextTick(N) : z.ending ? N && this.once("end", N) : z.needDrain ? N && this.once("drain", function() {
            return P.flush(L, N);
          }) : (this._flushFlag = L, this.write(o.alloc(0), "", N));
        }, w.prototype.close = function(L) {
          x(this, L), r.nextTick(H, this);
        }, w.prototype._transform = function(L, N, P) {
          var z, O = this._writableState, m = (O.ending || O.ended) && (!L || O.length === L.length);
          return L === null || o.isBuffer(L) ? this._handle ? (m ? z = this._finishFlushFlag : (z = this._flushFlag, L.length >= O.length && (this._flushFlag = this._opts.flush || u.Z_NO_FLUSH)), void this._processChunk(L, z, P)) : P(new Error("zlib binding closed")) : P(new Error("invalid input"));
        }, w.prototype._processChunk = function(L, N, P) {
          var z = L && L.length, O = this._chunkSize - this._offset, m = 0, F = this, V = typeof P == "function";
          if (!V) {
            var Q, ee = [], ne = 0;
            this.on("error", function(U) {
              Q = U;
            }), g(this._handle, "zlib binding closed");
            do
              var Y = this._handle.writeSync(N, L, m, z, this._buffer, this._offset, O);
            while (!this._hadError && A(Y[0], Y[1]));
            if (this._hadError)
              throw Q;
            if (ne >= c)
              throw x(this), new RangeError(d);
            var G = o.concat(ee, ne);
            return x(this), G;
          }
          g(this._handle, "zlib binding closed");
          var S = this._handle.write(N, L, m, z, this._buffer, this._offset, O);
          function A(U, J) {
            if (this && (this.buffer = null, this.callback = null), !F._hadError) {
              var K = O - J;
              if (g(K >= 0, "have should not go down"), K > 0) {
                var re = F._buffer.slice(F._offset, F._offset + K);
                F._offset += K, V ? F.push(re) : (ee.push(re), ne += re.length);
              }
              if ((J === 0 || F._offset >= F._chunkSize) && (O = F._chunkSize, F._offset = 0, F._buffer = o.allocUnsafe(F._chunkSize)), J === 0) {
                if (m += z - U, z = U, !V)
                  return !0;
                var se = F._handle.write(N, L, m, z, F._buffer, F._offset, F._chunkSize);
                return se.callback = A, void (se.buffer = L);
              }
              if (!V)
                return !1;
              P();
            }
          }
          S.buffer = L, S.callback = A;
        }, s.inherits(R, w), s.inherits(p, w), s.inherits(M, w), s.inherits($, w), s.inherits(Z, w), s.inherits(_, w), s.inherits(y, w);
      }).call(this, n(2));
    }, function(e, t, n) {
      e.exports = o;
      var r = n(21).EventEmitter;
      function o() {
        r.call(this);
      }
      n(7)(o, r), o.Readable = n(31), o.Writable = n(73), o.Duplex = n(166), o.Transform = n(167), o.PassThrough = n(168), o.Stream = o, o.prototype.pipe = function(l, u) {
        var s = this;
        function g(v) {
          l.writable && l.write(v) === !1 && s.pause && s.pause();
        }
        function c() {
          s.readable && s.resume && s.resume();
        }
        s.on("data", g), l.on("drain", c), l._isStdio || u && u.end === !1 || (s.on("end", T), s.on("close", b));
        var d = !1;
        function T() {
          d || (d = !0, l.end());
        }
        function b() {
          d || (d = !0, typeof l.destroy == "function" && l.destroy());
        }
        function h(v) {
          if (f(), r.listenerCount(this, "error") === 0)
            throw v;
        }
        function f() {
          s.removeListener("data", g), l.removeListener("drain", c), s.removeListener("end", T), s.removeListener("close", b), s.removeListener("error", h), l.removeListener("error", h), s.removeListener("end", f), s.removeListener("close", f), l.removeListener("close", f);
        }
        return s.on("error", h), l.on("error", h), s.on("end", f), s.on("close", f), l.on("close", f), l.emit("pipe", s), l;
      };
    }, function(e, t) {
    }, function(e, t, n) {
      var r = n(47).Buffer, o = n(164);
      e.exports = function() {
        function l() {
          (function(u, s) {
            if (!(u instanceof s))
              throw new TypeError("Cannot call a class as a function");
          })(this, l), this.head = null, this.tail = null, this.length = 0;
        }
        return l.prototype.push = function(u) {
          var s = { data: u, next: null };
          this.length > 0 ? this.tail.next = s : this.head = s, this.tail = s, ++this.length;
        }, l.prototype.unshift = function(u) {
          var s = { data: u, next: this.head };
          this.length === 0 && (this.tail = s), this.head = s, ++this.length;
        }, l.prototype.shift = function() {
          if (this.length !== 0) {
            var u = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, u;
          }
        }, l.prototype.clear = function() {
          this.head = this.tail = null, this.length = 0;
        }, l.prototype.join = function(u) {
          if (this.length === 0)
            return "";
          for (var s = this.head, g = "" + s.data; s = s.next; )
            g += u + s.data;
          return g;
        }, l.prototype.concat = function(u) {
          if (this.length === 0)
            return r.alloc(0);
          if (this.length === 1)
            return this.head.data;
          for (var s, g, c, d = r.allocUnsafe(u >>> 0), T = this.head, b = 0; T; )
            s = T.data, g = d, c = b, s.copy(g, c), b += T.data.length, T = T.next;
          return d;
        }, l;
      }(), o && o.inspect && o.inspect.custom && (e.exports.prototype[o.inspect.custom] = function() {
        var l = o.inspect({ length: this.length });
        return this.constructor.name + " " + l;
      });
    }, function(e, t) {
    }, function(e, t, n) {
      e.exports = l;
      var r = n(72), o = n(17);
      function l(u) {
        if (!(this instanceof l))
          return new l(u);
        r.call(this, u);
      }
      o.inherits = n(7), o.inherits(l, r), l.prototype._transform = function(u, s, g) {
        g(null, u);
      };
    }, function(e, t, n) {
      e.exports = n(23);
    }, function(e, t, n) {
      e.exports = n(31).Transform;
    }, function(e, t, n) {
      e.exports = n(31).PassThrough;
    }, function(e, t, n) {
      (function(r, o) {
        var l = n(74), u = n(171), s = n(172), g = n(175), c = n(178);
        for (var d in c)
          t[d] = c[d];
        t.NONE = 0, t.DEFLATE = 1, t.INFLATE = 2, t.GZIP = 3, t.GUNZIP = 4, t.DEFLATERAW = 5, t.INFLATERAW = 6, t.UNZIP = 7;
        function T(b) {
          if (typeof b != "number" || b < t.DEFLATE || b > t.UNZIP)
            throw new TypeError("Bad argument");
          this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = b, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
        }
        T.prototype.close = function() {
          this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, l(this.init_done, "close before init"), l(this.mode <= t.UNZIP), this.mode === t.DEFLATE || this.mode === t.GZIP || this.mode === t.DEFLATERAW ? s.deflateEnd(this.strm) : this.mode !== t.INFLATE && this.mode !== t.GUNZIP && this.mode !== t.INFLATERAW && this.mode !== t.UNZIP || g.inflateEnd(this.strm), this.mode = t.NONE, this.dictionary = null);
        }, T.prototype.write = function(b, h, f, v, E, j, B) {
          return this._write(!0, b, h, f, v, E, j, B);
        }, T.prototype.writeSync = function(b, h, f, v, E, j, B) {
          return this._write(!1, b, h, f, v, E, j, B);
        }, T.prototype._write = function(b, h, f, v, E, j, B, I) {
          if (l.equal(arguments.length, 8), l(this.init_done, "write before init"), l(this.mode !== t.NONE, "already finalized"), l.equal(!1, this.write_in_progress, "write already in progress"), l.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, l.equal(!1, h === void 0, "must provide flush value"), this.write_in_progress = !0, h !== t.Z_NO_FLUSH && h !== t.Z_PARTIAL_FLUSH && h !== t.Z_SYNC_FLUSH && h !== t.Z_FULL_FLUSH && h !== t.Z_FINISH && h !== t.Z_BLOCK)
            throw new Error("Invalid flush value");
          if (f == null && (f = r.alloc(0), E = 0, v = 0), this.strm.avail_in = E, this.strm.input = f, this.strm.next_in = v, this.strm.avail_out = I, this.strm.output = j, this.strm.next_out = B, this.flush = h, !b)
            return this._process(), this._checkError() ? this._afterSync() : void 0;
          var R = this;
          return o.nextTick(function() {
            R._process(), R._after();
          }), this;
        }, T.prototype._afterSync = function() {
          var b = this.strm.avail_out, h = this.strm.avail_in;
          return this.write_in_progress = !1, [h, b];
        }, T.prototype._process = function() {
          var b = null;
          switch (this.mode) {
            case t.DEFLATE:
            case t.GZIP:
            case t.DEFLATERAW:
              this.err = s.deflate(this.strm, this.flush);
              break;
            case t.UNZIP:
              switch (this.strm.avail_in > 0 && (b = this.strm.next_in), this.gzip_id_bytes_read) {
                case 0:
                  if (b === null)
                    break;
                  if (this.strm.input[b] !== 31) {
                    this.mode = t.INFLATE;
                    break;
                  }
                  if (this.gzip_id_bytes_read = 1, b++, this.strm.avail_in === 1)
                    break;
                case 1:
                  if (b === null)
                    break;
                  this.strm.input[b] === 139 ? (this.gzip_id_bytes_read = 2, this.mode = t.GUNZIP) : this.mode = t.INFLATE;
                  break;
                default:
                  throw new Error("invalid number of gzip magic number bytes read");
              }
            case t.INFLATE:
            case t.GUNZIP:
            case t.INFLATERAW:
              for (this.err = g.inflate(this.strm, this.flush), this.err === t.Z_NEED_DICT && this.dictionary && (this.err = g.inflateSetDictionary(this.strm, this.dictionary), this.err === t.Z_OK ? this.err = g.inflate(this.strm, this.flush) : this.err === t.Z_DATA_ERROR && (this.err = t.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === t.GUNZIP && this.err === t.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                this.reset(), this.err = g.inflate(this.strm, this.flush);
              break;
            default:
              throw new Error("Unknown mode " + this.mode);
          }
        }, T.prototype._checkError = function() {
          switch (this.err) {
            case t.Z_OK:
            case t.Z_BUF_ERROR:
              if (this.strm.avail_out !== 0 && this.flush === t.Z_FINISH)
                return this._error("unexpected end of file"), !1;
              break;
            case t.Z_STREAM_END:
              break;
            case t.Z_NEED_DICT:
              return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
            default:
              return this._error("Zlib error"), !1;
          }
          return !0;
        }, T.prototype._after = function() {
          if (this._checkError()) {
            var b = this.strm.avail_out, h = this.strm.avail_in;
            this.write_in_progress = !1, this.callback(h, b), this.pending_close && this.close();
          }
        }, T.prototype._error = function(b) {
          this.strm.msg && (b = this.strm.msg), this.onerror(b, this.err), this.write_in_progress = !1, this.pending_close && this.close();
        }, T.prototype.init = function(b, h, f, v, E) {
          l(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), l(b >= 8 && b <= 15, "invalid windowBits"), l(h >= -1 && h <= 9, "invalid compression level"), l(f >= 1 && f <= 9, "invalid memlevel"), l(v === t.Z_FILTERED || v === t.Z_HUFFMAN_ONLY || v === t.Z_RLE || v === t.Z_FIXED || v === t.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(h, b, f, v, E), this._setDictionary();
        }, T.prototype.params = function() {
          throw new Error("deflateParams Not supported");
        }, T.prototype.reset = function() {
          this._reset(), this._setDictionary();
        }, T.prototype._init = function(b, h, f, v, E) {
          switch (this.level = b, this.windowBits = h, this.memLevel = f, this.strategy = v, this.flush = t.Z_NO_FLUSH, this.err = t.Z_OK, this.mode !== t.GZIP && this.mode !== t.GUNZIP || (this.windowBits += 16), this.mode === t.UNZIP && (this.windowBits += 32), this.mode !== t.DEFLATERAW && this.mode !== t.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new u(), this.mode) {
            case t.DEFLATE:
            case t.GZIP:
            case t.DEFLATERAW:
              this.err = s.deflateInit2(this.strm, this.level, t.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
              break;
            case t.INFLATE:
            case t.GUNZIP:
            case t.INFLATERAW:
            case t.UNZIP:
              this.err = g.inflateInit2(this.strm, this.windowBits);
              break;
            default:
              throw new Error("Unknown mode " + this.mode);
          }
          this.err !== t.Z_OK && this._error("Init error"), this.dictionary = E, this.write_in_progress = !1, this.init_done = !0;
        }, T.prototype._setDictionary = function() {
          if (this.dictionary != null) {
            switch (this.err = t.Z_OK, this.mode) {
              case t.DEFLATE:
              case t.DEFLATERAW:
                this.err = s.deflateSetDictionary(this.strm, this.dictionary);
            }
            this.err !== t.Z_OK && this._error("Failed to set dictionary");
          }
        }, T.prototype._reset = function() {
          switch (this.err = t.Z_OK, this.mode) {
            case t.DEFLATE:
            case t.DEFLATERAW:
            case t.GZIP:
              this.err = s.deflateReset(this.strm);
              break;
            case t.INFLATE:
            case t.INFLATERAW:
            case t.GUNZIP:
              this.err = g.inflateReset(this.strm);
          }
          this.err !== t.Z_OK && this._error("Failed to reset stream");
        }, t.Zlib = T;
      }).call(this, n(5).Buffer, n(2));
    }, function(e, t, n) {
      var r = Object.getOwnPropertySymbols, o = Object.prototype.hasOwnProperty, l = Object.prototype.propertyIsEnumerable;
      function u(s) {
        if (s == null)
          throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(s);
      }
      e.exports = function() {
        try {
          if (!Object.assign)
            return !1;
          var s = new String("abc");
          if (s[5] = "de", Object.getOwnPropertyNames(s)[0] === "5")
            return !1;
          for (var g = {}, c = 0; c < 10; c++)
            g["_" + String.fromCharCode(c)] = c;
          if (Object.getOwnPropertyNames(g).map(function(T) {
            return g[T];
          }).join("") !== "0123456789")
            return !1;
          var d = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(T) {
            d[T] = T;
          }), Object.keys(Object.assign({}, d)).join("") === "abcdefghijklmnopqrst";
        } catch {
          return !1;
        }
      }() ? Object.assign : function(s, g) {
        for (var c, d, T = u(s), b = 1; b < arguments.length; b++) {
          for (var h in c = Object(arguments[b]))
            o.call(c, h) && (T[h] = c[h]);
          if (r) {
            d = r(c);
            for (var f = 0; f < d.length; f++)
              l.call(c, d[f]) && (T[d[f]] = c[d[f]]);
          }
        }
        return T;
      };
    }, function(e, t, n) {
      e.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, function(e, t, n) {
      var r, o = n(37), l = n(173), u = n(75), s = n(76), g = n(174);
      function c(_, y) {
        return _.msg = g[y], y;
      }
      function d(_) {
        return (_ << 1) - (_ > 4 ? 9 : 0);
      }
      function T(_) {
        for (var y = _.length; --y >= 0; )
          _[y] = 0;
      }
      function b(_) {
        var y = _.state, C = y.pending;
        C > _.avail_out && (C = _.avail_out), C !== 0 && (o.arraySet(_.output, y.pending_buf, y.pending_out, C, _.next_out), _.next_out += C, y.pending_out += C, _.total_out += C, _.avail_out -= C, y.pending -= C, y.pending === 0 && (y.pending_out = 0));
      }
      function h(_, y) {
        l._tr_flush_block(_, _.block_start >= 0 ? _.block_start : -1, _.strstart - _.block_start, y), _.block_start = _.strstart, b(_.strm);
      }
      function f(_, y) {
        _.pending_buf[_.pending++] = y;
      }
      function v(_, y) {
        _.pending_buf[_.pending++] = y >>> 8 & 255, _.pending_buf[_.pending++] = 255 & y;
      }
      function E(_, y) {
        var C, w, x = _.max_chain_length, H = _.strstart, L = _.prev_length, N = _.nice_match, P = _.strstart > _.w_size - 262 ? _.strstart - (_.w_size - 262) : 0, z = _.window, O = _.w_mask, m = _.prev, F = _.strstart + 258, V = z[H + L - 1], Q = z[H + L];
        _.prev_length >= _.good_match && (x >>= 2), N > _.lookahead && (N = _.lookahead);
        do
          if (z[(C = y) + L] === Q && z[C + L - 1] === V && z[C] === z[H] && z[++C] === z[H + 1]) {
            H += 2, C++;
            do
              ;
            while (z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && z[++H] === z[++C] && H < F);
            if (w = 258 - (F - H), H = F - 258, w > L) {
              if (_.match_start = y, L = w, w >= N)
                break;
              V = z[H + L - 1], Q = z[H + L];
            }
          }
        while ((y = m[y & O]) > P && --x != 0);
        return L <= _.lookahead ? L : _.lookahead;
      }
      function j(_) {
        var y, C, w, x, H, L, N, P, z, O, m = _.w_size;
        do {
          if (x = _.window_size - _.lookahead - _.strstart, _.strstart >= m + (m - 262)) {
            o.arraySet(_.window, _.window, m, m, 0), _.match_start -= m, _.strstart -= m, _.block_start -= m, y = C = _.hash_size;
            do
              w = _.head[--y], _.head[y] = w >= m ? w - m : 0;
            while (--C);
            y = C = m;
            do
              w = _.prev[--y], _.prev[y] = w >= m ? w - m : 0;
            while (--C);
            x += m;
          }
          if (_.strm.avail_in === 0)
            break;
          if (L = _.strm, N = _.window, P = _.strstart + _.lookahead, z = x, O = void 0, (O = L.avail_in) > z && (O = z), C = O === 0 ? 0 : (L.avail_in -= O, o.arraySet(N, L.input, L.next_in, O, P), L.state.wrap === 1 ? L.adler = u(L.adler, N, O, P) : L.state.wrap === 2 && (L.adler = s(L.adler, N, O, P)), L.next_in += O, L.total_in += O, O), _.lookahead += C, _.lookahead + _.insert >= 3)
            for (H = _.strstart - _.insert, _.ins_h = _.window[H], _.ins_h = (_.ins_h << _.hash_shift ^ _.window[H + 1]) & _.hash_mask; _.insert && (_.ins_h = (_.ins_h << _.hash_shift ^ _.window[H + 3 - 1]) & _.hash_mask, _.prev[H & _.w_mask] = _.head[_.ins_h], _.head[_.ins_h] = H, H++, _.insert--, !(_.lookahead + _.insert < 3)); )
              ;
        } while (_.lookahead < 262 && _.strm.avail_in !== 0);
      }
      function B(_, y) {
        for (var C, w; ; ) {
          if (_.lookahead < 262) {
            if (j(_), _.lookahead < 262 && y === 0)
              return 1;
            if (_.lookahead === 0)
              break;
          }
          if (C = 0, _.lookahead >= 3 && (_.ins_h = (_.ins_h << _.hash_shift ^ _.window[_.strstart + 3 - 1]) & _.hash_mask, C = _.prev[_.strstart & _.w_mask] = _.head[_.ins_h], _.head[_.ins_h] = _.strstart), C !== 0 && _.strstart - C <= _.w_size - 262 && (_.match_length = E(_, C)), _.match_length >= 3)
            if (w = l._tr_tally(_, _.strstart - _.match_start, _.match_length - 3), _.lookahead -= _.match_length, _.match_length <= _.max_lazy_match && _.lookahead >= 3) {
              _.match_length--;
              do
                _.strstart++, _.ins_h = (_.ins_h << _.hash_shift ^ _.window[_.strstart + 3 - 1]) & _.hash_mask, C = _.prev[_.strstart & _.w_mask] = _.head[_.ins_h], _.head[_.ins_h] = _.strstart;
              while (--_.match_length != 0);
              _.strstart++;
            } else
              _.strstart += _.match_length, _.match_length = 0, _.ins_h = _.window[_.strstart], _.ins_h = (_.ins_h << _.hash_shift ^ _.window[_.strstart + 1]) & _.hash_mask;
          else
            w = l._tr_tally(_, 0, _.window[_.strstart]), _.lookahead--, _.strstart++;
          if (w && (h(_, !1), _.strm.avail_out === 0))
            return 1;
        }
        return _.insert = _.strstart < 2 ? _.strstart : 2, y === 4 ? (h(_, !0), _.strm.avail_out === 0 ? 3 : 4) : _.last_lit && (h(_, !1), _.strm.avail_out === 0) ? 1 : 2;
      }
      function I(_, y) {
        for (var C, w, x; ; ) {
          if (_.lookahead < 262) {
            if (j(_), _.lookahead < 262 && y === 0)
              return 1;
            if (_.lookahead === 0)
              break;
          }
          if (C = 0, _.lookahead >= 3 && (_.ins_h = (_.ins_h << _.hash_shift ^ _.window[_.strstart + 3 - 1]) & _.hash_mask, C = _.prev[_.strstart & _.w_mask] = _.head[_.ins_h], _.head[_.ins_h] = _.strstart), _.prev_length = _.match_length, _.prev_match = _.match_start, _.match_length = 2, C !== 0 && _.prev_length < _.max_lazy_match && _.strstart - C <= _.w_size - 262 && (_.match_length = E(_, C), _.match_length <= 5 && (_.strategy === 1 || _.match_length === 3 && _.strstart - _.match_start > 4096) && (_.match_length = 2)), _.prev_length >= 3 && _.match_length <= _.prev_length) {
            x = _.strstart + _.lookahead - 3, w = l._tr_tally(_, _.strstart - 1 - _.prev_match, _.prev_length - 3), _.lookahead -= _.prev_length - 1, _.prev_length -= 2;
            do
              ++_.strstart <= x && (_.ins_h = (_.ins_h << _.hash_shift ^ _.window[_.strstart + 3 - 1]) & _.hash_mask, C = _.prev[_.strstart & _.w_mask] = _.head[_.ins_h], _.head[_.ins_h] = _.strstart);
            while (--_.prev_length != 0);
            if (_.match_available = 0, _.match_length = 2, _.strstart++, w && (h(_, !1), _.strm.avail_out === 0))
              return 1;
          } else if (_.match_available) {
            if ((w = l._tr_tally(_, 0, _.window[_.strstart - 1])) && h(_, !1), _.strstart++, _.lookahead--, _.strm.avail_out === 0)
              return 1;
          } else
            _.match_available = 1, _.strstart++, _.lookahead--;
        }
        return _.match_available && (w = l._tr_tally(_, 0, _.window[_.strstart - 1]), _.match_available = 0), _.insert = _.strstart < 2 ? _.strstart : 2, y === 4 ? (h(_, !0), _.strm.avail_out === 0 ? 3 : 4) : _.last_lit && (h(_, !1), _.strm.avail_out === 0) ? 1 : 2;
      }
      function R(_, y, C, w, x) {
        this.good_length = _, this.max_lazy = y, this.nice_length = C, this.max_chain = w, this.func = x;
      }
      function p() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(1146), this.dyn_dtree = new o.Buf16(122), this.bl_tree = new o.Buf16(78), T(this.dyn_ltree), T(this.dyn_dtree), T(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(16), this.heap = new o.Buf16(573), T(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(573), T(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function M(_) {
        var y;
        return _ && _.state ? (_.total_in = _.total_out = 0, _.data_type = 2, (y = _.state).pending = 0, y.pending_out = 0, y.wrap < 0 && (y.wrap = -y.wrap), y.status = y.wrap ? 42 : 113, _.adler = y.wrap === 2 ? 0 : 1, y.last_flush = 0, l._tr_init(y), 0) : c(_, -2);
      }
      function $(_) {
        var y, C = M(_);
        return C === 0 && ((y = _.state).window_size = 2 * y.w_size, T(y.head), y.max_lazy_match = r[y.level].max_lazy, y.good_match = r[y.level].good_length, y.nice_match = r[y.level].nice_length, y.max_chain_length = r[y.level].max_chain, y.strstart = 0, y.block_start = 0, y.lookahead = 0, y.insert = 0, y.match_length = y.prev_length = 2, y.match_available = 0, y.ins_h = 0), C;
      }
      function Z(_, y, C, w, x, H) {
        if (!_)
          return -2;
        var L = 1;
        if (y === -1 && (y = 6), w < 0 ? (L = 0, w = -w) : w > 15 && (L = 2, w -= 16), x < 1 || x > 9 || C !== 8 || w < 8 || w > 15 || y < 0 || y > 9 || H < 0 || H > 4)
          return c(_, -2);
        w === 8 && (w = 9);
        var N = new p();
        return _.state = N, N.strm = _, N.wrap = L, N.gzhead = null, N.w_bits = w, N.w_size = 1 << N.w_bits, N.w_mask = N.w_size - 1, N.hash_bits = x + 7, N.hash_size = 1 << N.hash_bits, N.hash_mask = N.hash_size - 1, N.hash_shift = ~~((N.hash_bits + 3 - 1) / 3), N.window = new o.Buf8(2 * N.w_size), N.head = new o.Buf16(N.hash_size), N.prev = new o.Buf16(N.w_size), N.lit_bufsize = 1 << x + 6, N.pending_buf_size = 4 * N.lit_bufsize, N.pending_buf = new o.Buf8(N.pending_buf_size), N.d_buf = 1 * N.lit_bufsize, N.l_buf = 3 * N.lit_bufsize, N.level = y, N.strategy = H, N.method = C, $(_);
      }
      r = [new R(0, 0, 0, 0, function(_, y) {
        var C = 65535;
        for (C > _.pending_buf_size - 5 && (C = _.pending_buf_size - 5); ; ) {
          if (_.lookahead <= 1) {
            if (j(_), _.lookahead === 0 && y === 0)
              return 1;
            if (_.lookahead === 0)
              break;
          }
          _.strstart += _.lookahead, _.lookahead = 0;
          var w = _.block_start + C;
          if ((_.strstart === 0 || _.strstart >= w) && (_.lookahead = _.strstart - w, _.strstart = w, h(_, !1), _.strm.avail_out === 0) || _.strstart - _.block_start >= _.w_size - 262 && (h(_, !1), _.strm.avail_out === 0))
            return 1;
        }
        return _.insert = 0, y === 4 ? (h(_, !0), _.strm.avail_out === 0 ? 3 : 4) : (_.strstart > _.block_start && (h(_, !1), _.strm.avail_out), 1);
      }), new R(4, 4, 8, 4, B), new R(4, 5, 16, 8, B), new R(4, 6, 32, 32, B), new R(4, 4, 16, 16, I), new R(8, 16, 32, 32, I), new R(8, 16, 128, 128, I), new R(8, 32, 128, 256, I), new R(32, 128, 258, 1024, I), new R(32, 258, 258, 4096, I)], t.deflateInit = function(_, y) {
        return Z(_, y, 8, 15, 8, 0);
      }, t.deflateInit2 = Z, t.deflateReset = $, t.deflateResetKeep = M, t.deflateSetHeader = function(_, y) {
        return _ && _.state ? _.state.wrap !== 2 ? -2 : (_.state.gzhead = y, 0) : -2;
      }, t.deflate = function(_, y) {
        var C, w, x, H;
        if (!_ || !_.state || y > 5 || y < 0)
          return _ ? c(_, -2) : -2;
        if (w = _.state, !_.output || !_.input && _.avail_in !== 0 || w.status === 666 && y !== 4)
          return c(_, _.avail_out === 0 ? -5 : -2);
        if (w.strm = _, C = w.last_flush, w.last_flush = y, w.status === 42)
          if (w.wrap === 2)
            _.adler = 0, f(w, 31), f(w, 139), f(w, 8), w.gzhead ? (f(w, (w.gzhead.text ? 1 : 0) + (w.gzhead.hcrc ? 2 : 0) + (w.gzhead.extra ? 4 : 0) + (w.gzhead.name ? 8 : 0) + (w.gzhead.comment ? 16 : 0)), f(w, 255 & w.gzhead.time), f(w, w.gzhead.time >> 8 & 255), f(w, w.gzhead.time >> 16 & 255), f(w, w.gzhead.time >> 24 & 255), f(w, w.level === 9 ? 2 : w.strategy >= 2 || w.level < 2 ? 4 : 0), f(w, 255 & w.gzhead.os), w.gzhead.extra && w.gzhead.extra.length && (f(w, 255 & w.gzhead.extra.length), f(w, w.gzhead.extra.length >> 8 & 255)), w.gzhead.hcrc && (_.adler = s(_.adler, w.pending_buf, w.pending, 0)), w.gzindex = 0, w.status = 69) : (f(w, 0), f(w, 0), f(w, 0), f(w, 0), f(w, 0), f(w, w.level === 9 ? 2 : w.strategy >= 2 || w.level < 2 ? 4 : 0), f(w, 3), w.status = 113);
          else {
            var L = 8 + (w.w_bits - 8 << 4) << 8;
            L |= (w.strategy >= 2 || w.level < 2 ? 0 : w.level < 6 ? 1 : w.level === 6 ? 2 : 3) << 6, w.strstart !== 0 && (L |= 32), L += 31 - L % 31, w.status = 113, v(w, L), w.strstart !== 0 && (v(w, _.adler >>> 16), v(w, 65535 & _.adler)), _.adler = 1;
          }
        if (w.status === 69)
          if (w.gzhead.extra) {
            for (x = w.pending; w.gzindex < (65535 & w.gzhead.extra.length) && (w.pending !== w.pending_buf_size || (w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), b(_), x = w.pending, w.pending !== w.pending_buf_size)); )
              f(w, 255 & w.gzhead.extra[w.gzindex]), w.gzindex++;
            w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), w.gzindex === w.gzhead.extra.length && (w.gzindex = 0, w.status = 73);
          } else
            w.status = 73;
        if (w.status === 73)
          if (w.gzhead.name) {
            x = w.pending;
            do {
              if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), b(_), x = w.pending, w.pending === w.pending_buf_size)) {
                H = 1;
                break;
              }
              H = w.gzindex < w.gzhead.name.length ? 255 & w.gzhead.name.charCodeAt(w.gzindex++) : 0, f(w, H);
            } while (H !== 0);
            w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), H === 0 && (w.gzindex = 0, w.status = 91);
          } else
            w.status = 91;
        if (w.status === 91)
          if (w.gzhead.comment) {
            x = w.pending;
            do {
              if (w.pending === w.pending_buf_size && (w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), b(_), x = w.pending, w.pending === w.pending_buf_size)) {
                H = 1;
                break;
              }
              H = w.gzindex < w.gzhead.comment.length ? 255 & w.gzhead.comment.charCodeAt(w.gzindex++) : 0, f(w, H);
            } while (H !== 0);
            w.gzhead.hcrc && w.pending > x && (_.adler = s(_.adler, w.pending_buf, w.pending - x, x)), H === 0 && (w.status = 103);
          } else
            w.status = 103;
        if (w.status === 103 && (w.gzhead.hcrc ? (w.pending + 2 > w.pending_buf_size && b(_), w.pending + 2 <= w.pending_buf_size && (f(w, 255 & _.adler), f(w, _.adler >> 8 & 255), _.adler = 0, w.status = 113)) : w.status = 113), w.pending !== 0) {
          if (b(_), _.avail_out === 0)
            return w.last_flush = -1, 0;
        } else if (_.avail_in === 0 && d(y) <= d(C) && y !== 4)
          return c(_, -5);
        if (w.status === 666 && _.avail_in !== 0)
          return c(_, -5);
        if (_.avail_in !== 0 || w.lookahead !== 0 || y !== 0 && w.status !== 666) {
          var N = w.strategy === 2 ? function(P, z) {
            for (var O; ; ) {
              if (P.lookahead === 0 && (j(P), P.lookahead === 0)) {
                if (z === 0)
                  return 1;
                break;
              }
              if (P.match_length = 0, O = l._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++, O && (h(P, !1), P.strm.avail_out === 0))
                return 1;
            }
            return P.insert = 0, z === 4 ? (h(P, !0), P.strm.avail_out === 0 ? 3 : 4) : P.last_lit && (h(P, !1), P.strm.avail_out === 0) ? 1 : 2;
          }(w, y) : w.strategy === 3 ? function(P, z) {
            for (var O, m, F, V, Q = P.window; ; ) {
              if (P.lookahead <= 258) {
                if (j(P), P.lookahead <= 258 && z === 0)
                  return 1;
                if (P.lookahead === 0)
                  break;
              }
              if (P.match_length = 0, P.lookahead >= 3 && P.strstart > 0 && (m = Q[F = P.strstart - 1]) === Q[++F] && m === Q[++F] && m === Q[++F]) {
                V = P.strstart + 258;
                do
                  ;
                while (m === Q[++F] && m === Q[++F] && m === Q[++F] && m === Q[++F] && m === Q[++F] && m === Q[++F] && m === Q[++F] && m === Q[++F] && F < V);
                P.match_length = 258 - (V - F), P.match_length > P.lookahead && (P.match_length = P.lookahead);
              }
              if (P.match_length >= 3 ? (O = l._tr_tally(P, 1, P.match_length - 3), P.lookahead -= P.match_length, P.strstart += P.match_length, P.match_length = 0) : (O = l._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++), O && (h(P, !1), P.strm.avail_out === 0))
                return 1;
            }
            return P.insert = 0, z === 4 ? (h(P, !0), P.strm.avail_out === 0 ? 3 : 4) : P.last_lit && (h(P, !1), P.strm.avail_out === 0) ? 1 : 2;
          }(w, y) : r[w.level].func(w, y);
          if (N !== 3 && N !== 4 || (w.status = 666), N === 1 || N === 3)
            return _.avail_out === 0 && (w.last_flush = -1), 0;
          if (N === 2 && (y === 1 ? l._tr_align(w) : y !== 5 && (l._tr_stored_block(w, 0, 0, !1), y === 3 && (T(w.head), w.lookahead === 0 && (w.strstart = 0, w.block_start = 0, w.insert = 0))), b(_), _.avail_out === 0))
            return w.last_flush = -1, 0;
        }
        return y !== 4 ? 0 : w.wrap <= 0 ? 1 : (w.wrap === 2 ? (f(w, 255 & _.adler), f(w, _.adler >> 8 & 255), f(w, _.adler >> 16 & 255), f(w, _.adler >> 24 & 255), f(w, 255 & _.total_in), f(w, _.total_in >> 8 & 255), f(w, _.total_in >> 16 & 255), f(w, _.total_in >> 24 & 255)) : (v(w, _.adler >>> 16), v(w, 65535 & _.adler)), b(_), w.wrap > 0 && (w.wrap = -w.wrap), w.pending !== 0 ? 0 : 1);
      }, t.deflateEnd = function(_) {
        var y;
        return _ && _.state ? (y = _.state.status) !== 42 && y !== 69 && y !== 73 && y !== 91 && y !== 103 && y !== 113 && y !== 666 ? c(_, -2) : (_.state = null, y === 113 ? c(_, -3) : 0) : -2;
      }, t.deflateSetDictionary = function(_, y) {
        var C, w, x, H, L, N, P, z, O = y.length;
        if (!_ || !_.state || (H = (C = _.state).wrap) === 2 || H === 1 && C.status !== 42 || C.lookahead)
          return -2;
        for (H === 1 && (_.adler = u(_.adler, y, O, 0)), C.wrap = 0, O >= C.w_size && (H === 0 && (T(C.head), C.strstart = 0, C.block_start = 0, C.insert = 0), z = new o.Buf8(C.w_size), o.arraySet(z, y, O - C.w_size, C.w_size, 0), y = z, O = C.w_size), L = _.avail_in, N = _.next_in, P = _.input, _.avail_in = O, _.next_in = 0, _.input = y, j(C); C.lookahead >= 3; ) {
          w = C.strstart, x = C.lookahead - 2;
          do
            C.ins_h = (C.ins_h << C.hash_shift ^ C.window[w + 3 - 1]) & C.hash_mask, C.prev[w & C.w_mask] = C.head[C.ins_h], C.head[C.ins_h] = w, w++;
          while (--x);
          C.strstart = w, C.lookahead = 2, j(C);
        }
        return C.strstart += C.lookahead, C.block_start = C.strstart, C.insert = C.lookahead, C.lookahead = 0, C.match_length = C.prev_length = 2, C.match_available = 0, _.next_in = N, _.input = P, _.avail_in = L, C.wrap = H, 0;
      }, t.deflateInfo = "pako deflate (from Nodeca project)";
    }, function(e, t, n) {
      var r = n(37);
      function o(m) {
        for (var F = m.length; --F >= 0; )
          m[F] = 0;
      }
      var l = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], u = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], g = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], c = new Array(576);
      o(c);
      var d = new Array(60);
      o(d);
      var T = new Array(512);
      o(T);
      var b = new Array(256);
      o(b);
      var h = new Array(29);
      o(h);
      var f, v, E, j = new Array(30);
      function B(m, F, V, Q, ee) {
        this.static_tree = m, this.extra_bits = F, this.extra_base = V, this.elems = Q, this.max_length = ee, this.has_stree = m && m.length;
      }
      function I(m, F) {
        this.dyn_tree = m, this.max_code = 0, this.stat_desc = F;
      }
      function R(m) {
        return m < 256 ? T[m] : T[256 + (m >>> 7)];
      }
      function p(m, F) {
        m.pending_buf[m.pending++] = 255 & F, m.pending_buf[m.pending++] = F >>> 8 & 255;
      }
      function M(m, F, V) {
        m.bi_valid > 16 - V ? (m.bi_buf |= F << m.bi_valid & 65535, p(m, m.bi_buf), m.bi_buf = F >> 16 - m.bi_valid, m.bi_valid += V - 16) : (m.bi_buf |= F << m.bi_valid & 65535, m.bi_valid += V);
      }
      function $(m, F, V) {
        M(m, V[2 * F], V[2 * F + 1]);
      }
      function Z(m, F) {
        var V = 0;
        do
          V |= 1 & m, m >>>= 1, V <<= 1;
        while (--F > 0);
        return V >>> 1;
      }
      function _(m, F, V) {
        var Q, ee, ne = new Array(16), Y = 0;
        for (Q = 1; Q <= 15; Q++)
          ne[Q] = Y = Y + V[Q - 1] << 1;
        for (ee = 0; ee <= F; ee++) {
          var G = m[2 * ee + 1];
          G !== 0 && (m[2 * ee] = Z(ne[G]++, G));
        }
      }
      function y(m) {
        var F;
        for (F = 0; F < 286; F++)
          m.dyn_ltree[2 * F] = 0;
        for (F = 0; F < 30; F++)
          m.dyn_dtree[2 * F] = 0;
        for (F = 0; F < 19; F++)
          m.bl_tree[2 * F] = 0;
        m.dyn_ltree[512] = 1, m.opt_len = m.static_len = 0, m.last_lit = m.matches = 0;
      }
      function C(m) {
        m.bi_valid > 8 ? p(m, m.bi_buf) : m.bi_valid > 0 && (m.pending_buf[m.pending++] = m.bi_buf), m.bi_buf = 0, m.bi_valid = 0;
      }
      function w(m, F, V, Q) {
        var ee = 2 * F, ne = 2 * V;
        return m[ee] < m[ne] || m[ee] === m[ne] && Q[F] <= Q[V];
      }
      function x(m, F, V) {
        for (var Q = m.heap[V], ee = V << 1; ee <= m.heap_len && (ee < m.heap_len && w(F, m.heap[ee + 1], m.heap[ee], m.depth) && ee++, !w(F, Q, m.heap[ee], m.depth)); )
          m.heap[V] = m.heap[ee], V = ee, ee <<= 1;
        m.heap[V] = Q;
      }
      function H(m, F, V) {
        var Q, ee, ne, Y, G = 0;
        if (m.last_lit !== 0)
          do
            Q = m.pending_buf[m.d_buf + 2 * G] << 8 | m.pending_buf[m.d_buf + 2 * G + 1], ee = m.pending_buf[m.l_buf + G], G++, Q === 0 ? $(m, ee, F) : ($(m, (ne = b[ee]) + 256 + 1, F), (Y = l[ne]) !== 0 && M(m, ee -= h[ne], Y), $(m, ne = R(--Q), V), (Y = u[ne]) !== 0 && M(m, Q -= j[ne], Y));
          while (G < m.last_lit);
        $(m, 256, F);
      }
      function L(m, F) {
        var V, Q, ee, ne = F.dyn_tree, Y = F.stat_desc.static_tree, G = F.stat_desc.has_stree, S = F.stat_desc.elems, A = -1;
        for (m.heap_len = 0, m.heap_max = 573, V = 0; V < S; V++)
          ne[2 * V] !== 0 ? (m.heap[++m.heap_len] = A = V, m.depth[V] = 0) : ne[2 * V + 1] = 0;
        for (; m.heap_len < 2; )
          ne[2 * (ee = m.heap[++m.heap_len] = A < 2 ? ++A : 0)] = 1, m.depth[ee] = 0, m.opt_len--, G && (m.static_len -= Y[2 * ee + 1]);
        for (F.max_code = A, V = m.heap_len >> 1; V >= 1; V--)
          x(m, ne, V);
        ee = S;
        do
          V = m.heap[1], m.heap[1] = m.heap[m.heap_len--], x(m, ne, 1), Q = m.heap[1], m.heap[--m.heap_max] = V, m.heap[--m.heap_max] = Q, ne[2 * ee] = ne[2 * V] + ne[2 * Q], m.depth[ee] = (m.depth[V] >= m.depth[Q] ? m.depth[V] : m.depth[Q]) + 1, ne[2 * V + 1] = ne[2 * Q + 1] = ee, m.heap[1] = ee++, x(m, ne, 1);
        while (m.heap_len >= 2);
        m.heap[--m.heap_max] = m.heap[1], function(U, J) {
          var K, re, se, fe, we, Ie, Ee = J.dyn_tree, Ce = J.max_code, Ae = J.stat_desc.static_tree, Oe = J.stat_desc.has_stree, Pe = J.stat_desc.extra_bits, qe = J.stat_desc.extra_base, et = J.stat_desc.max_length, Qe = 0;
          for (fe = 0; fe <= 15; fe++)
            U.bl_count[fe] = 0;
          for (Ee[2 * U.heap[U.heap_max] + 1] = 0, K = U.heap_max + 1; K < 573; K++)
            (fe = Ee[2 * Ee[2 * (re = U.heap[K]) + 1] + 1] + 1) > et && (fe = et, Qe++), Ee[2 * re + 1] = fe, re > Ce || (U.bl_count[fe]++, we = 0, re >= qe && (we = Pe[re - qe]), Ie = Ee[2 * re], U.opt_len += Ie * (fe + we), Oe && (U.static_len += Ie * (Ae[2 * re + 1] + we)));
          if (Qe !== 0) {
            do {
              for (fe = et - 1; U.bl_count[fe] === 0; )
                fe--;
              U.bl_count[fe]--, U.bl_count[fe + 1] += 2, U.bl_count[et]--, Qe -= 2;
            } while (Qe > 0);
            for (fe = et; fe !== 0; fe--)
              for (re = U.bl_count[fe]; re !== 0; )
                (se = U.heap[--K]) > Ce || (Ee[2 * se + 1] !== fe && (U.opt_len += (fe - Ee[2 * se + 1]) * Ee[2 * se], Ee[2 * se + 1] = fe), re--);
          }
        }(m, F), _(ne, A, m.bl_count);
      }
      function N(m, F, V) {
        var Q, ee, ne = -1, Y = F[1], G = 0, S = 7, A = 4;
        for (Y === 0 && (S = 138, A = 3), F[2 * (V + 1) + 1] = 65535, Q = 0; Q <= V; Q++)
          ee = Y, Y = F[2 * (Q + 1) + 1], ++G < S && ee === Y || (G < A ? m.bl_tree[2 * ee] += G : ee !== 0 ? (ee !== ne && m.bl_tree[2 * ee]++, m.bl_tree[32]++) : G <= 10 ? m.bl_tree[34]++ : m.bl_tree[36]++, G = 0, ne = ee, Y === 0 ? (S = 138, A = 3) : ee === Y ? (S = 6, A = 3) : (S = 7, A = 4));
      }
      function P(m, F, V) {
        var Q, ee, ne = -1, Y = F[1], G = 0, S = 7, A = 4;
        for (Y === 0 && (S = 138, A = 3), Q = 0; Q <= V; Q++)
          if (ee = Y, Y = F[2 * (Q + 1) + 1], !(++G < S && ee === Y)) {
            if (G < A)
              do
                $(m, ee, m.bl_tree);
              while (--G != 0);
            else
              ee !== 0 ? (ee !== ne && ($(m, ee, m.bl_tree), G--), $(m, 16, m.bl_tree), M(m, G - 3, 2)) : G <= 10 ? ($(m, 17, m.bl_tree), M(m, G - 3, 3)) : ($(m, 18, m.bl_tree), M(m, G - 11, 7));
            G = 0, ne = ee, Y === 0 ? (S = 138, A = 3) : ee === Y ? (S = 6, A = 3) : (S = 7, A = 4);
          }
      }
      o(j);
      var z = !1;
      function O(m, F, V, Q) {
        M(m, 0 + (Q ? 1 : 0), 3), function(ee, ne, Y, G) {
          C(ee), G && (p(ee, Y), p(ee, ~Y)), r.arraySet(ee.pending_buf, ee.window, ne, Y, ee.pending), ee.pending += Y;
        }(m, F, V, !0);
      }
      t._tr_init = function(m) {
        z || (function() {
          var F, V, Q, ee, ne, Y = new Array(16);
          for (Q = 0, ee = 0; ee < 28; ee++)
            for (h[ee] = Q, F = 0; F < 1 << l[ee]; F++)
              b[Q++] = ee;
          for (b[Q - 1] = ee, ne = 0, ee = 0; ee < 16; ee++)
            for (j[ee] = ne, F = 0; F < 1 << u[ee]; F++)
              T[ne++] = ee;
          for (ne >>= 7; ee < 30; ee++)
            for (j[ee] = ne << 7, F = 0; F < 1 << u[ee] - 7; F++)
              T[256 + ne++] = ee;
          for (V = 0; V <= 15; V++)
            Y[V] = 0;
          for (F = 0; F <= 143; )
            c[2 * F + 1] = 8, F++, Y[8]++;
          for (; F <= 255; )
            c[2 * F + 1] = 9, F++, Y[9]++;
          for (; F <= 279; )
            c[2 * F + 1] = 7, F++, Y[7]++;
          for (; F <= 287; )
            c[2 * F + 1] = 8, F++, Y[8]++;
          for (_(c, 287, Y), F = 0; F < 30; F++)
            d[2 * F + 1] = 5, d[2 * F] = Z(F, 5);
          f = new B(c, l, 257, 286, 15), v = new B(d, u, 0, 30, 15), E = new B(new Array(0), s, 0, 19, 7);
        }(), z = !0), m.l_desc = new I(m.dyn_ltree, f), m.d_desc = new I(m.dyn_dtree, v), m.bl_desc = new I(m.bl_tree, E), m.bi_buf = 0, m.bi_valid = 0, y(m);
      }, t._tr_stored_block = O, t._tr_flush_block = function(m, F, V, Q) {
        var ee, ne, Y = 0;
        m.level > 0 ? (m.strm.data_type === 2 && (m.strm.data_type = function(G) {
          var S, A = 4093624447;
          for (S = 0; S <= 31; S++, A >>>= 1)
            if (1 & A && G.dyn_ltree[2 * S] !== 0)
              return 0;
          if (G.dyn_ltree[18] !== 0 || G.dyn_ltree[20] !== 0 || G.dyn_ltree[26] !== 0)
            return 1;
          for (S = 32; S < 256; S++)
            if (G.dyn_ltree[2 * S] !== 0)
              return 1;
          return 0;
        }(m)), L(m, m.l_desc), L(m, m.d_desc), Y = function(G) {
          var S;
          for (N(G, G.dyn_ltree, G.l_desc.max_code), N(G, G.dyn_dtree, G.d_desc.max_code), L(G, G.bl_desc), S = 18; S >= 3 && G.bl_tree[2 * g[S] + 1] === 0; S--)
            ;
          return G.opt_len += 3 * (S + 1) + 5 + 5 + 4, S;
        }(m), ee = m.opt_len + 3 + 7 >>> 3, (ne = m.static_len + 3 + 7 >>> 3) <= ee && (ee = ne)) : ee = ne = V + 5, V + 4 <= ee && F !== -1 ? O(m, F, V, Q) : m.strategy === 4 || ne === ee ? (M(m, 2 + (Q ? 1 : 0), 3), H(m, c, d)) : (M(m, 4 + (Q ? 1 : 0), 3), function(G, S, A, U) {
          var J;
          for (M(G, S - 257, 5), M(G, A - 1, 5), M(G, U - 4, 4), J = 0; J < U; J++)
            M(G, G.bl_tree[2 * g[J] + 1], 3);
          P(G, G.dyn_ltree, S - 1), P(G, G.dyn_dtree, A - 1);
        }(m, m.l_desc.max_code + 1, m.d_desc.max_code + 1, Y + 1), H(m, m.dyn_ltree, m.dyn_dtree)), y(m), Q && C(m);
      }, t._tr_tally = function(m, F, V) {
        return m.pending_buf[m.d_buf + 2 * m.last_lit] = F >>> 8 & 255, m.pending_buf[m.d_buf + 2 * m.last_lit + 1] = 255 & F, m.pending_buf[m.l_buf + m.last_lit] = 255 & V, m.last_lit++, F === 0 ? m.dyn_ltree[2 * V]++ : (m.matches++, F--, m.dyn_ltree[2 * (b[V] + 256 + 1)]++, m.dyn_dtree[2 * R(F)]++), m.last_lit === m.lit_bufsize - 1;
      }, t._tr_align = function(m) {
        M(m, 2, 3), $(m, 256, c), function(F) {
          F.bi_valid === 16 ? (p(F, F.bi_buf), F.bi_buf = 0, F.bi_valid = 0) : F.bi_valid >= 8 && (F.pending_buf[F.pending++] = 255 & F.bi_buf, F.bi_buf >>= 8, F.bi_valid -= 8);
        }(m);
      };
    }, function(e, t, n) {
      e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, function(e, t, n) {
      var r = n(37), o = n(75), l = n(76), u = n(176), s = n(177);
      function g(I) {
        return (I >>> 24 & 255) + (I >>> 8 & 65280) + ((65280 & I) << 8) + ((255 & I) << 24);
      }
      function c() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function d(I) {
        var R;
        return I && I.state ? (R = I.state, I.total_in = I.total_out = R.total = 0, I.msg = "", R.wrap && (I.adler = 1 & R.wrap), R.mode = 1, R.last = 0, R.havedict = 0, R.dmax = 32768, R.head = null, R.hold = 0, R.bits = 0, R.lencode = R.lendyn = new r.Buf32(852), R.distcode = R.distdyn = new r.Buf32(592), R.sane = 1, R.back = -1, 0) : -2;
      }
      function T(I) {
        var R;
        return I && I.state ? ((R = I.state).wsize = 0, R.whave = 0, R.wnext = 0, d(I)) : -2;
      }
      function b(I, R) {
        var p, M;
        return I && I.state ? (M = I.state, R < 0 ? (p = 0, R = -R) : (p = 1 + (R >> 4), R < 48 && (R &= 15)), R && (R < 8 || R > 15) ? -2 : (M.window !== null && M.wbits !== R && (M.window = null), M.wrap = p, M.wbits = R, T(I))) : -2;
      }
      function h(I, R) {
        var p, M;
        return I ? (M = new c(), I.state = M, M.window = null, (p = b(I, R)) !== 0 && (I.state = null), p) : -2;
      }
      var f, v, E = !0;
      function j(I) {
        if (E) {
          var R;
          for (f = new r.Buf32(512), v = new r.Buf32(32), R = 0; R < 144; )
            I.lens[R++] = 8;
          for (; R < 256; )
            I.lens[R++] = 9;
          for (; R < 280; )
            I.lens[R++] = 7;
          for (; R < 288; )
            I.lens[R++] = 8;
          for (s(1, I.lens, 0, 288, f, 0, I.work, { bits: 9 }), R = 0; R < 32; )
            I.lens[R++] = 5;
          s(2, I.lens, 0, 32, v, 0, I.work, { bits: 5 }), E = !1;
        }
        I.lencode = f, I.lenbits = 9, I.distcode = v, I.distbits = 5;
      }
      function B(I, R, p, M) {
        var $, Z = I.state;
        return Z.window === null && (Z.wsize = 1 << Z.wbits, Z.wnext = 0, Z.whave = 0, Z.window = new r.Buf8(Z.wsize)), M >= Z.wsize ? (r.arraySet(Z.window, R, p - Z.wsize, Z.wsize, 0), Z.wnext = 0, Z.whave = Z.wsize) : (($ = Z.wsize - Z.wnext) > M && ($ = M), r.arraySet(Z.window, R, p - M, $, Z.wnext), (M -= $) ? (r.arraySet(Z.window, R, p - M, M, 0), Z.wnext = M, Z.whave = Z.wsize) : (Z.wnext += $, Z.wnext === Z.wsize && (Z.wnext = 0), Z.whave < Z.wsize && (Z.whave += $))), 0;
      }
      t.inflateReset = T, t.inflateReset2 = b, t.inflateResetKeep = d, t.inflateInit = function(I) {
        return h(I, 15);
      }, t.inflateInit2 = h, t.inflate = function(I, R) {
        var p, M, $, Z, _, y, C, w, x, H, L, N, P, z, O, m, F, V, Q, ee, ne, Y, G, S, A = 0, U = new r.Buf8(4), J = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!I || !I.state || !I.output || !I.input && I.avail_in !== 0)
          return -2;
        (p = I.state).mode === 12 && (p.mode = 13), _ = I.next_out, $ = I.output, C = I.avail_out, Z = I.next_in, M = I.input, y = I.avail_in, w = p.hold, x = p.bits, H = y, L = C, Y = 0;
        e:
          for (; ; )
            switch (p.mode) {
              case 1:
                if (p.wrap === 0) {
                  p.mode = 13;
                  break;
                }
                for (; x < 16; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if (2 & p.wrap && w === 35615) {
                  p.check = 0, U[0] = 255 & w, U[1] = w >>> 8 & 255, p.check = l(p.check, U, 2, 0), w = 0, x = 0, p.mode = 2;
                  break;
                }
                if (p.flags = 0, p.head && (p.head.done = !1), !(1 & p.wrap) || (((255 & w) << 8) + (w >> 8)) % 31) {
                  I.msg = "incorrect header check", p.mode = 30;
                  break;
                }
                if ((15 & w) != 8) {
                  I.msg = "unknown compression method", p.mode = 30;
                  break;
                }
                if (x -= 4, ne = 8 + (15 & (w >>>= 4)), p.wbits === 0)
                  p.wbits = ne;
                else if (ne > p.wbits) {
                  I.msg = "invalid window size", p.mode = 30;
                  break;
                }
                p.dmax = 1 << ne, I.adler = p.check = 1, p.mode = 512 & w ? 10 : 12, w = 0, x = 0;
                break;
              case 2:
                for (; x < 16; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if (p.flags = w, (255 & p.flags) != 8) {
                  I.msg = "unknown compression method", p.mode = 30;
                  break;
                }
                if (57344 & p.flags) {
                  I.msg = "unknown header flags set", p.mode = 30;
                  break;
                }
                p.head && (p.head.text = w >> 8 & 1), 512 & p.flags && (U[0] = 255 & w, U[1] = w >>> 8 & 255, p.check = l(p.check, U, 2, 0)), w = 0, x = 0, p.mode = 3;
              case 3:
                for (; x < 32; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                p.head && (p.head.time = w), 512 & p.flags && (U[0] = 255 & w, U[1] = w >>> 8 & 255, U[2] = w >>> 16 & 255, U[3] = w >>> 24 & 255, p.check = l(p.check, U, 4, 0)), w = 0, x = 0, p.mode = 4;
              case 4:
                for (; x < 16; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                p.head && (p.head.xflags = 255 & w, p.head.os = w >> 8), 512 & p.flags && (U[0] = 255 & w, U[1] = w >>> 8 & 255, p.check = l(p.check, U, 2, 0)), w = 0, x = 0, p.mode = 5;
              case 5:
                if (1024 & p.flags) {
                  for (; x < 16; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  p.length = w, p.head && (p.head.extra_len = w), 512 & p.flags && (U[0] = 255 & w, U[1] = w >>> 8 & 255, p.check = l(p.check, U, 2, 0)), w = 0, x = 0;
                } else
                  p.head && (p.head.extra = null);
                p.mode = 6;
              case 6:
                if (1024 & p.flags && ((N = p.length) > y && (N = y), N && (p.head && (ne = p.head.extra_len - p.length, p.head.extra || (p.head.extra = new Array(p.head.extra_len)), r.arraySet(p.head.extra, M, Z, N, ne)), 512 & p.flags && (p.check = l(p.check, M, N, Z)), y -= N, Z += N, p.length -= N), p.length))
                  break e;
                p.length = 0, p.mode = 7;
              case 7:
                if (2048 & p.flags) {
                  if (y === 0)
                    break e;
                  N = 0;
                  do
                    ne = M[Z + N++], p.head && ne && p.length < 65536 && (p.head.name += String.fromCharCode(ne));
                  while (ne && N < y);
                  if (512 & p.flags && (p.check = l(p.check, M, N, Z)), y -= N, Z += N, ne)
                    break e;
                } else
                  p.head && (p.head.name = null);
                p.length = 0, p.mode = 8;
              case 8:
                if (4096 & p.flags) {
                  if (y === 0)
                    break e;
                  N = 0;
                  do
                    ne = M[Z + N++], p.head && ne && p.length < 65536 && (p.head.comment += String.fromCharCode(ne));
                  while (ne && N < y);
                  if (512 & p.flags && (p.check = l(p.check, M, N, Z)), y -= N, Z += N, ne)
                    break e;
                } else
                  p.head && (p.head.comment = null);
                p.mode = 9;
              case 9:
                if (512 & p.flags) {
                  for (; x < 16; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  if (w !== (65535 & p.check)) {
                    I.msg = "header crc mismatch", p.mode = 30;
                    break;
                  }
                  w = 0, x = 0;
                }
                p.head && (p.head.hcrc = p.flags >> 9 & 1, p.head.done = !0), I.adler = p.check = 0, p.mode = 12;
                break;
              case 10:
                for (; x < 32; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                I.adler = p.check = g(w), w = 0, x = 0, p.mode = 11;
              case 11:
                if (p.havedict === 0)
                  return I.next_out = _, I.avail_out = C, I.next_in = Z, I.avail_in = y, p.hold = w, p.bits = x, 2;
                I.adler = p.check = 1, p.mode = 12;
              case 12:
                if (R === 5 || R === 6)
                  break e;
              case 13:
                if (p.last) {
                  w >>>= 7 & x, x -= 7 & x, p.mode = 27;
                  break;
                }
                for (; x < 3; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                switch (p.last = 1 & w, x -= 1, 3 & (w >>>= 1)) {
                  case 0:
                    p.mode = 14;
                    break;
                  case 1:
                    if (j(p), p.mode = 20, R === 6) {
                      w >>>= 2, x -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    p.mode = 17;
                    break;
                  case 3:
                    I.msg = "invalid block type", p.mode = 30;
                }
                w >>>= 2, x -= 2;
                break;
              case 14:
                for (w >>>= 7 & x, x -= 7 & x; x < 32; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if ((65535 & w) != (w >>> 16 ^ 65535)) {
                  I.msg = "invalid stored block lengths", p.mode = 30;
                  break;
                }
                if (p.length = 65535 & w, w = 0, x = 0, p.mode = 15, R === 6)
                  break e;
              case 15:
                p.mode = 16;
              case 16:
                if (N = p.length) {
                  if (N > y && (N = y), N > C && (N = C), N === 0)
                    break e;
                  r.arraySet($, M, Z, N, _), y -= N, Z += N, C -= N, _ += N, p.length -= N;
                  break;
                }
                p.mode = 12;
                break;
              case 17:
                for (; x < 14; ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if (p.nlen = 257 + (31 & w), w >>>= 5, x -= 5, p.ndist = 1 + (31 & w), w >>>= 5, x -= 5, p.ncode = 4 + (15 & w), w >>>= 4, x -= 4, p.nlen > 286 || p.ndist > 30) {
                  I.msg = "too many length or distance symbols", p.mode = 30;
                  break;
                }
                p.have = 0, p.mode = 18;
              case 18:
                for (; p.have < p.ncode; ) {
                  for (; x < 3; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  p.lens[J[p.have++]] = 7 & w, w >>>= 3, x -= 3;
                }
                for (; p.have < 19; )
                  p.lens[J[p.have++]] = 0;
                if (p.lencode = p.lendyn, p.lenbits = 7, G = { bits: p.lenbits }, Y = s(0, p.lens, 0, 19, p.lencode, 0, p.work, G), p.lenbits = G.bits, Y) {
                  I.msg = "invalid code lengths set", p.mode = 30;
                  break;
                }
                p.have = 0, p.mode = 19;
              case 19:
                for (; p.have < p.nlen + p.ndist; ) {
                  for (; m = (A = p.lencode[w & (1 << p.lenbits) - 1]) >>> 16 & 255, F = 65535 & A, !((O = A >>> 24) <= x); ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  if (F < 16)
                    w >>>= O, x -= O, p.lens[p.have++] = F;
                  else {
                    if (F === 16) {
                      for (S = O + 2; x < S; ) {
                        if (y === 0)
                          break e;
                        y--, w += M[Z++] << x, x += 8;
                      }
                      if (w >>>= O, x -= O, p.have === 0) {
                        I.msg = "invalid bit length repeat", p.mode = 30;
                        break;
                      }
                      ne = p.lens[p.have - 1], N = 3 + (3 & w), w >>>= 2, x -= 2;
                    } else if (F === 17) {
                      for (S = O + 3; x < S; ) {
                        if (y === 0)
                          break e;
                        y--, w += M[Z++] << x, x += 8;
                      }
                      x -= O, ne = 0, N = 3 + (7 & (w >>>= O)), w >>>= 3, x -= 3;
                    } else {
                      for (S = O + 7; x < S; ) {
                        if (y === 0)
                          break e;
                        y--, w += M[Z++] << x, x += 8;
                      }
                      x -= O, ne = 0, N = 11 + (127 & (w >>>= O)), w >>>= 7, x -= 7;
                    }
                    if (p.have + N > p.nlen + p.ndist) {
                      I.msg = "invalid bit length repeat", p.mode = 30;
                      break;
                    }
                    for (; N--; )
                      p.lens[p.have++] = ne;
                  }
                }
                if (p.mode === 30)
                  break;
                if (p.lens[256] === 0) {
                  I.msg = "invalid code -- missing end-of-block", p.mode = 30;
                  break;
                }
                if (p.lenbits = 9, G = { bits: p.lenbits }, Y = s(1, p.lens, 0, p.nlen, p.lencode, 0, p.work, G), p.lenbits = G.bits, Y) {
                  I.msg = "invalid literal/lengths set", p.mode = 30;
                  break;
                }
                if (p.distbits = 6, p.distcode = p.distdyn, G = { bits: p.distbits }, Y = s(2, p.lens, p.nlen, p.ndist, p.distcode, 0, p.work, G), p.distbits = G.bits, Y) {
                  I.msg = "invalid distances set", p.mode = 30;
                  break;
                }
                if (p.mode = 20, R === 6)
                  break e;
              case 20:
                p.mode = 21;
              case 21:
                if (y >= 6 && C >= 258) {
                  I.next_out = _, I.avail_out = C, I.next_in = Z, I.avail_in = y, p.hold = w, p.bits = x, u(I, L), _ = I.next_out, $ = I.output, C = I.avail_out, Z = I.next_in, M = I.input, y = I.avail_in, w = p.hold, x = p.bits, p.mode === 12 && (p.back = -1);
                  break;
                }
                for (p.back = 0; m = (A = p.lencode[w & (1 << p.lenbits) - 1]) >>> 16 & 255, F = 65535 & A, !((O = A >>> 24) <= x); ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if (m && !(240 & m)) {
                  for (V = O, Q = m, ee = F; m = (A = p.lencode[ee + ((w & (1 << V + Q) - 1) >> V)]) >>> 16 & 255, F = 65535 & A, !(V + (O = A >>> 24) <= x); ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  w >>>= V, x -= V, p.back += V;
                }
                if (w >>>= O, x -= O, p.back += O, p.length = F, m === 0) {
                  p.mode = 26;
                  break;
                }
                if (32 & m) {
                  p.back = -1, p.mode = 12;
                  break;
                }
                if (64 & m) {
                  I.msg = "invalid literal/length code", p.mode = 30;
                  break;
                }
                p.extra = 15 & m, p.mode = 22;
              case 22:
                if (p.extra) {
                  for (S = p.extra; x < S; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  p.length += w & (1 << p.extra) - 1, w >>>= p.extra, x -= p.extra, p.back += p.extra;
                }
                p.was = p.length, p.mode = 23;
              case 23:
                for (; m = (A = p.distcode[w & (1 << p.distbits) - 1]) >>> 16 & 255, F = 65535 & A, !((O = A >>> 24) <= x); ) {
                  if (y === 0)
                    break e;
                  y--, w += M[Z++] << x, x += 8;
                }
                if (!(240 & m)) {
                  for (V = O, Q = m, ee = F; m = (A = p.distcode[ee + ((w & (1 << V + Q) - 1) >> V)]) >>> 16 & 255, F = 65535 & A, !(V + (O = A >>> 24) <= x); ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  w >>>= V, x -= V, p.back += V;
                }
                if (w >>>= O, x -= O, p.back += O, 64 & m) {
                  I.msg = "invalid distance code", p.mode = 30;
                  break;
                }
                p.offset = F, p.extra = 15 & m, p.mode = 24;
              case 24:
                if (p.extra) {
                  for (S = p.extra; x < S; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  p.offset += w & (1 << p.extra) - 1, w >>>= p.extra, x -= p.extra, p.back += p.extra;
                }
                if (p.offset > p.dmax) {
                  I.msg = "invalid distance too far back", p.mode = 30;
                  break;
                }
                p.mode = 25;
              case 25:
                if (C === 0)
                  break e;
                if (N = L - C, p.offset > N) {
                  if ((N = p.offset - N) > p.whave && p.sane) {
                    I.msg = "invalid distance too far back", p.mode = 30;
                    break;
                  }
                  N > p.wnext ? (N -= p.wnext, P = p.wsize - N) : P = p.wnext - N, N > p.length && (N = p.length), z = p.window;
                } else
                  z = $, P = _ - p.offset, N = p.length;
                N > C && (N = C), C -= N, p.length -= N;
                do
                  $[_++] = z[P++];
                while (--N);
                p.length === 0 && (p.mode = 21);
                break;
              case 26:
                if (C === 0)
                  break e;
                $[_++] = p.length, C--, p.mode = 21;
                break;
              case 27:
                if (p.wrap) {
                  for (; x < 32; ) {
                    if (y === 0)
                      break e;
                    y--, w |= M[Z++] << x, x += 8;
                  }
                  if (L -= C, I.total_out += L, p.total += L, L && (I.adler = p.check = p.flags ? l(p.check, $, L, _ - L) : o(p.check, $, L, _ - L)), L = C, (p.flags ? w : g(w)) !== p.check) {
                    I.msg = "incorrect data check", p.mode = 30;
                    break;
                  }
                  w = 0, x = 0;
                }
                p.mode = 28;
              case 28:
                if (p.wrap && p.flags) {
                  for (; x < 32; ) {
                    if (y === 0)
                      break e;
                    y--, w += M[Z++] << x, x += 8;
                  }
                  if (w !== (4294967295 & p.total)) {
                    I.msg = "incorrect length check", p.mode = 30;
                    break;
                  }
                  w = 0, x = 0;
                }
                p.mode = 29;
              case 29:
                Y = 1;
                break e;
              case 30:
                Y = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return -2;
            }
        return I.next_out = _, I.avail_out = C, I.next_in = Z, I.avail_in = y, p.hold = w, p.bits = x, (p.wsize || L !== I.avail_out && p.mode < 30 && (p.mode < 27 || R !== 4)) && B(I, I.output, I.next_out, L - I.avail_out) ? (p.mode = 31, -4) : (H -= I.avail_in, L -= I.avail_out, I.total_in += H, I.total_out += L, p.total += L, p.wrap && L && (I.adler = p.check = p.flags ? l(p.check, $, L, I.next_out - L) : o(p.check, $, L, I.next_out - L)), I.data_type = p.bits + (p.last ? 64 : 0) + (p.mode === 12 ? 128 : 0) + (p.mode === 20 || p.mode === 15 ? 256 : 0), (H === 0 && L === 0 || R === 4) && Y === 0 && (Y = -5), Y);
      }, t.inflateEnd = function(I) {
        if (!I || !I.state)
          return -2;
        var R = I.state;
        return R.window && (R.window = null), I.state = null, 0;
      }, t.inflateGetHeader = function(I, R) {
        var p;
        return I && I.state && 2 & (p = I.state).wrap ? (p.head = R, R.done = !1, 0) : -2;
      }, t.inflateSetDictionary = function(I, R) {
        var p, M = R.length;
        return I && I.state ? (p = I.state).wrap !== 0 && p.mode !== 11 ? -2 : p.mode === 11 && o(1, R, M, 0) !== p.check ? -3 : B(I, R, M, M) ? (p.mode = 31, -4) : (p.havedict = 1, 0) : -2;
      }, t.inflateInfo = "pako inflate (from Nodeca project)";
    }, function(e, t, n) {
      e.exports = function(r, o) {
        var l, u, s, g, c, d, T, b, h, f, v, E, j, B, I, R, p, M, $, Z, _, y, C, w, x;
        l = r.state, u = r.next_in, w = r.input, s = u + (r.avail_in - 5), g = r.next_out, x = r.output, c = g - (o - r.avail_out), d = g + (r.avail_out - 257), T = l.dmax, b = l.wsize, h = l.whave, f = l.wnext, v = l.window, E = l.hold, j = l.bits, B = l.lencode, I = l.distcode, R = (1 << l.lenbits) - 1, p = (1 << l.distbits) - 1;
        e:
          do {
            j < 15 && (E += w[u++] << j, j += 8, E += w[u++] << j, j += 8), M = B[E & R];
            t:
              for (; ; ) {
                if (E >>>= $ = M >>> 24, j -= $, ($ = M >>> 16 & 255) === 0)
                  x[g++] = 65535 & M;
                else {
                  if (!(16 & $)) {
                    if (!(64 & $)) {
                      M = B[(65535 & M) + (E & (1 << $) - 1)];
                      continue t;
                    }
                    if (32 & $) {
                      l.mode = 12;
                      break e;
                    }
                    r.msg = "invalid literal/length code", l.mode = 30;
                    break e;
                  }
                  Z = 65535 & M, ($ &= 15) && (j < $ && (E += w[u++] << j, j += 8), Z += E & (1 << $) - 1, E >>>= $, j -= $), j < 15 && (E += w[u++] << j, j += 8, E += w[u++] << j, j += 8), M = I[E & p];
                  n:
                    for (; ; ) {
                      if (E >>>= $ = M >>> 24, j -= $, !(16 & ($ = M >>> 16 & 255))) {
                        if (!(64 & $)) {
                          M = I[(65535 & M) + (E & (1 << $) - 1)];
                          continue n;
                        }
                        r.msg = "invalid distance code", l.mode = 30;
                        break e;
                      }
                      if (_ = 65535 & M, j < ($ &= 15) && (E += w[u++] << j, (j += 8) < $ && (E += w[u++] << j, j += 8)), (_ += E & (1 << $) - 1) > T) {
                        r.msg = "invalid distance too far back", l.mode = 30;
                        break e;
                      }
                      if (E >>>= $, j -= $, _ > ($ = g - c)) {
                        if (($ = _ - $) > h && l.sane) {
                          r.msg = "invalid distance too far back", l.mode = 30;
                          break e;
                        }
                        if (y = 0, C = v, f === 0) {
                          if (y += b - $, $ < Z) {
                            Z -= $;
                            do
                              x[g++] = v[y++];
                            while (--$);
                            y = g - _, C = x;
                          }
                        } else if (f < $) {
                          if (y += b + f - $, ($ -= f) < Z) {
                            Z -= $;
                            do
                              x[g++] = v[y++];
                            while (--$);
                            if (y = 0, f < Z) {
                              Z -= $ = f;
                              do
                                x[g++] = v[y++];
                              while (--$);
                              y = g - _, C = x;
                            }
                          }
                        } else if (y += f - $, $ < Z) {
                          Z -= $;
                          do
                            x[g++] = v[y++];
                          while (--$);
                          y = g - _, C = x;
                        }
                        for (; Z > 2; )
                          x[g++] = C[y++], x[g++] = C[y++], x[g++] = C[y++], Z -= 3;
                        Z && (x[g++] = C[y++], Z > 1 && (x[g++] = C[y++]));
                      } else {
                        y = g - _;
                        do
                          x[g++] = x[y++], x[g++] = x[y++], x[g++] = x[y++], Z -= 3;
                        while (Z > 2);
                        Z && (x[g++] = x[y++], Z > 1 && (x[g++] = x[y++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (u < s && g < d);
        u -= Z = j >> 3, E &= (1 << (j -= Z << 3)) - 1, r.next_in = u, r.next_out = g, r.avail_in = u < s ? s - u + 5 : 5 - (u - s), r.avail_out = g < d ? d - g + 257 : 257 - (g - d), l.hold = E, l.bits = j;
      };
    }, function(e, t, n) {
      var r = n(37), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], s = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function(g, c, d, T, b, h, f, v) {
        var E, j, B, I, R, p, M, $, Z, _ = v.bits, y = 0, C = 0, w = 0, x = 0, H = 0, L = 0, N = 0, P = 0, z = 0, O = 0, m = null, F = 0, V = new r.Buf16(16), Q = new r.Buf16(16), ee = null, ne = 0;
        for (y = 0; y <= 15; y++)
          V[y] = 0;
        for (C = 0; C < T; C++)
          V[c[d + C]]++;
        for (H = _, x = 15; x >= 1 && V[x] === 0; x--)
          ;
        if (H > x && (H = x), x === 0)
          return b[h++] = 20971520, b[h++] = 20971520, v.bits = 1, 0;
        for (w = 1; w < x && V[w] === 0; w++)
          ;
        for (H < w && (H = w), P = 1, y = 1; y <= 15; y++)
          if (P <<= 1, (P -= V[y]) < 0)
            return -1;
        if (P > 0 && (g === 0 || x !== 1))
          return -1;
        for (Q[1] = 0, y = 1; y < 15; y++)
          Q[y + 1] = Q[y] + V[y];
        for (C = 0; C < T; C++)
          c[d + C] !== 0 && (f[Q[c[d + C]]++] = C);
        if (g === 0 ? (m = ee = f, p = 19) : g === 1 ? (m = o, F -= 257, ee = l, ne -= 257, p = 256) : (m = u, ee = s, p = -1), O = 0, C = 0, y = w, R = h, L = H, N = 0, B = -1, I = (z = 1 << H) - 1, g === 1 && z > 852 || g === 2 && z > 592)
          return 1;
        for (; ; ) {
          M = y - N, f[C] < p ? ($ = 0, Z = f[C]) : f[C] > p ? ($ = ee[ne + f[C]], Z = m[F + f[C]]) : ($ = 96, Z = 0), E = 1 << y - N, w = j = 1 << L;
          do
            b[R + (O >> N) + (j -= E)] = M << 24 | $ << 16 | Z | 0;
          while (j !== 0);
          for (E = 1 << y - 1; O & E; )
            E >>= 1;
          if (E !== 0 ? (O &= E - 1, O += E) : O = 0, C++, --V[y] == 0) {
            if (y === x)
              break;
            y = c[d + f[C]];
          }
          if (y > H && (O & I) !== B) {
            for (N === 0 && (N = H), R += w, P = 1 << (L = y - N); L + N < x && !((P -= V[L + N]) <= 0); )
              L++, P <<= 1;
            if (z += 1 << L, g === 1 && z > 852 || g === 2 && z > 592)
              return 1;
            b[B = O & I] = H << 24 | L << 16 | R - h | 0;
          }
        }
        return O !== 0 && (b[R + O] = y - N << 24 | 64 << 16 | 0), v.bits = H, 0;
      };
    }, function(e, t, n) {
      e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, function(e, t) {
    }, function(e, t, n) {
      function r(c, d) {
        var T = Object.keys(c);
        if (Object.getOwnPropertySymbols) {
          var b = Object.getOwnPropertySymbols(c);
          d && (b = b.filter(function(h) {
            return Object.getOwnPropertyDescriptor(c, h).enumerable;
          })), T.push.apply(T, b);
        }
        return T;
      }
      function o(c, d, T) {
        return d in c ? Object.defineProperty(c, d, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : c[d] = T, c;
      }
      function l(c, d) {
        for (var T = 0; T < d.length; T++) {
          var b = d[T];
          b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(c, b.key, b);
        }
      }
      var u = n(5).Buffer, s = n(181).inspect, g = s && s.custom || "inspect";
      e.exports = function() {
        function c() {
          (function(b, h) {
            if (!(b instanceof h))
              throw new TypeError("Cannot call a class as a function");
          })(this, c), this.head = null, this.tail = null, this.length = 0;
        }
        var d, T;
        return d = c, (T = [{ key: "push", value: function(b) {
          var h = { data: b, next: null };
          this.length > 0 ? this.tail.next = h : this.head = h, this.tail = h, ++this.length;
        } }, { key: "unshift", value: function(b) {
          var h = { data: b, next: this.head };
          this.length === 0 && (this.tail = h), this.head = h, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var b = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(b) {
          if (this.length === 0)
            return "";
          for (var h = this.head, f = "" + h.data; h = h.next; )
            f += b + h.data;
          return f;
        } }, { key: "concat", value: function(b) {
          if (this.length === 0)
            return u.alloc(0);
          for (var h, f, v, E = u.allocUnsafe(b >>> 0), j = this.head, B = 0; j; )
            h = j.data, f = E, v = B, u.prototype.copy.call(h, f, v), B += j.data.length, j = j.next;
          return E;
        } }, { key: "consume", value: function(b, h) {
          var f;
          return b < this.head.data.length ? (f = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : f = b === this.head.data.length ? this.shift() : h ? this._getString(b) : this._getBuffer(b), f;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(b) {
          var h = this.head, f = 1, v = h.data;
          for (b -= v.length; h = h.next; ) {
            var E = h.data, j = b > E.length ? E.length : b;
            if (j === E.length ? v += E : v += E.slice(0, b), (b -= j) == 0) {
              j === E.length ? (++f, h.next ? this.head = h.next : this.head = this.tail = null) : (this.head = h, h.data = E.slice(j));
              break;
            }
            ++f;
          }
          return this.length -= f, v;
        } }, { key: "_getBuffer", value: function(b) {
          var h = u.allocUnsafe(b), f = this.head, v = 1;
          for (f.data.copy(h), b -= f.data.length; f = f.next; ) {
            var E = f.data, j = b > E.length ? E.length : b;
            if (E.copy(h, h.length - b, 0, j), (b -= j) == 0) {
              j === E.length ? (++v, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = E.slice(j));
              break;
            }
            ++v;
          }
          return this.length -= v, h;
        } }, { key: g, value: function(b, h) {
          return s(this, function(f) {
            for (var v = 1; v < arguments.length; v++) {
              var E = arguments[v] != null ? arguments[v] : {};
              v % 2 ? r(Object(E), !0).forEach(function(j) {
                o(f, j, E[j]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(E)) : r(Object(E)).forEach(function(j) {
                Object.defineProperty(f, j, Object.getOwnPropertyDescriptor(E, j));
              });
            }
            return f;
          }({}, h, { depth: 0, customInspect: !1 }));
        } }]) && l(d.prototype, T), c;
      }();
    }, function(e, t) {
    }, function(e, t, n) {
      (function(r) {
        var o;
        function l(I, R, p) {
          return R in I ? Object.defineProperty(I, R, { value: p, enumerable: !0, configurable: !0, writable: !0 }) : I[R] = p, I;
        }
        var u = n(49), s = Symbol("lastResolve"), g = Symbol("lastReject"), c = Symbol("error"), d = Symbol("ended"), T = Symbol("lastPromise"), b = Symbol("handlePromise"), h = Symbol("stream");
        function f(I, R) {
          return { value: I, done: R };
        }
        function v(I) {
          var R = I[s];
          if (R !== null) {
            var p = I[h].read();
            p !== null && (I[T] = null, I[s] = null, I[g] = null, R(f(p, !1)));
          }
        }
        function E(I) {
          r.nextTick(v, I);
        }
        var j = Object.getPrototypeOf(function() {
        }), B = Object.setPrototypeOf((l(o = { get stream() {
          return this[h];
        }, next: function() {
          var I = this, R = this[c];
          if (R !== null)
            return Promise.reject(R);
          if (this[d])
            return Promise.resolve(f(void 0, !0));
          if (this[h].destroyed)
            return new Promise(function(Z, _) {
              r.nextTick(function() {
                I[c] ? _(I[c]) : Z(f(void 0, !0));
              });
            });
          var p, M = this[T];
          if (M)
            p = new Promise(function(Z, _) {
              return function(y, C) {
                Z.then(function() {
                  _[d] ? y(f(void 0, !0)) : _[b](y, C);
                }, C);
              };
            }(M, this));
          else {
            var $ = this[h].read();
            if ($ !== null)
              return Promise.resolve(f($, !1));
            p = new Promise(this[b]);
          }
          return this[T] = p, p;
        } }, Symbol.asyncIterator, function() {
          return this;
        }), l(o, "return", function() {
          var I = this;
          return new Promise(function(R, p) {
            I[h].destroy(null, function(M) {
              M ? p(M) : R(f(void 0, !0));
            });
          });
        }), o), j);
        e.exports = function(I) {
          var R, p = Object.create(B, (l(R = {}, h, { value: I, writable: !0 }), l(R, s, { value: null, writable: !0 }), l(R, g, { value: null, writable: !0 }), l(R, c, { value: null, writable: !0 }), l(R, d, { value: I._readableState.endEmitted, writable: !0 }), l(R, b, { value: function(M, $) {
            var Z = p[h].read();
            Z ? (p[T] = null, p[s] = null, p[g] = null, M(f(Z, !1))) : (p[s] = M, p[g] = $);
          }, writable: !0 }), R));
          return p[T] = null, u(I, function(M) {
            if (M && M.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var $ = p[g];
              return $ !== null && (p[T] = null, p[s] = null, p[g] = null, $(M)), void (p[c] = M);
            }
            var Z = p[s];
            Z !== null && (p[T] = null, p[s] = null, p[g] = null, Z(f(void 0, !0))), p[d] = !0;
          }), I.on("readable", E.bind(null, p)), p;
        };
      }).call(this, n(2));
    }, function(e, t) {
      e.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, function(e, t, n) {
      e.exports = o;
      var r = n(82);
      function o(l) {
        if (!(this instanceof o))
          return new o(l);
        r.call(this, l);
      }
      n(7)(o, r), o.prototype._transform = function(l, u, s) {
        s(null, l);
      };
    }, function(e, t, n) {
      var r, o = n(26).codes, l = o.ERR_MISSING_ARGS, u = o.ERR_STREAM_DESTROYED;
      function s(b) {
        if (b)
          throw b;
      }
      function g(b, h, f, v) {
        v = function(B) {
          var I = !1;
          return function() {
            I || (I = !0, B.apply(void 0, arguments));
          };
        }(v);
        var E = !1;
        b.on("close", function() {
          E = !0;
        }), r === void 0 && (r = n(49)), r(b, { readable: h, writable: f }, function(B) {
          if (B)
            return v(B);
          E = !0, v();
        });
        var j = !1;
        return function(B) {
          if (!E && !j)
            return j = !0, function(I) {
              return I.setHeader && typeof I.abort == "function";
            }(b) ? b.abort() : typeof b.destroy == "function" ? b.destroy() : void v(B || new u("pipe"));
        };
      }
      function c(b) {
        b();
      }
      function d(b, h) {
        return b.pipe(h);
      }
      function T(b) {
        return b.length ? typeof b[b.length - 1] != "function" ? s : b.pop() : s;
      }
      e.exports = function() {
        for (var b = arguments.length, h = new Array(b), f = 0; f < b; f++)
          h[f] = arguments[f];
        var v, E = T(h);
        if (Array.isArray(h[0]) && (h = h[0]), h.length < 2)
          throw new l("streams");
        var j = h.map(function(B, I) {
          var R = I < h.length - 1;
          return g(B, R, I > 0, function(p) {
            v || (v = p), p && j.forEach(c), R || (j.forEach(c), E(v));
          });
        });
        return h.reduce(d);
      };
    }, function(e, t, n) {
      var r = n(187)(function o(l, u) {
        return (u = u || {}).namespace = l, u.prod = !0, u.dev = !1, u.force || o.force ? o.yep(u) : o.nope(u);
      });
      e.exports = r;
    }, function(e, t) {
      var n = [], r = [], o = function() {
      };
      function l(f) {
        return !~n.indexOf(f) && (n.push(f), !0);
      }
      function u(f) {
        o = f;
      }
      function s(f) {
        for (var v = [], E = 0; E < n.length; E++)
          if (n[E].async)
            v.push(n[E]);
          else if (n[E](f))
            return !0;
        return !!v.length && new Promise(function(j) {
          Promise.all(v.map(function(B) {
            return B(f);
          })).then(function(B) {
            j(B.some(Boolean));
          });
        });
      }
      function g(f) {
        return !~r.indexOf(f) && (r.push(f), !0);
      }
      function c() {
        o.apply(o, arguments);
      }
      function d(f) {
        for (var v = 0; v < r.length; v++)
          f = r[v].apply(r[v], arguments);
        return f;
      }
      function T(f, v) {
        var E = Object.prototype.hasOwnProperty;
        for (var j in v)
          E.call(v, j) && (f[j] = v[j]);
        return f;
      }
      function b(f) {
        return f.enabled = !1, f.modify = g, f.set = u, f.use = l, T(function() {
          return !1;
        }, f);
      }
      function h(f) {
        return f.enabled = !0, f.modify = g, f.set = u, f.use = l, T(function() {
          var v = Array.prototype.slice.call(arguments, 0);
          return c.call(c, f, d(v, f)), !0;
        }, f);
      }
      e.exports = function(f) {
        return f.introduce = T, f.enabled = s, f.process = d, f.modify = g, f.write = c, f.nope = b, f.yep = h, f.set = u, f.use = l, f;
      };
    }, function(e, t, n) {
      (function(r) {
        var o = n(65), l = n(22).StringDecoder, u = n(32).Stream;
        function s() {
        }
        e.exports = function(g, c) {
          var d = r.alloc(65536), T = new l("utf8"), b = new u(), h = "", f = 0, v = 0;
          return g.start === -1 && delete g.start, b.readable = !0, b.destroy = function() {
            b.destroyed = !0, b.emit("end"), b.emit("close");
          }, o.open(g.file, "a+", "0644", function(E, j) {
            if (E)
              return c ? c(E) : b.emit("error", E), void b.destroy();
            (function B() {
              if (!b.destroyed)
                return o.read(j, d, 0, d.length, f, function(I, R) {
                  if (I)
                    return c ? c(I) : b.emit("error", I), void b.destroy();
                  if (!R)
                    return h && ((g.start == null || v > g.start) && (c ? c(null, h) : b.emit("line", h)), v++, h = ""), setTimeout(B, 1e3);
                  var p = T.write(d.slice(0, R));
                  c || b.emit("data", p);
                  for (var M = (p = (h + p).split(/\n+/)).length - 1, $ = 0; $ < M; $++)
                    (g.start == null || v > g.start) && (c ? c(null, p[$]) : b.emit("line", p[$])), v++;
                  return h = p[M], f += R, B();
                });
              o.close(j, s);
            })();
          }), c ? b.destroy : b;
        };
      }).call(this, n(5).Buffer);
    }, function(e, t, n) {
      (function(r, o) {
        function l(I) {
          return (l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
            return typeof R;
          } : function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
          })(I);
        }
        function u(I, R) {
          var p = Object.keys(I);
          if (Object.getOwnPropertySymbols) {
            var M = Object.getOwnPropertySymbols(I);
            R && (M = M.filter(function($) {
              return Object.getOwnPropertyDescriptor(I, $).enumerable;
            })), p.push.apply(p, M);
          }
          return p;
        }
        function s(I) {
          for (var R = 1; R < arguments.length; R++) {
            var p = arguments[R] != null ? arguments[R] : {};
            R % 2 ? u(Object(p), !0).forEach(function(M) {
              g(I, M, p[M]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(I, Object.getOwnPropertyDescriptors(p)) : u(Object(p)).forEach(function(M) {
              Object.defineProperty(I, M, Object.getOwnPropertyDescriptor(p, M));
            });
          }
          return I;
        }
        function g(I, R, p) {
          return R in I ? Object.defineProperty(I, R, { value: p, enumerable: !0, configurable: !0, writable: !0 }) : I[R] = p, I;
        }
        function c(I, R) {
          if (!(I instanceof R))
            throw new TypeError("Cannot call a class as a function");
        }
        function d(I, R) {
          for (var p = 0; p < R.length; p++) {
            var M = R[p];
            M.enumerable = M.enumerable || !1, M.configurable = !0, "value" in M && (M.writable = !0), Object.defineProperty(I, M.key, M);
          }
        }
        function T(I, R) {
          return (T = Object.setPrototypeOf || function(p, M) {
            return p.__proto__ = M, p;
          })(I, R);
        }
        function b(I) {
          var R = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return !1;
            if (typeof Proxy == "function")
              return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          }();
          return function() {
            var p, M = f(I);
            if (R) {
              var $ = f(this).constructor;
              p = Reflect.construct(M, arguments, $);
            } else
              p = M.apply(this, arguments);
            return h(this, p);
          };
        }
        function h(I, R) {
          return !R || l(R) !== "object" && typeof R != "function" ? function(p) {
            if (p === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return p;
          }(I) : R;
        }
        function f(I) {
          return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(R) {
            return R.__proto__ || Object.getPrototypeOf(R);
          })(I);
        }
        var v = n(83), E = n(200), j = n(32).Stream, B = n(20);
        e.exports = function(I) {
          (function(Z, _) {
            if (typeof _ != "function" && _ !== null)
              throw new TypeError("Super expression must either be null or a function");
            Z.prototype = Object.create(_ && _.prototype, { constructor: { value: Z, writable: !0, configurable: !0 } }), _ && T(Z, _);
          })($, I);
          var R, p, M = b($);
          function $() {
            var Z, _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return c(this, $), (Z = M.call(this, _)).options = _, Z.name = _.name || "http", Z.ssl = !!_.ssl, Z.host = _.host || "localhost", Z.port = _.port, Z.auth = _.auth, Z.path = _.path || "", Z.agent = _.agent, Z.headers = _.headers || {}, Z.headers["content-type"] = "application/json", Z.port || (Z.port = Z.ssl ? 443 : 80), Z;
          }
          return R = $, (p = [{ key: "log", value: function(Z, _) {
            var y = this;
            this._request(Z, function(C, w) {
              w && w.statusCode !== 200 && (C = new Error("Invalid HTTP Status Code: ".concat(w.statusCode))), C ? y.emit("warn", C) : y.emit("logged", Z);
            }), _ && r(_);
          } }, { key: "query", value: function(Z, _) {
            typeof Z == "function" && (_ = Z, Z = {}), (Z = { method: "query", params: this.normalizeQuery(Z) }).params.path && (Z.path = Z.params.path, delete Z.params.path), Z.params.auth && (Z.auth = Z.params.auth, delete Z.params.auth), this._request(Z, function(y, C, w) {
              if (C && C.statusCode !== 200 && (y = new Error("Invalid HTTP Status Code: ".concat(C.statusCode))), y)
                return _(y);
              if (typeof w == "string")
                try {
                  w = JSON.parse(w);
                } catch (x) {
                  return _(x);
                }
              _(null, w);
            });
          } }, { key: "stream", value: function() {
            var Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ = new j();
            (Z = { method: "stream", params: Z }).params.path && (Z.path = Z.params.path, delete Z.params.path), Z.params.auth && (Z.auth = Z.params.auth, delete Z.params.auth);
            var y = "", C = this._request(Z);
            return _.destroy = function() {
              return C.destroy();
            }, C.on("data", function(w) {
              for (var x = (w = (y + w).split(/\n+/)).length - 1, H = 0; H < x; H++)
                try {
                  _.emit("log", JSON.parse(w[H]));
                } catch (L) {
                  _.emit("error", L);
                }
              y = w[x];
            }), C.on("error", function(w) {
              return _.emit("error", w);
            }), _;
          } }, { key: "_request", value: function(Z, _) {
            var y = (Z = Z || {}).auth || this.auth, C = Z.path || this.path || "";
            delete Z.auth, delete Z.path;
            var w = Object.assign({}, this.headers);
            y && y.bearer && (w.Authorization = "Bearer ".concat(y.bearer));
            var x = (this.ssl ? E : v).request(s(s({}, this.options), {}, { method: "POST", host: this.host, port: this.port, path: "/".concat(C.replace(/^\//, "")), headers: w, auth: y && y.username && y.password ? "".concat(y.username, ":").concat(y.password) : "", agent: this.agent }));
            x.on("error", _), x.on("response", function(H) {
              return H.on("end", function() {
                return _(null, H);
              }).resume();
            }), x.end(o.from(JSON.stringify(Z), "utf8"));
          } }]) && d(R.prototype, p), $;
        }(B);
      }).call(this, n(15).setImmediate, n(5).Buffer);
    }, function(e, t, n) {
      (function(r, o, l) {
        var u = n(84), s = n(7), g = n(85), c = n(31), d = n(191), T = g.IncomingMessage, b = g.readyStates, h = e.exports = function(v) {
          var E, j = this;
          c.Writable.call(j), j._opts = v, j._body = [], j._headers = {}, v.auth && j.setHeader("Authorization", "Basic " + new r(v.auth).toString("base64")), Object.keys(v.headers).forEach(function(I) {
            j.setHeader(I, v.headers[I]);
          });
          var B = !0;
          if (v.mode === "disable-fetch" || "requestTimeout" in v && !u.abortController)
            B = !1, E = !0;
          else if (v.mode === "prefer-streaming")
            E = !1;
          else if (v.mode === "allow-wrong-content-type")
            E = !u.overrideMimeType;
          else {
            if (v.mode && v.mode !== "default" && v.mode !== "prefer-fast")
              throw new Error("Invalid value for opts.mode");
            E = !0;
          }
          j._mode = function(I, R) {
            return u.fetch && R ? "fetch" : u.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : u.msstream ? "ms-stream" : u.arraybuffer && I ? "arraybuffer" : u.vbArray && I ? "text:vbarray" : "text";
          }(E, B), j._fetchTimer = null, j.on("finish", function() {
            j._onFinish();
          });
        };
        s(h, c.Writable), h.prototype.setHeader = function(v, E) {
          var j = v.toLowerCase();
          f.indexOf(j) === -1 && (this._headers[j] = { name: v, value: E });
        }, h.prototype.getHeader = function(v) {
          var E = this._headers[v.toLowerCase()];
          return E ? E.value : null;
        }, h.prototype.removeHeader = function(v) {
          delete this._headers[v.toLowerCase()];
        }, h.prototype._onFinish = function() {
          var v = this;
          if (!v._destroyed) {
            var E = v._opts, j = v._headers, B = null;
            E.method !== "GET" && E.method !== "HEAD" && (B = u.arraybuffer ? d(r.concat(v._body)) : u.blobConstructor ? new o.Blob(v._body.map(function($) {
              return d($);
            }), { type: (j["content-type"] || {}).value || "" }) : r.concat(v._body).toString());
            var I = [];
            if (Object.keys(j).forEach(function($) {
              var Z = j[$].name, _ = j[$].value;
              Array.isArray(_) ? _.forEach(function(y) {
                I.push([Z, y]);
              }) : I.push([Z, _]);
            }), v._mode === "fetch") {
              var R = null;
              if (u.abortController) {
                var p = new AbortController();
                R = p.signal, v._fetchAbortController = p, "requestTimeout" in E && E.requestTimeout !== 0 && (v._fetchTimer = o.setTimeout(function() {
                  v.emit("requestTimeout"), v._fetchAbortController && v._fetchAbortController.abort();
                }, E.requestTimeout));
              }
              o.fetch(v._opts.url, { method: v._opts.method, headers: I, body: B || void 0, mode: "cors", credentials: E.withCredentials ? "include" : "same-origin", signal: R }).then(function($) {
                v._fetchResponse = $, v._connect();
              }, function($) {
                o.clearTimeout(v._fetchTimer), v._destroyed || v.emit("error", $);
              });
            } else {
              var M = v._xhr = new o.XMLHttpRequest();
              try {
                M.open(v._opts.method, v._opts.url, !0);
              } catch ($) {
                return void l.nextTick(function() {
                  v.emit("error", $);
                });
              }
              "responseType" in M && (M.responseType = v._mode.split(":")[0]), "withCredentials" in M && (M.withCredentials = !!E.withCredentials), v._mode === "text" && "overrideMimeType" in M && M.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in E && (M.timeout = E.requestTimeout, M.ontimeout = function() {
                v.emit("requestTimeout");
              }), I.forEach(function($) {
                M.setRequestHeader($[0], $[1]);
              }), v._response = null, M.onreadystatechange = function() {
                switch (M.readyState) {
                  case b.LOADING:
                  case b.DONE:
                    v._onXHRProgress();
                }
              }, v._mode === "moz-chunked-arraybuffer" && (M.onprogress = function() {
                v._onXHRProgress();
              }), M.onerror = function() {
                v._destroyed || v.emit("error", new Error("XHR error"));
              };
              try {
                M.send(B);
              } catch ($) {
                return void l.nextTick(function() {
                  v.emit("error", $);
                });
              }
            }
          }
        }, h.prototype._onXHRProgress = function() {
          (function(v) {
            try {
              var E = v.status;
              return E !== null && E !== 0;
            } catch {
              return !1;
            }
          })(this._xhr) && !this._destroyed && (this._response || this._connect(), this._response._onXHRProgress());
        }, h.prototype._connect = function() {
          var v = this;
          v._destroyed || (v._response = new T(v._xhr, v._fetchResponse, v._mode, v._fetchTimer), v._response.on("error", function(E) {
            v.emit("error", E);
          }), v.emit("response", v._response));
        }, h.prototype._write = function(v, E, j) {
          this._body.push(v), j();
        }, h.prototype.abort = h.prototype.destroy = function() {
          this._destroyed = !0, o.clearTimeout(this._fetchTimer), this._response && (this._response._destroyed = !0), this._xhr ? this._xhr.abort() : this._fetchAbortController && this._fetchAbortController.abort();
        }, h.prototype.end = function(v, E, j) {
          typeof v == "function" && (j = v, v = void 0), c.Writable.prototype.end.call(this, v, E, j);
        }, h.prototype.flushHeaders = function() {
        }, h.prototype.setTimeout = function() {
        }, h.prototype.setNoDelay = function() {
        }, h.prototype.setSocketKeepAlive = function() {
        };
        var f = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
      }).call(this, n(5).Buffer, n(6), n(2));
    }, function(e, t, n) {
      var r = n(5).Buffer;
      e.exports = function(o) {
        if (o instanceof Uint8Array) {
          if (o.byteOffset === 0 && o.byteLength === o.buffer.byteLength)
            return o.buffer;
          if (typeof o.buffer.slice == "function")
            return o.buffer.slice(o.byteOffset, o.byteOffset + o.byteLength);
        }
        if (r.isBuffer(o)) {
          for (var l = new Uint8Array(o.length), u = o.length, s = 0; s < u; s++)
            l[s] = o[s];
          return l.buffer;
        }
        throw new Error("Argument must be a Buffer");
      };
    }, function(e, t) {
      e.exports = function() {
        for (var r = {}, o = 0; o < arguments.length; o++) {
          var l = arguments[o];
          for (var u in l)
            n.call(l, u) && (r[u] = l[u]);
        }
        return r;
      };
      var n = Object.prototype.hasOwnProperty;
    }, function(e, t) {
      e.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
    }, function(e, t, n) {
      (function(r, o) {
        var l;
        (function(u) {
          t && t.nodeType, r && r.nodeType;
          var s = typeof o == "object" && o;
          s.global !== s && s.window !== s && s.self;
          var g, c = 2147483647, d = /^xn--/, T = /[^\x20-\x7E]/, b = /[\x2E\u3002\uFF0E\uFF61]/g, h = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f = Math.floor, v = String.fromCharCode;
          function E(_) {
            throw new RangeError(h[_]);
          }
          function j(_, y) {
            for (var C = _.length, w = []; C--; )
              w[C] = y(_[C]);
            return w;
          }
          function B(_, y) {
            var C = _.split("@"), w = "";
            return C.length > 1 && (w = C[0] + "@", _ = C[1]), w + j((_ = _.replace(b, ".")).split("."), y).join(".");
          }
          function I(_) {
            for (var y, C, w = [], x = 0, H = _.length; x < H; )
              (y = _.charCodeAt(x++)) >= 55296 && y <= 56319 && x < H ? (64512 & (C = _.charCodeAt(x++))) == 56320 ? w.push(((1023 & y) << 10) + (1023 & C) + 65536) : (w.push(y), x--) : w.push(y);
            return w;
          }
          function R(_) {
            return j(_, function(y) {
              var C = "";
              return y > 65535 && (C += v((y -= 65536) >>> 10 & 1023 | 55296), y = 56320 | 1023 & y), C += v(y);
            }).join("");
          }
          function p(_, y) {
            return _ + 22 + 75 * (_ < 26) - ((y != 0) << 5);
          }
          function M(_, y, C) {
            var w = 0;
            for (_ = C ? f(_ / 700) : _ >> 1, _ += f(_ / y); _ > 455; w += 36)
              _ = f(_ / 35);
            return f(w + 36 * _ / (_ + 38));
          }
          function $(_) {
            var y, C, w, x, H, L, N, P, z, O, m, F = [], V = _.length, Q = 0, ee = 128, ne = 72;
            for ((C = _.lastIndexOf("-")) < 0 && (C = 0), w = 0; w < C; ++w)
              _.charCodeAt(w) >= 128 && E("not-basic"), F.push(_.charCodeAt(w));
            for (x = C > 0 ? C + 1 : 0; x < V; ) {
              for (H = Q, L = 1, N = 36; x >= V && E("invalid-input"), ((P = (m = _.charCodeAt(x++)) - 48 < 10 ? m - 22 : m - 65 < 26 ? m - 65 : m - 97 < 26 ? m - 97 : 36) >= 36 || P > f((c - Q) / L)) && E("overflow"), Q += P * L, !(P < (z = N <= ne ? 1 : N >= ne + 26 ? 26 : N - ne)); N += 36)
                L > f(c / (O = 36 - z)) && E("overflow"), L *= O;
              ne = M(Q - H, y = F.length + 1, H == 0), f(Q / y) > c - ee && E("overflow"), ee += f(Q / y), Q %= y, F.splice(Q++, 0, ee);
            }
            return R(F);
          }
          function Z(_) {
            var y, C, w, x, H, L, N, P, z, O, m, F, V, Q, ee, ne = [];
            for (F = (_ = I(_)).length, y = 128, C = 0, H = 72, L = 0; L < F; ++L)
              (m = _[L]) < 128 && ne.push(v(m));
            for (w = x = ne.length, x && ne.push("-"); w < F; ) {
              for (N = c, L = 0; L < F; ++L)
                (m = _[L]) >= y && m < N && (N = m);
              for (N - y > f((c - C) / (V = w + 1)) && E("overflow"), C += (N - y) * V, y = N, L = 0; L < F; ++L)
                if ((m = _[L]) < y && ++C > c && E("overflow"), m == y) {
                  for (P = C, z = 36; !(P < (O = z <= H ? 1 : z >= H + 26 ? 26 : z - H)); z += 36)
                    ee = P - O, Q = 36 - O, ne.push(v(p(O + ee % Q, 0))), P = f(ee / Q);
                  ne.push(v(p(P, 0))), H = M(C, V, w == x), C = 0, ++w;
                }
              ++C, ++y;
            }
            return ne.join("");
          }
          g = { version: "1.4.1", ucs2: { decode: I, encode: R }, decode: $, encode: Z, toASCII: function(_) {
            return B(_, function(y) {
              return T.test(y) ? "xn--" + Z(y) : y;
            });
          }, toUnicode: function(_) {
            return B(_, function(y) {
              return d.test(y) ? $(y.slice(4).toLowerCase()) : y;
            });
          } }, (l = function() {
            return g;
          }.call(t, n, t, r)) === void 0 || (r.exports = l);
        })();
      }).call(this, n(195)(e), n(6));
    }, function(e, t) {
      e.exports = function(n) {
        return n.webpackPolyfill || (n.deprecate = function() {
        }, n.paths = [], n.children || (n.children = []), Object.defineProperty(n, "loaded", { enumerable: !0, get: function() {
          return n.l;
        } }), Object.defineProperty(n, "id", { enumerable: !0, get: function() {
          return n.i;
        } }), n.webpackPolyfill = 1), n;
      };
    }, function(e, t, n) {
      e.exports = { isString: function(r) {
        return typeof r == "string";
      }, isObject: function(r) {
        return typeof r == "object" && r !== null;
      }, isNull: function(r) {
        return r === null;
      }, isNullOrUndefined: function(r) {
        return r == null;
      } };
    }, function(e, t, n) {
      t.decode = t.parse = n(198), t.encode = t.stringify = n(199);
    }, function(e, t, n) {
      function r(l, u) {
        return Object.prototype.hasOwnProperty.call(l, u);
      }
      e.exports = function(l, u, s, g) {
        u = u || "&", s = s || "=";
        var c = {};
        if (typeof l != "string" || l.length === 0)
          return c;
        var d = /\+/g;
        l = l.split(u);
        var T = 1e3;
        g && typeof g.maxKeys == "number" && (T = g.maxKeys);
        var b = l.length;
        T > 0 && b > T && (b = T);
        for (var h = 0; h < b; ++h) {
          var f, v, E, j, B = l[h].replace(d, "%20"), I = B.indexOf(s);
          I >= 0 ? (f = B.substr(0, I), v = B.substr(I + 1)) : (f = B, v = ""), E = decodeURIComponent(f), j = decodeURIComponent(v), r(c, E) ? o(c[E]) ? c[E].push(j) : c[E] = [c[E], j] : c[E] = j;
        }
        return c;
      };
      var o = Array.isArray || function(l) {
        return Object.prototype.toString.call(l) === "[object Array]";
      };
    }, function(e, t, n) {
      var r = function(s) {
        switch (typeof s) {
          case "string":
            return s;
          case "boolean":
            return s ? "true" : "false";
          case "number":
            return isFinite(s) ? s : "";
          default:
            return "";
        }
      };
      e.exports = function(s, g, c, d) {
        return g = g || "&", c = c || "=", s === null && (s = void 0), typeof s == "object" ? l(u(s), function(T) {
          var b = encodeURIComponent(r(T)) + c;
          return o(s[T]) ? l(s[T], function(h) {
            return b + encodeURIComponent(r(h));
          }).join(g) : b + encodeURIComponent(r(s[T]));
        }).join(g) : d ? encodeURIComponent(r(d)) + c + encodeURIComponent(r(s)) : "";
      };
      var o = Array.isArray || function(s) {
        return Object.prototype.toString.call(s) === "[object Array]";
      };
      function l(s, g) {
        if (s.map)
          return s.map(g);
        for (var c = [], d = 0; d < s.length; d++)
          c.push(g(s[d], d));
        return c;
      }
      var u = Object.keys || function(s) {
        var g = [];
        for (var c in s)
          Object.prototype.hasOwnProperty.call(s, c) && g.push(c);
        return g;
      };
    }, function(e, t, n) {
      var r = n(83), o = n(86), l = e.exports;
      for (var u in r)
        r.hasOwnProperty(u) && (l[u] = r[u]);
      function s(g) {
        if (typeof g == "string" && (g = o.parse(g)), g.protocol || (g.protocol = "https:"), g.protocol !== "https:")
          throw new Error('Protocol "' + g.protocol + '" not supported. Expected "https:"');
        return g;
      }
      l.request = function(g, c) {
        return g = s(g), r.request.call(this, g, c);
      }, l.get = function(g, c) {
        return g = s(g), r.get.call(this, g, c);
      };
    }, function(e, t, n) {
      (function(r) {
        function o(v) {
          return (o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          })(v);
        }
        function l(v, E) {
          if (!(v instanceof E))
            throw new TypeError("Cannot call a class as a function");
        }
        function u(v, E) {
          for (var j = 0; j < E.length; j++) {
            var B = E[j];
            B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(v, B.key, B);
          }
        }
        function s(v, E) {
          return (s = Object.setPrototypeOf || function(j, B) {
            return j.__proto__ = B, j;
          })(v, E);
        }
        function g(v) {
          var E = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return !1;
            if (typeof Proxy == "function")
              return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          }();
          return function() {
            var j, B = d(v);
            if (E) {
              var I = d(this).constructor;
              j = Reflect.construct(B, arguments, I);
            } else
              j = B.apply(this, arguments);
            return c(this, j);
          };
        }
        function c(v, E) {
          return !E || o(E) !== "object" && typeof E != "function" ? function(j) {
            if (j === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return j;
          }(v) : E;
        }
        function d(v) {
          return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(E) {
            return E.__proto__ || Object.getPrototypeOf(E);
          })(v);
        }
        var T = n(87), b = n(3).MESSAGE, h = n(18), f = n(20);
        e.exports = function(v) {
          (function(R, p) {
            if (typeof p != "function" && p !== null)
              throw new TypeError("Super expression must either be null or a function");
            R.prototype = Object.create(p && p.prototype, { constructor: { value: R, writable: !0, configurable: !0 } }), p && s(R, p);
          })(I, v);
          var E, j, B = g(I);
          function I() {
            var R, p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (l(this, I), R = B.call(this, p), !p.stream || !T(p.stream))
              throw new Error("options.stream is required.");
            return R._stream = p.stream, R._stream.setMaxListeners(1 / 0), R.isObjectMode = p.stream._writableState.objectMode, R.eol = p.eol || h.EOL, R;
          }
          return E = I, (j = [{ key: "log", value: function(R, p) {
            var M = this;
            if (r(function() {
              return M.emit("logged", R);
            }), this.isObjectMode)
              return this._stream.write(R), void (p && p());
            this._stream.write("".concat(R[b]).concat(this.eol)), p && p();
          } }]) && u(E.prototype, j), I;
        }(f);
      }).call(this, n(15).setImmediate);
    }, function(e, t, n) {
      (function(r) {
        function o(w, x, H) {
          return x in w ? Object.defineProperty(w, x, { value: H, enumerable: !0, configurable: !0, writable: !0 }) : w[x] = H, w;
        }
        function l(w) {
          return (l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(x) {
            return typeof x;
          } : function(x) {
            return x && typeof Symbol == "function" && x.constructor === Symbol && x !== Symbol.prototype ? "symbol" : typeof x;
          })(w);
        }
        function u(w, x) {
          for (var H = 0; H < x.length; H++) {
            var L = x[H];
            L.enumerable = L.enumerable || !1, L.configurable = !0, "value" in L && (L.writable = !0), Object.defineProperty(w, L.key, L);
          }
        }
        function s(w, x) {
          return (s = Object.setPrototypeOf || function(H, L) {
            return H.__proto__ = L, H;
          })(w, x);
        }
        function g(w) {
          var x = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return !1;
            if (typeof Proxy == "function")
              return !0;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), !0;
            } catch {
              return !1;
            }
          }();
          return function() {
            var H, L = d(w);
            if (x) {
              var N = d(this).constructor;
              H = Reflect.construct(L, arguments, N);
            } else
              H = L.apply(this, arguments);
            return c(this, H);
          };
        }
        function c(w, x) {
          return !x || l(x) !== "object" && typeof x != "function" ? function(H) {
            if (H === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return H;
          }(w) : x;
        }
        function d(w) {
          return (d = Object.setPrototypeOf ? Object.getPrototypeOf : function(x) {
            return x.__proto__ || Object.getPrototypeOf(x);
          })(w);
        }
        var T = n(32), b = T.Stream, h = T.Transform, f = n(51), v = n(3), E = v.LEVEL, j = v.SPLAT, B = n(87), I = n(89), R = n(93), p = n(206), M = n(207), $ = n(61).warn, Z = n(50), _ = /%[scdjifoO%]/g, y = function(w) {
          (function(P, z) {
            if (typeof z != "function" && z !== null)
              throw new TypeError("Super expression must either be null or a function");
            P.prototype = Object.create(z && z.prototype, { constructor: { value: P, writable: !0, configurable: !0 } }), z && s(P, z);
          })(N, w);
          var x, H, L = g(N);
          function N(P) {
            var z;
            return function(O, m) {
              if (!(O instanceof m))
                throw new TypeError("Cannot call a class as a function");
            }(this, N), (z = L.call(this, { objectMode: !0 })).configure(P), z;
          }
          return x = N, (H = [{ key: "child", value: function(P) {
            var z = this;
            return Object.create(z, { write: { value: function(O) {
              var m = Object.assign({}, P, O);
              O instanceof Error && (m.stack = O.stack, m.message = O.message), z.write(m);
            } } });
          } }, { key: "configure", value: function() {
            var P = this, z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, O = z.silent, m = z.format, F = z.defaultMeta, V = z.levels, Q = z.level, ee = Q === void 0 ? "info" : Q, ne = z.exitOnError, Y = ne === void 0 || ne, G = z.transports, S = z.colors, A = z.emitErrs, U = z.formatters, J = z.padLevels, K = z.rewriters, re = z.stripColors, se = z.exceptionHandlers, fe = z.rejectionHandlers;
            if (this.transports.length && this.clear(), this.silent = O, this.format = m || this.format || n(208)(), this.defaultMeta = F || null, this.levels = V || this.levels || Z.npm.levels, this.level = ee, this.exceptions = new I(this), this.rejections = new R(this), this.profilers = {}, this.exitOnError = Y, G && (G = Array.isArray(G) ? G : [G]).forEach(function(we) {
              return P.add(we);
            }), S || A || U || J || K || re)
              throw new Error(["{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.", "Use a custom winston.format(function) instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
            se && this.exceptions.handle(se), fe && this.rejections.handle(fe);
          } }, { key: "isLevelEnabled", value: function(P) {
            var z = this, O = C(this.levels, P);
            if (O === null)
              return !1;
            var m = C(this.levels, this.level);
            return m !== null && (this.transports && this.transports.length !== 0 ? this.transports.findIndex(function(F) {
              var V = C(z.levels, F.level);
              return V === null && (V = m), V >= O;
            }) !== -1 : m >= O);
          } }, { key: "log", value: function(P, z) {
            for (var O, m, F = arguments.length, V = new Array(F > 2 ? F - 2 : 0), Q = 2; Q < F; Q++)
              V[Q - 2] = arguments[Q];
            if (arguments.length === 1)
              return P[E] = P.level, this._addDefaultMeta(P), this.write(P), this;
            if (arguments.length === 2)
              return z && l(z) === "object" ? (z[E] = z.level = P, this._addDefaultMeta(z), this.write(z), this) : (this.write((o(m = {}, E, P), o(m, "level", P), o(m, "message", z), m)), this);
            var ee = V[0];
            if (l(ee) === "object" && ee !== null) {
              var ne = z && z.match && z.match(_);
              if (!ne) {
                var Y, G = Object.assign({}, this.defaultMeta, ee, (o(Y = {}, E, P), o(Y, j, V), o(Y, "level", P), o(Y, "message", z), Y));
                return ee.message && (G.message = "".concat(G.message, " ").concat(ee.message)), ee.stack && (G.stack = ee.stack), this.write(G), this;
              }
            }
            return this.write(Object.assign({}, this.defaultMeta, (o(O = {}, E, P), o(O, j, V), o(O, "level", P), o(O, "message", z), O))), this;
          } }, { key: "_transform", value: function(P, z, O) {
            if (this.silent)
              return O();
            P[E] || (P[E] = P.level), this.levels[P[E]] || this.levels[P[E]] === 0 || console.error("[winston] Unknown logger level: %s", P[E]), this._readableState.pipes || console.error("[winston] Attempt to write logs with no transports %j", P);
            try {
              this.push(this.format.transform(P, this.format.options));
            } catch (m) {
              throw m;
            } finally {
              O();
            }
          } }, { key: "_final", value: function(P) {
            var z = this.transports.slice();
            f(z, function(O, m) {
              if (!O || O.finished)
                return r(m);
              O.once("finish", m), O.end();
            }, P);
          } }, { key: "add", value: function(P) {
            var z = !B(P) || P.log.length > 2 ? new p({ transport: P }) : P;
            if (!z._writableState || !z._writableState.objectMode)
              throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
            return this._onEvent("error", z), this._onEvent("warn", z), this.pipe(z), P.handleExceptions && this.exceptions.handle(), P.handleRejections && this.rejections.handle(), this;
          } }, { key: "remove", value: function(P) {
            if (!P)
              return this;
            var z = P;
            return (!B(P) || P.log.length > 2) && (z = this.transports.filter(function(O) {
              return O.transport === P;
            })[0]), z && this.unpipe(z), this;
          } }, { key: "clear", value: function() {
            return this.unpipe(), this;
          } }, { key: "close", value: function() {
            return this.clear(), this.emit("close"), this;
          } }, { key: "setLevels", value: function() {
            $.deprecated("setLevels");
          } }, { key: "query", value: function(P, z) {
            typeof P == "function" && (z = P, P = {}), P = P || {};
            var O = {}, m = Object.assign({}, P.query || {});
            f(this.transports.filter(function(F) {
              return !!F.query;
            }), function(F, V) {
              (function(Q, ee) {
                P.query && typeof Q.formatQuery == "function" && (P.query = Q.formatQuery(m)), Q.query(P, function(ne, Y) {
                  if (ne)
                    return ee(ne);
                  typeof Q.formatResults == "function" && (Y = Q.formatResults(Y, P.format)), ee(null, Y);
                });
              })(F, function(Q, ee) {
                V && ((ee = Q || ee) && (O[F.name] = ee), V()), V = null;
              });
            }, function() {
              return z(null, O);
            });
          } }, { key: "stream", value: function() {
            var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, z = new b(), O = [];
            return z._streams = O, z.destroy = function() {
              for (var m = O.length; m--; )
                O[m].destroy();
            }, this.transports.filter(function(m) {
              return !!m.stream;
            }).forEach(function(m) {
              var F = m.stream(P);
              F && (O.push(F), F.on("log", function(V) {
                V.transport = V.transport || [], V.transport.push(m.name), z.emit("log", V);
              }), F.on("error", function(V) {
                V.transport = V.transport || [], V.transport.push(m.name), z.emit("error", V);
              }));
            }), z;
          } }, { key: "startTimer", value: function() {
            return new M(this);
          } }, { key: "profile", value: function(P) {
            var z = Date.now();
            if (this.profilers[P]) {
              var O = this.profilers[P];
              delete this.profilers[P];
              for (var m = arguments.length, F = new Array(m > 1 ? m - 1 : 0), V = 1; V < m; V++)
                F[V - 1] = arguments[V];
              typeof F[F.length - 2] == "function" && (console.warn("Callback function no longer supported as of winston@3.0.0"), F.pop());
              var Q = l(F[F.length - 1]) === "object" ? F.pop() : {};
              return Q.level = Q.level || "info", Q.durationMs = z - O, Q.message = Q.message || P, this.write(Q);
            }
            return this.profilers[P] = z, this;
          } }, { key: "handleExceptions", value: function() {
            var P;
            console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()"), (P = this.exceptions).handle.apply(P, arguments);
          } }, { key: "unhandleExceptions", value: function() {
            var P;
            console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()"), (P = this.exceptions).unhandle.apply(P, arguments);
          } }, { key: "cli", value: function() {
            throw new Error(["Logger.cli() was removed in winston@3.0.0", "Use a custom winston.formats.cli() instead.", "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"].join(`
`));
          } }, { key: "_onEvent", value: function(P, z) {
            z["__winston" + P] || (z["__winston" + P] = function(O) {
              P !== "error" || this.transports.includes(z) || this.add(z), this.emit(P, O, z);
            }.bind(this), z.on(P, z["__winston" + P]));
          } }, { key: "_addDefaultMeta", value: function(P) {
            this.defaultMeta && Object.assign(P, this.defaultMeta);
          } }]) && u(x.prototype, H), N;
        }(h);
        function C(w, x) {
          var H = w[x];
          return H || H === 0 ? H : null;
        }
        Object.defineProperty(y.prototype, "transports", { configurable: !1, enumerable: !0, get: function() {
          var w = this._readableState.pipes;
          return Array.isArray(w) ? w : [w].filter(Boolean);
        } }), e.exports = y;
      }).call(this, n(15).setImmediate);
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      var r = d(n(45)), o = d(n(46)), l = d(n(66)), u = d(n(67)), s = d(n(68)), g = d(n(25)), c = d(n(30));
      function d(h) {
        return h && h.__esModule ? h : { default: h };
      }
      function T(h, f, v) {
        v = (0, u.default)(v);
        var E = 0, j = 0, { length: B } = h, I = !1;
        function R(p, M) {
          p === !1 && (I = !0), I !== !0 && (p ? v(p) : ++j !== B && M !== o.default || v(null));
        }
        for (B === 0 && v(null); E < B; E++)
          f(h[E], E, (0, s.default)(R));
      }
      function b(h, f, v) {
        return (0, l.default)(h, 1 / 0, f, v);
      }
      t.default = (0, c.default)(function(h, f, v) {
        return ((0, r.default)(h) ? T : b)(h, (0, g.default)(f), v);
      }, 3), e.exports = t.default;
    }, function(e, t, n) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        return (o, l, u) => r(o, u);
      }, e.exports = t.default;
    }, function(e, t, n) {
      var r = Object.prototype.toString;
      e.exports = function(o) {
        if (typeof o.displayName == "string" && o.constructor.name)
          return o.displayName;
        if (typeof o.name == "string" && o.name)
          return o.name;
        if (typeof o == "object" && o.constructor && typeof o.constructor.name == "string")
          return o.constructor.name;
        var l = o.toString(), u = r.call(o).slice(8, -1);
        return (l = u === "Function" ? l.substring(l.indexOf("(") + 1, l.indexOf(")")) : u) || "anonymous";
      };
    }, function(e, t, n) {
      const r = n(13), { LEVEL: o } = n(3), l = n(20), u = e.exports = function(s = {}) {
        if (l.call(this, s), !s.transport || typeof s.transport.log != "function")
          throw new Error("Invalid transport, must be an object with a log method.");
        this.transport = s.transport, this.level = this.level || s.transport.level, this.handleExceptions = this.handleExceptions || s.transport.handleExceptions, this._deprecated(), this.transport.__winstonError || (this.transport.__winstonError = function(g) {
          this.emit("error", g, this.transport);
        }.bind(this), this.transport.on("error", this.transport.__winstonError));
      };
      r.inherits(u, l), u.prototype._write = function(s, g, c) {
        if (this.silent || s.exception === !0 && !this.handleExceptions)
          return c(null);
        (!this.level || this.levels[this.level] >= this.levels[s[o]]) && this.transport.log(s[o], s.message, s, this._nop), c(null);
      }, u.prototype._writev = function(s, g) {
        for (let c = 0; c < s.length; c++)
          this._accept(s[c]) && (this.transport.log(s[c].chunk[o], s[c].chunk.message, s[c].chunk, this._nop), s[c].callback());
        return g(null);
      }, u.prototype._deprecated = function() {
        console.error([`${this.transport.name} is a legacy winston transport. Consider upgrading: `, "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"].join(`
`));
      }, u.prototype.close = function() {
        this.transport.close && this.transport.close(), this.transport.__winstonError && (this.transport.removeListener("error", this.transport.__winstonError), this.transport.__winstonError = null);
      };
    }, function(e, t, n) {
      function r(l) {
        return (r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
          return typeof u;
        } : function(u) {
          return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
        })(l);
      }
      function o(l, u) {
        for (var s = 0; s < u.length; s++) {
          var g = u[s];
          g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(l, g.key, g);
        }
      }
      e.exports = function() {
        function l(g) {
          if (function(c, d) {
            if (!(c instanceof d))
              throw new TypeError("Cannot call a class as a function");
          }(this, l), !g)
            throw new Error("Logger is required for profiling.");
          this.logger = g, this.start = Date.now();
        }
        var u, s;
        return u = l, (s = [{ key: "done", value: function() {
          for (var g = arguments.length, c = new Array(g), d = 0; d < g; d++)
            c[d] = arguments[d];
          typeof c[c.length - 1] == "function" && (console.warn("Callback function no longer supported as of winston@3.0.0"), c.pop());
          var T = r(c[c.length - 1]) === "object" ? c.pop() : {};
          return T.level = T.level || "info", T.durationMs = Date.now() - this.start, this.logger.write(T);
        } }]) && o(u.prototype, s), l;
      }();
    }, function(e, t, n) {
      (function(r) {
        const o = n(209), { MESSAGE: l } = n(3), u = n(35);
        function s(g, c) {
          return c instanceof r ? c.toString("base64") : typeof c == "bigint" ? c.toString() : c;
        }
        e.exports = o((g, c = {}) => (g[l] = (c.stable ? u.stableStringify : u)(g, c.replacer || s, c.space), g));
      }).call(this, n(5).Buffer);
    }, function(e, t, n) {
      class r extends Error {
        constructor(l) {
          super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${l.toString().split(`
`)[0]}
`), Error.captureStackTrace(this, r);
        }
      }
      e.exports = (o) => {
        if (o.length > 2)
          throw new r(o);
        function l(s = {}) {
          this.options = s;
        }
        function u(s) {
          return new l(s);
        }
        return l.prototype.transform = o, u.Format = l, u;
      };
    }, function(e, t, n) {
      function r(u, s) {
        if (!(u instanceof s))
          throw new TypeError("Cannot call a class as a function");
      }
      function o(u, s) {
        for (var g = 0; g < s.length; g++) {
          var c = s[g];
          c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(u, c.key, c);
        }
      }
      var l = n(88);
      e.exports = function() {
        function u() {
          var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          r(this, u), this.loggers = /* @__PURE__ */ new Map(), this.options = c;
        }
        var s, g;
        return s = u, (g = [{ key: "add", value: function(c, d) {
          var T = this;
          if (!this.loggers.has(c)) {
            var b = (d = Object.assign({}, d || this.options)).transports || this.options.transports;
            d.transports = b ? b.slice() : [];
            var h = l(d);
            h.on("close", function() {
              return T._delete(c);
            }), this.loggers.set(c, h);
          }
          return this.loggers.get(c);
        } }, { key: "get", value: function(c, d) {
          return this.add(c, d);
        } }, { key: "has", value: function(c) {
          return !!this.loggers.has(c);
        } }, { key: "close", value: function(c) {
          var d = this;
          if (c)
            return this._removeLogger(c);
          this.loggers.forEach(function(T, b) {
            return d._removeLogger(b);
          });
        } }, { key: "_removeLogger", value: function(c) {
          this.loggers.has(c) && (this.loggers.get(c).close(), this._delete(c));
        } }, { key: "_delete", value: function(c) {
          this.loggers.delete(c);
        } }]) && o(s.prototype, g), u;
      }();
    }, function(e, t, n) {
      (function(r) {
        const o = n(52), l = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/;
        e.exports = function(u, s, g, c) {
          let d, T, b = !1, h = !1;
          const f = n(94);
          function v(B) {
            c(s, B);
          }
          function E(B, I) {
            let R = `"${s}" ${I}`;
            throw B && (R = `${R}`), T && (R = `${R}. An example of a valid value would be: ${T}`), new o(R);
          }
          const j = { convertFromBase64: function() {
            return v("marking for base64 conversion"), b = !0, j;
          }, default: function(B) {
            if (typeof B == "number")
              d = B.toString();
            else if (Array.isArray(B) || typeof B == "object" && B !== null)
              d = JSON.stringify(B);
            else {
              if (typeof B != "string")
                throw new o("values passed to default() must be of Number, String, Array, or Object type");
              d = B;
            }
            return v(`setting default value to "${d}"`), j;
          }, required: function(B) {
            return B === void 0 ? (v("marked as required"), h = !0) : (v(`setting required flag to ${B}`), h = B), j;
          }, example: function(B) {
            return T = B, j;
          } };
          return Object.entries({ ...f, ...g }).forEach(([B, I]) => {
            j[B] = function(R) {
              return function() {
                let p = u[s];
                if (v(`will be read from the environment using "${R.name}" accessor`), p === void 0)
                  if (d === void 0 && h)
                    v("was not found in the environment, but is required to be set"), E(void 0, "is a required variable, but it was not set");
                  else {
                    if (d === void 0)
                      return void v("was not found in the environment, but is not required. returning undefined");
                    v(`was not found in the environment, parsing default value "${d}" instead`), p = d;
                  }
                h && (v("verifying variable value is not an empty string"), p.trim().length === 0 && E(void 0, "is a required variable, but its value was empty")), b && (v("verifying variable is a valid base64 string"), p.match(l) || E(p, "should be a valid base64 string if using convertFromBase64"), v("converting from base64 to utf8 string"), p = r.from(p, "base64").toString());
                const M = [p].concat(Array.prototype.slice.call(arguments));
                try {
                  v(`passing value "${p}" to "${R.name}" accessor`);
                  const $ = R.apply(R, M);
                  return v(`parsed successfully, returning ${$}`), $;
                } catch ($) {
                  E(p, $.message);
                }
              };
            }(I);
          }), j;
        };
      }).call(this, n(5).Buffer);
    }, function(e, t, n) {
      const r = n(33);
      e.exports = function(o, l) {
        return l = l || ",", o.length ? r(o).split(l).filter(Boolean) : [];
      };
    }, function(e, t, n) {
      e.exports = function(r) {
        const o = r.toLowerCase();
        if (o !== "false" && o !== "true")
          throw new Error('should be either "true", "false", "TRUE", or "FALSE"');
        return o !== "false";
      };
    }, function(e, t, n) {
      e.exports = function(r) {
        const o = r.toLowerCase();
        if (["false", "0", "true", "1"].indexOf(o) === -1)
          throw new Error('should be either "true", "false", "TRUE", "FALSE", 1, or 0');
        return !(o === "0" || o === "false");
      };
    }, function(e, t, n) {
      const r = n(95);
      e.exports = function(o) {
        var l = r(o);
        if (l > 65535)
          throw new Error("cannot assign a port number greater than 65535");
        return l;
      };
    }, function(e, t, n) {
      const r = n(33);
      e.exports = function(o, l) {
        const u = r(o);
        if (l.indexOf(u) < 0)
          throw new Error(`should be one of [${l.join(", ")}]`);
        return u;
      };
    }, function(e, t, n) {
      const r = n(54);
      e.exports = function(o) {
        const l = r(o);
        if (l > 0)
          throw new Error("should be a negative float");
        return l;
      };
    }, function(e, t, n) {
      const r = n(54);
      e.exports = function(o) {
        const l = r(o);
        if (l < 0)
          throw new Error("should be a positive float");
        return l;
      };
    }, function(e, t, n) {
      const r = n(53);
      e.exports = function(o) {
        const l = r(o);
        if (l > 0)
          throw new Error("should be a negative integer");
        return l;
      };
    }, function(e, t, n) {
      const r = n(55);
      e.exports = function(o) {
        var l = r(o);
        if (!Array.isArray(l))
          throw new Error("should be a parseable JSON Array");
        return l;
      };
    }, function(e, t, n) {
      const r = n(55);
      e.exports = function(o) {
        var l = r(o);
        if (Array.isArray(l))
          throw new Error("should be a parseable JSON Object");
        return l;
      };
    }, function(e, t, n) {
      e.exports = function(r, o) {
        try {
          RegExp(void 0, o);
        } catch {
          throw new Error("invalid regexp flags");
        }
        try {
          return new RegExp(r, o);
        } catch {
          throw new Error("should be a valid regexp");
        }
      };
    }, function(e, t, n) {
      const r = n(96);
      e.exports = function(o) {
        return r(o).toString();
      };
    }, function(e, t, n) {
      const r = n(33), o = /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\u0001-\u0008\u000b\u000c\u000e-\u001f\u0021\u0023-\u005b\u005d-\u007f]|\\[\u0001-\u0009\u000b\u000c\u000e-\u007f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\u0001-\u0008\u000b\u000c\u000e-\u001f\u0021-\u005a\u0053-\u007f]|\\[\u0001-\u0009\u000b\u000c\u000e-\u007f])+)\])$/;
      e.exports = function(l) {
        const u = r(l);
        if (!o.test(u))
          throw new Error("should be a valid email address");
        return u;
      };
    }, function(e, t, n) {
      e.exports = function(r, o) {
        return function(l, u) {
          o && o.match(/prod|production/) || r(`env-var (${l}): ${u}`);
        };
      };
    }, function(e, t, n) {
      (function(r) {
        (function() {
          var o, l, u, s, g, c;
          typeof performance < "u" && performance !== null && performance.now ? e.exports = function() {
            return performance.now();
          } : r != null && r.hrtime ? (e.exports = function() {
            return (o() - g) / 1e6;
          }, l = r.hrtime, s = (o = function() {
            var d;
            return 1e9 * (d = l())[0] + d[1];
          })(), c = 1e9 * r.uptime(), g = s - c) : Date.now ? (e.exports = function() {
            return Date.now() - u;
          }, u = Date.now()) : (e.exports = function() {
            return (/* @__PURE__ */ new Date()).getTime() - u;
          }, u = (/* @__PURE__ */ new Date()).getTime());
        }).call(this);
      }).call(this, n(2));
    }, function(e, t, n) {
      (function(r) {
        (function(o) {
          function l(s) {
            if ((s = s === void 0 ? "utf-8" : s) !== "utf-8")
              throw new RangeError("Failed to construct 'TextEncoder': The encoding label provided ('" + s + "') is invalid.");
          }
          function u(s, g) {
            if (g = g === void 0 ? { fatal: !1 } : g, (s = s === void 0 ? "utf-8" : s) !== "utf-8")
              throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('" + s + "') is invalid.");
            if (g.fatal)
              throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
          }
          if (o.TextEncoder && o.TextDecoder)
            return !1;
          Object.defineProperty(l.prototype, "encoding", { value: "utf-8" }), l.prototype.encode = function(s, g) {
            if ((g = g === void 0 ? { stream: !1 } : g).stream)
              throw Error("Failed to encode: the 'stream' option is unsupported.");
            g = 0;
            for (var c = s.length, d = 0, T = Math.max(32, c + (c >> 1) + 7), b = new Uint8Array(T >> 3 << 3); g < c; ) {
              var h = s.charCodeAt(g++);
              if (55296 <= h && 56319 >= h) {
                if (g < c) {
                  var f = s.charCodeAt(g);
                  (64512 & f) == 56320 && (++g, h = ((1023 & h) << 10) + (1023 & f) + 65536);
                }
                if (55296 <= h && 56319 >= h)
                  continue;
              }
              if (d + 4 > b.length && (T += 8, T = (T *= 1 + g / s.length * 2) >> 3 << 3, (f = new Uint8Array(T)).set(b), b = f), (4294967168 & h) == 0)
                b[d++] = h;
              else {
                if (!(4294965248 & h))
                  b[d++] = h >> 6 & 31 | 192;
                else if (!(4294901760 & h))
                  b[d++] = h >> 12 & 15 | 224, b[d++] = h >> 6 & 63 | 128;
                else {
                  if (4292870144 & h)
                    continue;
                  b[d++] = h >> 18 & 7 | 240, b[d++] = h >> 12 & 63 | 128, b[d++] = h >> 6 & 63 | 128;
                }
                b[d++] = 63 & h | 128;
              }
            }
            return b.slice(0, d);
          }, Object.defineProperty(u.prototype, "encoding", { value: "utf-8" }), Object.defineProperty(u.prototype, "fatal", { value: !1 }), Object.defineProperty(u.prototype, "ignoreBOM", { value: !1 }), u.prototype.decode = function(s, g) {
            if ((g = g === void 0 ? { stream: !1 } : g).stream)
              throw Error("Failed to decode: the 'stream' option is unsupported.");
            g = 0;
            for (var c = (s = new Uint8Array(s)).length, d = []; g < c; ) {
              var T = s[g++];
              if (T === 0)
                break;
              if (!(128 & T))
                d.push(T);
              else if ((224 & T) == 192) {
                var b = 63 & s[g++];
                d.push((31 & T) << 6 | b);
              } else if ((240 & T) == 224) {
                b = 63 & s[g++];
                var h = 63 & s[g++];
                d.push((31 & T) << 12 | b << 6 | h);
              } else
                (248 & T) == 240 && (65535 < (T = (7 & T) << 18 | (b = 63 & s[g++]) << 12 | (h = 63 & s[g++]) << 6 | 63 & s[g++]) && (T -= 65536, d.push(T >>> 10 & 1023 | 55296), T = 56320 | 1023 & T), d.push(T));
            }
            return String.fromCharCode.apply(null, d);
          }, o.TextEncoder = l, o.TextDecoder = u;
        })(typeof window < "u" ? window : r !== void 0 ? r : this);
      }).call(this, n(6));
    }, function(e, t, n) {
      n.r(t), n.d(t, "AuthClient", function() {
        return l;
      }), n.d(t, "RtcSignalingClient", function() {
        return s;
      }), n.d(t, "Credentials", function() {
        return x;
      }), n.d(t, "IRtcStream", function() {
      }), n.d(t, "SignalingPromiseClient", function() {
        return H.SignalingPromiseClient;
      }), n.d(t, "IRtcClientConfigurationV1", function() {
      }), n.d(t, "IRtcClientConfiguration", function() {
      }), n.d(t, "IRtcConnectionStatsInfo", function() {
      }), n.d(t, "IRtcSendConfiguration", function() {
      }), n.d(t, "IRtcSessionMetricsMessageCounts", function() {
      }), n.d(t, "IRtcStreamMessage", function() {
      }), n.d(t, "IRtcStreamPayload", function() {
      }), n.d(t, "IStreamControl", function() {
      }), n.d(t, "RtcClient", function() {
        return Mt;
      }), n.d(t, "RtcClientV1", function() {
        return Tt;
      }), n.d(t, "createRtcStreamMessage", function() {
        return Pe;
      });
      var r = n(28), o = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class l extends r.a {
        adminSignup(k, W) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/admin-signup", { token: W, method: "POST", body: JSON.stringify(k) });
          });
        }
        login(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/login", { method: "POST", body: JSON.stringify(k), allowUnsafeRetries: !0 });
          });
        }
        loginWithGoogleToken(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/login-google", { method: "POST", body: JSON.stringify(k), allowUnsafeRetries: !0 });
          });
        }
        refresh(k, W) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/refresh", { method: "POST", body: JSON.stringify({ refreshToken: k, tokenExpirationSeconds: W }), allowUnsafeRetries: !0 });
          });
        }
        respondToNewPasswordRequiredChallenge(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/respond-to-new-password-required-challenge", { method: "POST", body: JSON.stringify(k) });
          });
        }
        forgotPassword(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/forgot-password", { method: "POST", body: JSON.stringify({ email: k }) });
          });
        }
        confirmForgotPassword(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/confirm-forgot-password", { method: "POST", body: JSON.stringify(k) });
          });
        }
        resendInvitation(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/resend-invitation", { method: "POST", body: JSON.stringify({ email: k }) });
          });
        }
        changePassword({ token: k, refreshToken: W, currentPassword: X, newPassword: ie }) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/change-password", { token: k, method: "POST", body: JSON.stringify({ refreshToken: W, currentPassword: X, newPassword: ie }) });
          });
        }
        getDeviceCredentials(k) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/device-credentials", { token: k, method: "POST", allowUnsafeRetries: !0 });
          });
        }
        impersonate(k, W) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/impersonate", { token: k, method: "POST", allowUnsafeRetries: !0, body: JSON.stringify({ userId: W }) });
          });
        }
        createServiceAccount(k, W, X, ie) {
          return o(this, void 0, void 0, function* () {
            return yield this.fetch("auth/service-account", { token: k, method: "POST", allowUnsafeRetries: !0, body: JSON.stringify({ name: W, roleId: X, tags: ie }) });
          });
        }
        getFeatures(k) {
          return o(this, void 0, void 0, function* () {
            return (yield this.fetch("auth/features", { token: k })).features;
          });
        }
      }
      var u = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class s extends r.a {
        createPeer(k, W) {
          return u(this, void 0, void 0, function* () {
            return yield this.fetch("peers", { token: k, method: "POST", body: JSON.stringify(W) });
          });
        }
        getPeers(k) {
          return u(this, void 0, void 0, function* () {
            return (yield this.fetch("peers", { token: k })).items;
          });
        }
        refreshPeer(k, W) {
          return u(this, void 0, void 0, function* () {
            yield this.fetch(`peers/${W}/refresh`, { token: k, method: "POST", allowUnsafeRetries: !0 });
          });
        }
        createSession(k, W) {
          return u(this, void 0, void 0, function* () {
            return yield this.fetch("sessions", { token: k, method: "POST", body: JSON.stringify(W) });
          });
        }
        refreshSession(k, W) {
          return u(this, void 0, void 0, function* () {
            yield this.fetch(`sessions/${W}/refresh`, { token: k, method: "POST", allowUnsafeRetries: !0 });
          });
        }
        deleteSession(k, W) {
          return u(this, void 0, void 0, function* () {
            yield this.fetch(`sessions/${W}`, { token: k, method: "DELETE", allowUnsafeRetries: !0 });
          });
        }
        getSessions(k) {
          return u(this, void 0, void 0, function* () {
            return (yield this.fetch("sessions", { token: k })).items;
          });
        }
        getIceServers(k) {
          return u(this, void 0, void 0, function* () {
            return (yield this.fetch("ice-servers", { token: k })).items;
          });
        }
        addSignals(k, W, X) {
          return u(this, void 0, void 0, function* () {
            yield this.fetch(`sessions/${W}/add-signals`, { token: k, method: "POST", body: JSON.stringify(X) });
          });
        }
        takeSignals(k, W) {
          return u(this, void 0, void 0, function* () {
            return (yield this.fetch(`sessions/${W}/take-signals`, { token: k, method: "POST" })).items;
          });
        }
      }
      var g = n(1), c = n(8), d = n(14), T = n.n(d), b = n(104), h = n.n(b), f = n(0), v = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class E {
        constructor(k) {
          this.name = "LogReporter", this.type = "simple", this.message = k;
        }
        send(k) {
          return v(this, void 0, void 0, function* () {
            var W, X;
            f.a.info(this.message, (W = k.reduce((ie, oe) => Object.assign(Object.assign({}, ie), { [oe.name]: oe.stat }), {}), X = (ie) => {
              const { sum: oe, count: he } = ie, ye = oe / he;
              return Object.assign(Object.assign({}, ie), { average: ye });
            }, Object.keys(W).reduce((ie, oe) => Object.assign(Object.assign({}, ie), { [oe]: X(W[oe]) }), {})));
          });
        }
      }
      var j = n(4), B = n(39);
      function I(pe) {
        return !!pe.match(/^[a-zA-Z0-9-_.,:?'"()@\/\\#$+ ]{1,255}$/);
      }
      var R = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      function p({ func: pe, delay: k, immediate: W = !1 }) {
        let X = !1, ie = setTimeout(function he() {
          return R(this, void 0, void 0, function* () {
            if (X)
              return;
            const ye = (/* @__PURE__ */ new Date()).getTime();
            try {
              oe = pe(), yield oe;
            } finally {
              if (!X) {
                const _e = (/* @__PURE__ */ new Date()).getTime();
                ie = setTimeout(he, Math.max(k - (_e - ye), 0));
              }
            }
          });
        }, W ? 0 : k), oe = Promise.resolve();
        return { stop() {
          return R(this, void 0, void 0, function* () {
            X = !0, clearTimeout(ie), yield oe;
          });
        } };
      }
      var M = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      const $ = n(226), Z = !!j.c, _ = new class {
        constructor(pe) {
          this.samplePeriodSeconds = 60, this.buffer = {}, this.reporters = [], this.flushInterval = p({ func: () => this.flushStats(), delay: this.samplePeriodSeconds * g.a.second }), this.tags = this.filterTags((pe == null ? void 0 : pe.tags) || { app: j.a, version: j.j, namespace: j.i, instanceId: B.a });
        }
        shutdown() {
          return M(this, void 0, void 0, function* () {
            yield this.flushInterval.stop(), yield this.flushStats(), yield Object(c.a)(2 * g.a.second);
          });
        }
        aggregate(pe, k, W) {
          this.addToBuffer(this.buffer, this.encodeKey({ metric: pe, tags: this.filterTags(W || {}) }), typeof k == "number" ? { min: k, max: k, sum: k, count: 1 } : k);
        }
        increment(pe, k) {
          this.aggregate(pe, 1, k);
        }
        timer(pe, k, W) {
          return M(this, void 0, void 0, function* () {
            const X = $(), ie = yield k(), oe = $();
            return this.aggregate(pe, oe - X, W), ie;
          });
        }
        registerStatsReporter(pe) {
          this.reporters.push(pe);
        }
        setTag(pe, k) {
          const W = this.filterTags({ [pe]: k });
          this.tags = Object.assign(Object.assign({}, this.tags), W);
        }
        addToBuffer(pe, k, W) {
          if (pe[k]) {
            const { min: X, max: ie, sum: oe, count: he } = pe[k];
            pe[k] = { min: Math.min(X, W.min), max: Math.max(ie, W.max), sum: oe + W.sum, count: he + W.count };
          } else
            pe[k] = W;
        }
        write(pe) {
          return M(this, void 0, void 0, function* () {
            yield Promise.all(this.reporters.map((k) => M(this, void 0, void 0, function* () {
              let W;
              const X = {};
              switch (k.type) {
                case "simple":
                  for (const [oe, he] of Object.entries(pe)) {
                    const { metric: ye } = this.decodeKey(oe);
                    this.addToBuffer(X, this.encodeKey({ metric: ye }), he);
                  }
                  W = X;
                  break;
                case "tagged":
                  W = pe;
                  break;
                default:
                  (function(oe) {
                    throw new Error(`Unreachable type encountered (${oe})`);
                  })(k.type);
              }
              const ie = Object.entries(W);
              if (ie.length > 0)
                return k.send(ie.map(([oe, he]) => {
                  const { metric: ye, tags: _e } = this.decodeKey(oe);
                  return { name: ye, tags: Object.assign(Object.assign({}, _e), this.tags), stat: he };
                }), this.samplePeriodSeconds).catch((oe) => {
                  f.a.debug(`Failed to write stats to ${k.name}`, { error: oe });
                });
            })));
          });
        }
        flushStats() {
          return M(this, void 0, void 0, function* () {
            yield this.write(this.buffer), this.buffer = {};
          });
        }
        encodeKey(pe) {
          return T()(Object.assign(Object.assign({}, pe), Object.keys(pe.tags || {}).length > 0 ? { tags: pe.tags } : {}));
        }
        decodeKey(pe) {
          return JSON.parse(pe);
        }
        filterTags(pe) {
          return Object.entries(pe || {}).reduce((k, [W, X]) => (I(W) && I(X) && (k[W] = X), k), {});
        }
      }();
      Z || ["local", "on-prem"].includes(j.i) || _.registerStatsReporter(new E("stats"));
      var y = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class C extends class {
        constructor(k) {
          this.options = k, this.cache = new h.a(Object.assign(Object.assign(Object.assign({}, k.dispose || k.disposeAfter ? { ttlAutopurge: !0 } : {}), k), { dispose: (...W) => {
            var X;
            W[2] === "evict" && _.increment("lru-eviction", { name: k.name }), (X = k.dispose) === null || X === void 0 || X.call(k, ...W);
          }, disposeAfter: (...W) => {
            var X;
            this.updateStats(), (X = k.disposeAfter) === null || X === void 0 || X.call(k, ...W);
          } })), this.stringify = k.fastStringify ? JSON.stringify : T.a;
        }
        set(k, W, X) {
          const ie = this.stringify(k);
          if (!this.cache.set(ie, W, { ttl: X })) {
            const oe = this.cache.sizeCalculation ? this.cache.sizeCalculation(W, ie) : "unknown";
            throw Error(`Value too large (${oe} > ${this.cache.max})`);
          }
          this.updateStats();
        }
        get(k) {
          const { name: W } = this.options, X = this.stringify(k), ie = this.cache.getRemainingTTL(X);
          return ie <= 0 ? _.increment("cache-miss", { name: W }) : ie !== 1 / 0 && _.aggregate("cache-item-ttl", ie, { name: W }), this.cache.get(X);
        }
        delete(k) {
          this.cache.delete(this.stringify(k));
        }
        peek(k) {
          return this.cache.peek(this.stringify(k));
        }
        size() {
          return this.cache.size;
        }
        clear() {
          this.cache.clear();
        }
        forEach(k) {
          this.cache.forEach(k);
        }
        purgeStale() {
          return this.cache.purgeStale();
        }
        updateStats() {
          const { name: k } = this.options;
          _.aggregate("cache-item-count", this.cache.size, { name: k }), this.cache.calculatedSize !== void 0 && _.aggregate("cache-length", this.cache.calculatedSize, { name: k });
        }
      } {
        constructor(k) {
          if (super(k), this.expireRejectedPromiseValues = k.expireRejectedPromiseValues === void 0 || k.expireRejectedPromiseValues, this.rejectedPromiseValueTtl = k.rejectedPromiseValueTtl !== void 0 ? k.rejectedPromiseValueTtl : g.a.second, this.rejectedPromiseValueTtl < 0)
            throw new Error("rejectedPromiseValueTtl must not be negative");
        }
        set(k, W, X) {
          super.set(k, W, X), this.expireRejectedPromiseValues && W.catch(() => y(this, void 0, void 0, function* () {
            yield Object(c.a)(this.rejectedPromiseValueTtl), this.peek(k) === W && this.delete(k);
          }));
        }
      }
      var w = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class x {
        constructor(k, W, X) {
          this.authClient = k, this.email = W, this.password = X, this.tokenTtlMs = 1 * g.a.hour, this.tokenCache = new C({ name: "Credentials-tokenCache", max: 100, ttl: this.tokenTtlMs - 5 * g.a.minute, fastStringify: !0 });
        }
        getToken() {
          return w(this, void 0, void 0, function* () {
            let k = this.tokenCache.get(this.email);
            return k || (k = (() => w(this, void 0, void 0, function* () {
              const { authentication: W } = yield this.authClient.login({ email: this.email, password: this.password, tokenExpirationSeconds: this.tokenTtlMs / g.a.second });
              if (!W)
                throw new Error("User account not verified.");
              return W.accessToken;
            }))(), this.tokenCache.set(this.email, k)), k;
          });
        }
      }
      var H = n(97), L = n(40), N = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class P extends L.a {
        constructor(k) {
          super(k);
        }
        postLanRtcOffer(k) {
          return N(this, void 0, void 0, function* () {
            return yield this.fetch("v1/lan-rtc-offer", { method: "POST", body: JSON.stringify(k) });
          });
        }
      }
      var z = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      function O(pe) {
        return z(this, void 0, void 0, function* () {
          return (yield Promise.all(pe.map((k) => k.catch((W) => W)))).filter((k) => k instanceof Error);
        });
      }
      function m(pe) {
        if (pe !== void 0)
          return pe;
        throw new Error("Value is undefined");
      }
      function F(pe, k) {
        const W = pe.reduce((X, ie) => [...X, ...ie.urls], []).filter((X) => V(X, k)).sort((X) => Q(X, "udp") ? -1 : 0).shift();
        if (W)
          return Object.assign(Object.assign({}, m(pe.find((X) => X.urls.includes(W)))), { urls: [W] });
      }
      function V(pe, k) {
        switch (k) {
          case "stun":
            return /^stuns?:/.test(pe);
          case "turn":
            return /^turns?:/.test(pe);
        }
      }
      function Q(pe, k) {
        return pe.endsWith(`transport=${k}`);
      }
      var ee = n(9), ne = n(24), Y = n(229);
      class G extends Error {
        constructor(k, W) {
          super(`Deadline expired after ${k}ms + ${W}ms`);
        }
      }
      class S {
        static withDeadline(k, W) {
          const X = new Promise((ie, oe) => {
            setTimeout(() => {
              oe(new G(W, this.grpcCallDeadlineSlopMs));
            }, W + this.grpcCallDeadlineSlopMs);
          });
          return Promise.race([k, X]);
        }
      }
      S.grpcCallDeadlineSlopMs = 500 * g.a.millisecond;
      var A = n(29);
      const U = { ordered: !1, maxPacketLifeTime: 300 * g.a.millisecond }, J = { ordered: !0 }, K = { ordered: !0 }, re = { ordered: !1, maxRetransmits: 0 }, se = { ordered: !1, maxRetransmits: 0 }, fe = (pe) => "received" in pe && pe.received !== void 0, we = (pe) => !("received" in pe) || pe.received === void 0, Ie = 2 * g.a.second;
      function Ee(pe, k = {}) {
        const W = Array.from(pe.values()), X = W.filter(fe), ie = X.length > 0, oe = Math.max(...X.map((ce) => ce.received));
        let he;
        if (ie) {
          const ce = W.length, le = X.length, Re = X.map((De) => De.received - De.sent), { standardDeviation: Me, mean: Ne, jitter: Fe } = function(De) {
            const Le = De.length;
            if (Le === 0)
              return { mean: NaN, standardDeviation: -1, jitter: NaN };
            const Ve = De.reduce((Xe, ot) => Xe + ot, 0) / Le, $e = Math.sqrt(De.map((Xe) => Math.pow(Xe - Ve, 2)).reduce((Xe, ot) => Xe + ot) / Le);
            if (Le === 1)
              return { mean: Ve, standardDeviation: $e, jitter: NaN };
            let Ke = 0;
            for (let Xe = 1; Xe < Le; Xe++)
              Ke += Math.abs(De[Xe] - De[Xe - 1]);
            return { mean: Ve, standardDeviation: $e, jitter: Ke / (Le - 1) };
          }(Re), Ye = W.filter((De) => De.sent < oe - Ie), Ge = Ye.filter(we), Ze = Ge.length === 0 ? 0 : Ge.length / Ye.length;
          he = { pingsSent: ce, pongsReceived: le, average: Ne, standardDeviation: Me, jitter: Fe, max: Math.max(...Re), min: Math.min(...Re), loss: Ze };
        } else
          he = null;
        const { temporalNow: ye = Date.now() } = k, _e = (ie ? oe : ye) - 4 * Ie;
        return Array.from(pe.entries()).forEach((ce) => {
          const [le, Re] = ce;
          Re.sent < _e && pe.delete(le);
        }), he;
      }
      function Ce({ entityId: pe, streamName: k, streamType: W }) {
        return `${pe}.${k}.${W}`;
      }
      var Ae = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class Oe {
        constructor(k, W) {
          this.sessionId = k, this.connection = W, this.counts = { localSent: /* @__PURE__ */ new Map(), localReceived: /* @__PURE__ */ new Map(), remoteSent: /* @__PURE__ */ new Map(), remoteReceived: /* @__PURE__ */ new Map() }, this.sessionId = k, this.connection = W;
        }
        updateRemoteMessagesCounts(k) {
          if (k.payload.streamsInfo) {
            this.counts.remoteSent = /* @__PURE__ */ new Map(), this.counts.remoteReceived = /* @__PURE__ */ new Map();
            for (const W of k.payload.streamsInfo.items)
              this.counts.remoteSent.set(W.streamId, W.sentCount), this.counts.remoteReceived.set(W.streamId, W.receivedCount);
          }
        }
        getLocalStreamsInfo(k) {
          const { localSent: W, localReceived: X } = this.counts;
          return { items: [.../* @__PURE__ */ new Set([...W.keys(), ...X.keys()])].map((ie) => {
            var oe, he;
            return { streamId: ie, sentCount: (oe = W.get(ie)) !== null && oe !== void 0 ? oe : 0, receivedCount: (he = X.get(ie)) !== null && he !== void 0 ? he : 0 };
          }), timestamp: k };
        }
        incrementLocalSent(k) {
          const { localSent: W } = this.counts, X = Ce(k.header.stream);
          W.set(X, (W.get(X) || 0) + 1);
        }
        incrementLocalReceived(k) {
          const { localReceived: W } = this.counts, X = Ce(k.header.stream), ie = W.get(X) || 0;
          if (ie === 0) {
            const { streamName: oe, streamType: he } = k.header.stream;
            f.a.debug("RTC client received first message for stream", { streamName: oe, streamType: he });
          }
          W.set(X, ie + 1);
        }
        uploadMetrics() {
          return Ae(this, void 0, void 0, function* () {
            const { sessionId: k } = this, W = yield this.connection.peerConnection.getStats(), X = {};
            W.forEach((ce) => X[ce.id] = ce), f.a.debug("rtc-stats", Object.assign(Object.assign({}, X), { sessionId: k }));
            const { localSent: ie, localReceived: oe, remoteSent: he, remoteReceived: ye } = this.counts, _e = [.../* @__PURE__ */ new Set([...ie.keys(), ...oe.keys()])].reduce((ce, le) => {
              const Re = ie.get(le), Me = oe.get(le), Ne = he.get(le), Fe = ye.get(le);
              return Object.assign(Object.assign({}, ce), { [`local-${le}-sent`]: Re, [`local-${le}-received`]: Me, [`remote-${le}-sent`]: Ne, [`remote-${le}-received`]: Fe });
            }, { sessionId: k });
            f.a.debug("rtc-message-report", Object.assign({ deviceId: this.connection.getRemoteDeviceId() }, _e));
          });
        }
      }
      function Pe(pe, k, W) {
        return { header: { stream: pe, created: Date.now(), frameId: W || "" }, payload: k };
      }
      function qe(pe) {
        return (/* @__PURE__ */ new Set(["disconnected", "failed", "closed"])).has(pe.iceConnectionState);
      }
      function et(pe) {
        switch (pe.header.stream.streamType) {
          case "twist": {
            const { twist: k } = pe.payload;
            if (!k)
              throw Error("twist not in payload of RTC message with type twist");
            return { header: pe.header, payload: { twist: { linear: Object.assign({ x: 0, y: 0, z: 0 }, k.linear), angular: Object.assign({ x: 0, y: 0, z: 0 }, k.angular) } } };
          }
          case "pose": {
            const { pose: k } = pe.payload;
            if (!k)
              throw Error("pose not in payload of RTC message with type pose");
            return { header: pe.header, payload: { pose: { translation: Object.assign({ x: 0, y: 0, z: 0 }, k.translation), rotation: Object.assign({ x: 0, y: 0, z: 0, w: 0 }, k.rotation) } } };
          }
          case "pose-with-covariance": {
            const { poseWithCovariance: k } = pe.payload;
            if (!k)
              throw Error("poseWithCovariance not in payload of RTC message with type pose-with-covariance");
            const W = new Array(36).fill(0);
            return k.covariance.forEach((X, ie) => {
              if (ie >= 36)
                throw Error("covariance contains more than 36 elements");
              W[ie] = X;
            }), { header: pe.header, payload: { poseWithCovariance: { pose: { translation: Object.assign({ x: 0, y: 0, z: 0 }, k.pose.translation), rotation: Object.assign({ x: 0, y: 0, z: 0, w: 0 }, k.pose.rotation) }, covariance: W } } };
          }
          case "point": {
            const { point: k } = pe.payload;
            if (!k)
              throw Error("point not in payload of RTC message with type point");
            return { header: pe.header, payload: { point: Object.assign({ x: 0, y: 0, z: 0 }, k) } };
          }
          default:
            return pe;
        }
      }
      var Qe = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class yt {
        constructor(k, W, X) {
          this.peerConnection = k, this.config = W, this.dataChannelNotifier = X, this.connectTimeoutMs = 20 * g.a.second, this.iceGatheringTimeoutMs = 15 * g.a.second, this.pingUpdateTimeoutMs = 1 * g.a.second, this.pingV2UpdateTimeoutMs = 250 * g.a.millisecond, this.pingV2MetricsGatherTimeoutMs = 1 * g.a.second, this.streamsInfoUpdateTimeoutMs = 2 * g.a.second, this.reassemblyTimeoutMs = 500 * g.a.millisecond, this.reassemblyTableCleanupMs = 1 * g.a.second, this.heartbeatTimeoutMs = 20 * g.a.millisecond, this.streamLatestTimestamp = /* @__PURE__ */ new Map(), this.reassemblyTable = /* @__PURE__ */ new Map(), this.reassemblyTableLastTimestamp = /* @__PURE__ */ new Map(), this.closeCalled = !1, this.gotOffer = !1, this.hasIceCandidate = !1, this.pingV2Map = /* @__PURE__ */ new Map(), this.sendPingV2 = () => {
            const { latestTryOnceStreamChannel: oe } = this;
            if (!oe)
              return;
            const he = (/* @__PURE__ */ new Date()).getTime(), ye = Object(Y.a)();
            this.sendSystemMessage(oe, { type: "ping-v2", payload: { timestamp: he, id: ye } }), this.pingV2Map.set(ye, { sent: he });
          }, this.gatherPingV2Metrics = () => {
            const oe = Ee(this.pingV2Map);
            if (oe) {
              const he = this.getRemoteDeviceId();
              this.pingInfo = oe, _.aggregate("rtc-ping-average", oe.average, Object.assign({}, he ? { deviceId: he } : {})), _.aggregate("rtc-ping-loss", oe.loss, Object.assign({}, he ? { deviceId: he } : {})), _.aggregate("rtc-jitter", oe.jitter, Object.assign({}, he ? { deviceId: he } : {}));
            }
          };
          const { isOffer: ie } = W.baseConfig;
          ie ? this.initializeChannels(k) : k.ondatachannel = (oe) => {
            switch (oe.channel.label) {
              case "stream.latest-ttl":
                this.latestTtlStreamChannel = oe.channel;
                break;
              case "stream.reliable":
                this.reliableStreamChannel = oe.channel;
                break;
              case "stream.latest-reliable":
                this.latestReliableStreamChannel = oe.channel;
                break;
              case "stream.latest-try-once":
                this.latestTryOnceStreamChannel = oe.channel;
                break;
              case "heartbeat":
                return void (this.heartbeatChannel = oe.channel);
              default:
                return void this.dataChannelNotifier(oe.channel);
            }
            this.setupChannel(oe.channel);
          }, this.pingUpdateTimeout = setInterval(() => {
            const { reliableStreamChannel: oe } = this;
            oe && this.sendSystemMessage(oe, { type: "ping" });
          }, this.pingUpdateTimeoutMs), this.pingV2UpdateTimeout = setInterval(this.sendPingV2, this.pingV2UpdateTimeoutMs), this.pingV2MetricsGatherTimeout = setInterval(this.gatherPingV2Metrics, this.pingV2MetricsGatherTimeoutMs), this.streamsInfoUpdateTimeout = setInterval(() => {
            const { latestTtlStreamChannel: oe } = this;
            oe && this.sendSystemMessage(oe, { type: "streams-info" });
          }, this.streamsInfoUpdateTimeoutMs), this.reassemblyTableCleanupTimeout = setInterval(() => {
            const oe = (/* @__PURE__ */ new Date()).getTime();
            this.reassemblyTableLastTimestamp.forEach((he, ye, _e) => {
              oe > ye + this.reassemblyTimeoutMs && this.reassemblyTable.delete(he);
            });
          }, this.reassemblyTableCleanupMs), this.heartbeatTimeout = setInterval(() => {
            const { heartbeatChannel: oe } = this;
            oe && oe.readyState === "open" && oe.send(new Uint8Array([1]));
          }, this.heartbeatTimeoutMs);
        }
        handleSignal(k) {
          return Qe(this, void 0, void 0, function* () {
            const { peerConnection: W } = this, { track: X } = this.config.baseConfig, ie = (() => {
              try {
                return JSON.parse(k.getPayload());
              } catch {
                return;
              }
            })();
            if (!ie)
              return void f.a.error("Received unparseable signal.");
            f.a.debug("Handling signal", { description: ie });
            const { sdp: oe, type: he } = ie;
            if (!oe || !he)
              return void f.a.warn("Received non-SDP signal");
            const { signalingState: ye, connectionState: _e } = W;
            if (ye !== "stable" || _e !== "connected")
              if (W.remoteDescription)
                f.a.warn(`Received SDP after remote description was set: ${oe}`);
              else {
                if (he === "offer") {
                  if (ye !== "stable")
                    return void f.a.warn("Received offer SDP when signaling is ongoing.");
                  yield W.setRemoteDescription(ie);
                  const ce = yield W.createAnswer();
                  yield W.setLocalDescription(ce);
                  const le = k.clone();
                  return X == null || X("Answer Received", le), le.setPayload(JSON.stringify(ce)), le.setReceiverId(k.getSenderId()), le.setSenderId(k.getReceiverId()), le;
                }
                if (he === "answer") {
                  if (ye === "stable")
                    return void f.a.warn("Received answer SDP when signaling hasn't started.");
                  yield W.setRemoteDescription(ie);
                }
              }
            else
              f.a.warn(`Received SDP when already connected: ${oe}`);
          });
        }
        send(k, W) {
          const X = this.getChannelFromLabel(W.channelLabel);
          X ? this.sendOnChannel(X, k) : f.a.warn("Send called with unexpected channel label", { channelLabel: W.channelLabel });
        }
        controlRemoteStream(k) {
          this.sendSystemMessage(m(this.reliableStreamChannel), { type: "stream-control", streamControl: k });
        }
        isActive() {
          return (/* @__PURE__ */ new Set(["new", "checking", "connected", "completed"])).has(this.peerConnection.iceConnectionState) || this.isReady();
        }
        isReady() {
          const { reliableStreamChannel: k, latestTtlStreamChannel: W, latestTryOnceStreamChannel: X, latestReliableStreamChannel: ie } = this;
          return (k == null ? void 0 : k.readyState) === "open" && (W == null ? void 0 : W.readyState) === "open" && (X == null ? void 0 : X.readyState) === "open" && (ie == null ? void 0 : ie.readyState) === "open";
        }
        close() {
          return Qe(this, void 0, void 0, function* () {
            if (this.closeCalled)
              return;
            this.closeCalled = !0, this.sessionMetrics && (yield this.sessionMetrics.uploadMetrics()), at(this.pingUpdateTimeout), at(this.pingV2UpdateTimeout), at(this.pingV2MetricsGatherTimeout), at(this.reassemblyTableCleanupTimeout), at(this.streamsInfoUpdateTimeout), at(this.heartbeatTimeout);
            const { peerConnection: k, reliableStreamChannel: W, latestTtlStreamChannel: X, latestTryOnceStreamChannel: ie, latestReliableStreamChannel: oe } = this;
            k.close(), W == null || W.close(), X == null || X.close(), ie == null || ie.close(), oe == null || oe.close();
          });
        }
        getPing() {
          return this.pingTimeMs;
        }
        getPingInfo() {
          return this.pingInfo;
        }
        getLastMessageTimestamp() {
          return this.lastMessageTimestamp;
        }
        getSessionCreatedTimestamp() {
          var k;
          return (k = this.config.remoteConfig) === null || k === void 0 ? void 0 : k.sessionCreatedTimestamp;
        }
        setSessionCreatedTimestamp(k) {
          this.config.remoteConfig && (this.config.remoteConfig.sessionCreatedTimestamp = k);
        }
        getSessionId() {
          var k;
          return (k = this.config.remoteConfig) === null || k === void 0 ? void 0 : k.sessionId;
        }
        setSessionId(k) {
          this.config.remoteConfig && (this.config.remoteConfig.sessionId = k, this.sessionMetrics = new Oe(k, this));
        }
        getRemotePeerId() {
          return this.config.baseConfig.remotePeerId;
        }
        getRemoteDeviceId() {
          var k;
          return (k = this.config.baseConfig) === null || k === void 0 ? void 0 : k.remoteDeviceId;
        }
        setRemoteDeviceId(k) {
          this.config.baseConfig.remoteDeviceId = k;
        }
        getSessionMetricsMessageCounts() {
          var k;
          return (k = this.sessionMetrics) === null || k === void 0 ? void 0 : k.counts;
        }
        getConnectionStatsInfo() {
          return Qe(this, void 0, void 0, function* () {
            const { peerConnection: k } = this;
            if (!k)
              return;
            const W = yield k.getStats(null), X = [];
            W.forEach((_e) => {
              X.push(_e);
            });
            const ie = X.find((_e) => _e.type === "transport");
            if (!ie)
              return;
            const oe = X.find((_e) => (_e.type === "candidate-pair" || _e.type === "candidatepair") && _e.id === ie.selectedCandidatePairId);
            if (!oe)
              return;
            const he = X.find((_e) => _e.id === oe.localCandidateId), ye = X.find((_e) => _e.id === oe.remoteCandidateId);
            return he && ye && (he.address = he.address || he.ip, ye.address = ye.address || ye.ip, he.address !== void 0 && ye.address !== void 0) ? { transport: ie, localCandidate: he, remoteCandidate: ye } : void 0;
          });
        }
        initializeChannels(k) {
          this.heartbeatChannel = k.createDataChannel("heartbeat", se), this.heartbeatChannel.binaryType = "arraybuffer", this.latestTtlStreamChannel = k.createDataChannel("stream.latest-ttl", U), this.latestTtlStreamChannel.binaryType = "arraybuffer", this.reliableStreamChannel = k.createDataChannel("stream.reliable", J), this.reliableStreamChannel.binaryType = "arraybuffer", this.latestReliableStreamChannel = k.createDataChannel("stream.latest-reliable", K), this.latestReliableStreamChannel.binaryType = "arraybuffer", this.latestTryOnceStreamChannel = k.createDataChannel("stream.latest-try-once", re), this.latestTryOnceStreamChannel.binaryType = "arraybuffer", this.setupChannel(this.latestTtlStreamChannel), this.setupChannel(this.reliableStreamChannel), this.setupChannel(this.latestReliableStreamChannel), this.setupChannel(this.latestTryOnceStreamChannel);
        }
        getOffer() {
          var k, W, X;
          return Qe(this, void 0, void 0, function* () {
            const { gotOffer: ie } = this, { peerConnection: oe, config: he } = this;
            if (this.config.baseConfig.isLan)
              throw new Error('"getOffer" method can only be called with internet connections. LAN connections should call the "getLanOffer" method.');
            const ye = (k = this.config.remoteConfig) === null || k === void 0 ? void 0 : k.sessionId;
            if (ie)
              return void f.a.debug("Failed to generate offer because gotOffer was already called.");
            if (this.gotOffer = !0, qe(this.peerConnection))
              return void f.a.debug("Failed to generate offer because the peer connection was inactive.");
            const _e = he.baseConfig.track;
            oe.onicecandidate = () => {
              this.hasIceCandidate = !0;
            }, oe.oniceconnectionstatechange = () => Qe(this, void 0, void 0, function* () {
              const Ne = oe.iceConnectionState;
              if (Ne === "connected" || Ne === "completed") {
                const Fe = yield this.getConnectionStatsInfo(), Ye = Fe ? function(Ge) {
                  const Ze = Ge.localCandidate.candidateType, De = Ge.remoteCandidate.candidateType;
                  return Ze === "host" && De === "host" ? "local" : Ze === "relay" || De === "relay" ? "TURN" : "STUN";
                }(Fe) : void 0;
                f.a.info(`ICE connection state changed to ${Ne}`, { sessionId: ye, connectionStatsInfo: Fe, iceMode: Ye }), _e == null || _e("ICE connection state change", { iceConnectionState: Ne, sessionId: ye, connectionStatsInfo: Fe, iceMode: Ye });
              }
            }), yield oe.setLocalDescription(yield oe.createOffer());
            const ce = (/* @__PURE__ */ new Date()).getTime();
            for (; ; ) {
              const Ne = (/* @__PURE__ */ new Date()).getTime() - ce;
              if (Ne > this.connectTimeoutMs)
                return void f.a.debug("Failed to generate offer because ICE gathering timed out.");
              if (Ne > this.iceGatheringTimeoutMs && this.hasIceCandidate) {
                // f.a.debug("ICE gathering partially completed; proceeding", { iceTransportPolicy: oe.getConfiguration().iceTransportPolicy, waitTime: Ne }), _e == null || _e("ICE gathering partially completed", { sessionId: ye, iceTransportPolicy: oe.getConfiguration().iceTransportPolicy, waitTime: Ne });
                break;
              }
              if (oe.iceGatheringState === "complete") {
                // f.a.debug("ICE gathering complete", { iceTransportPolicy: oe.getConfiguration().iceTransportPolicy, waitTime: Ne }), _e == null || _e("ICE gathering completed", { sessionId: ye, iceTransportPolicy: oe.getConfiguration().iceTransportPolicy, waitTime: Ne });
                break;
              }
              yield Object(c.a)(0.1 * g.a.second);
            }
            const le = [];
            for (const Ne of le)
              "credentialType" in Ne && (Ne.credentialType = void 0);
            const Re = JSON.stringify(le), Me = new ee.Signal();
            return Me.setPayload(JSON.stringify(oe.localDescription)), Me.setSenderId(this.config.baseConfig.localPeerId), Me.setReceiverId(this.config.baseConfig.remotePeerId), Me.setIceServers(Re), Me.setIceTransportPolicy("all"), this.config.baseConfig.sessionType !== void 0 ? Me.setSessionType(this.config.baseConfig.sessionType) : Me.setSessionType(ee.SessionType.TELEOP), f.a.debug("Sending offer signal with description", { description: Me.getPayload() }), Me;
          });
        }
        getLanOffer() {
          return Qe(this, void 0, void 0, function* () {
            const { peerConnection: k, gotOffer: W } = this;
            if (!this.config.baseConfig.isLan)
              throw new Error('"getLanOffer" method can only be used with LAN connections. Internet connections should call the "getOffer" method.');
            if (W)
              return void f.a.debug("Failed to generate offer because gotOffer was already called.");
            if (this.gotOffer = !0, qe(this.peerConnection))
              return void f.a.debug("Failed to generate offer because the peer connection was inactive.");
            yield k.setLocalDescription(yield k.createOffer());
            const X = (/* @__PURE__ */ new Date()).getTime();
            for (; ; ) {
              if ((/* @__PURE__ */ new Date()).getTime() - X > this.iceGatheringTimeoutMs)
                return void f.a.debug("Failed to generate offer because ICE gathering timed out.");
              if (k.iceGatheringState === "complete")
                break;
              yield Object(c.a)(0.1 * g.a.second);
            }
            const ie = k.localDescription;
            if (ie)
              return f.a.debug("Sending LAN offer signal with description", { description: ie }), ie;
            f.a.error("Failed to generate LAN offer description");
          });
        }
        handleLanAnswer(k) {
          return Qe(this, void 0, void 0, function* () {
            const { peerConnection: W } = this;
            if (!this.config.baseConfig.isLan)
              throw new Error('"handleLanAnswer" method can only be used with LAN connections. Internet connections should call the "handleSignal" method.');
            yield W.setRemoteDescription(k);
          });
        }
        getChannelFromLabel(k) {
          switch (k) {
            case "stream.latest-ttl":
              return this.latestTtlStreamChannel;
            case "stream.reliable":
              return this.reliableStreamChannel;
            case "stream.latest-reliable":
              return this.latestReliableStreamChannel;
            case "stream.latest-try-once":
              return this.latestTryOnceStreamChannel;
          }
        }
        sendOnChannel(k, W) {
          let X;
          try {
            X = Object(A.encode)(JSON.stringify(W));
          } catch (ie) {
            return void f.a.warn("Failed to encode RTC message", { error: ie });
          }
          try {
            k.send(X), this.sessionMetrics && this.sessionMetrics.incrementLocalSent(W);
          } catch (ie) {
            f.a.warn("Failed to send message to channel", { error: ie, channel: k.label });
          }
        }
        channelNotRecognized(k) {
          return k !== this.latestTtlStreamChannel && k !== this.latestReliableStreamChannel && k !== this.latestTryOnceStreamChannel && k !== this.reliableStreamChannel;
        }
        setupChannel(k) {
          k.onmessage = (W) => {
            if (this.channelNotRecognized(k))
              return void f.a.warn("Received message on unrecognized data channel.");
            let X;
            try {
              X = JSON.parse(Object(A.decode)(W.data));
            } catch (ie) {
              return void f.a.warn("Received unparseable message on RTC stream data channel", { error: ie, channel: k.label });
            }
            X.communicationType === "message-chunk" ? this.receiveChannelMessageChunk(k, X) : this.receiveChannelMessage(k, X);
          }, k.onerror = (W) => {
            f.a.warn(`Channel error: ${W.error}`, { error: W.error, sessionId: this.getSessionId(), channelLabel: k.label });
          }, k.onopen = () => {
            f.a.debug("Channel opened", { sessionId: this.getSessionId(), channelLabel: k.label });
          }, k.onclose = () => {
            const W = { bufferedAmount: k.bufferedAmount, sessionId: this.getSessionId(), channelLabel: k.label };
            this.closeCalled === !1 ? f.a.debug("Unexpected channel closed", W) : f.a.debug("Channel closed", W);
          };
        }
        receiveChannelMessage(k, W) {
          const { config: X } = this, { remotePeerId: ie } = this.config.baseConfig;
          this.lastMessageTimestamp = (/* @__PURE__ */ new Date()).getTime(), W = et(W), this.sessionMetrics && this.sessionMetrics.incrementLocalReceived(W), this.handleSystemMessage(k, W) || (k === this.latestTryOnceStreamChannel || k === this.latestTtlStreamChannel || k === this.latestReliableStreamChannel) && !this.isLatestMessage(W) || X.baseConfig.receive(ie, W);
        }
        receiveChannelMessageChunk(k, W) {
          const X = this.reassemblyTable.get(W.id) || [];
          if (X.push(W), X.length === W.total) {
            const ie = function(oe) {
              const he = oe.sort((ye, _e) => ye.seq < _e.seq ? -1 : 1).map((ye) => ye.part).reduce((ye, _e) => ye + _e);
              try {
                return JSON.parse(he);
              } catch {
                return void f.a.warn("Could not reassemble RTC message chunks");
              }
            }(X);
            return ie && this.receiveChannelMessage(k, ie), void this.reassemblyTable.delete(W.id);
          }
          this.reassemblyTable.set(W.id, X), this.reassemblyTableLastTimestamp.set(W.id, (/* @__PURE__ */ new Date()).getTime());
        }
        handleSystemMessage(k, W) {
          var X, ie;
          const { config: oe } = this, { baseConfig: he } = oe, { remotePeerId: ye, remoteDeviceId: _e } = he;
          switch (W.header.stream.streamType) {
            case "ping":
              return this.sendSystemMessage(k, { type: "pong", timestamp: m(W.payload.ping) }), !0;
            case "pong": {
              const ce = (/* @__PURE__ */ new Date()).getTime() - m(W.payload.pong);
              return this.pingTimeMs = ce, _.aggregate("rtc-ping-time", ce, Object.assign({}, _e ? { deviceId: _e } : {})), !0;
            }
            case "ping-v2":
              return this.sendPingV2(), !0;
            case "pong-v2": {
              const ce = m(W.payload.pongV2), le = this.pingV2Map.get(ce.id);
              return (le == null ? void 0 : le.sent) !== ce.timestamp && f.a.warn("Pong timestamp doesn't match stored value", { currentEntry: le, pong: ce }), this.pingV2Map.set(ce.id, { sent: ce.timestamp, received: (/* @__PURE__ */ new Date()).getTime() }), !0;
            }
            case "streams-info": {
              const { sessionMetrics: ce } = this, le = (X = W.payload.streamsInfo) === null || X === void 0 ? void 0 : X.timestamp;
              return !!le && (ce == null || ce.updateRemoteMessagesCounts(W), (ie = he.onStreamsInfoUpdate) === null || ie === void 0 || ie.call(he, ye, le), !0);
            }
            case "stream-control":
              return !0;
            default:
              return !1;
          }
        }
        sendSystemMessage(k, W) {
          var X;
          const { localUserId: ie, localPeerId: oe } = this.config.baseConfig;
          if (k.readyState !== "open")
            return;
          const he = { entityId: ie ?? oe, streamName: `$.${W.type}`, streamType: W.type };
          let ye;
          switch (W.type) {
            case "ping":
              ye = { ping: (/* @__PURE__ */ new Date()).getTime() };
              break;
            case "pong":
              ye = { pong: W.timestamp };
              break;
            case "ping-v2":
              ye = { pingV2: W.payload };
              break;
            case "pong-v2":
              ye = { pongV2: W.payload };
              break;
            case "stream-control":
              ye = { streamControl: W.streamControl };
              break;
            case "streams-info":
              ye = { streamsInfo: (X = this.sessionMetrics) === null || X === void 0 ? void 0 : X.getLocalStreamsInfo((/* @__PURE__ */ new Date()).getTime()) };
          }
          this.sendOnChannel(k, Pe(he, ye));
        }
        isLatestMessage(k) {
          const W = Ce(k.header.stream), X = (this.streamLatestTimestamp.get(W) || 0) <= k.header.created;
          return X && this.streamLatestTimestamp.set(W, k.header.created), X;
        }
      }
      function at(pe) {
        pe && clearInterval(pe);
      }
      function _t() {
        f.a.debug("forceGarbageCollection() triggered"), queueMicrotask(() => {
          let pe = document.createElement("img");
          pe.src = window.URL.createObjectURL(new Blob([new ArrayBuffer(5e7)])), pe.onerror = function() {
            window.URL.revokeObjectURL(this.src), pe = null;
          };
        });
      }
      function Ot(pe) {
        try {
          return pe instanceof Error ? `${pe.name}: ${pe.message}` : typeof pe == "object" ? JSON.stringify(pe) : String(pe);
        } catch {
          return "Unknown error";
        }
      }
      function St(pe) {
        var k, W;
        return { userId: (k = pe.getUserId()) === null || k === void 0 ? void 0 : k.getValue(), deviceId: (W = pe.getDeviceId()) === null || W === void 0 ? void 0 : W.getValue(), organizationId: pe.getOrganizationId(), id: pe.getPeerId(), capabilities: [], capabilitySet: {} };
      }
      var Ue = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class Mt {
        constructor(k) {
          this.config = k, this.grpcCallDeadline = 5 * g.a.second, this.refreshIntervalDelayMs = 2 * g.a.second, this.iceServersTtl = 30 * g.a.minute, this.connections = [], this.localConnections = [], this.isConnectionInitiator = /* @__PURE__ */ new Map(), this.isOutgoingConnection = /* @__PURE__ */ new Map(), this.peerDataChannelListeners = [], this.rtcInstancesConstructed = 0;
          const { refreshIntervalDelayMs: W } = this;
          this.refreshInterval = p({ func: () => Ue(this, void 0, void 0, function* () {
            try {
              yield this.update();
            } catch (X) {
              f.a.warn("RTC refresh failed", { error: X });
            }
          }), delay: W, immediate: !0 });
        }
        send(k, W, X) {
          const ie = this.getActiveConnection(k);
          ie ? ie.isReady() ? ie.send(W, X) : f.a.warn("Send called with unready connection.") : f.a.warn("Send called with no connection.");
        }
        controlRemoteStream(k, W) {
          const X = this.getActiveConnection(k);
          X ? X.isReady() ? X.controlRemoteStream(W) : f.a.warn("controlRemoteStream called with unready connection.") : f.a.warn("controlRemoteStream called with no connection.");
        }
        getLocalPeer() {
          return Ue(this, void 0, void 0, function* () {
            for (; !this.localPeer; )
              yield Object(c.a)(0.1 * g.a.second);
            return St(this.localPeer);
          });
        }
        connect(k, W) {
          var X, ie, oe;
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode === !0)
              throw new Error("connect method called in local only mode.");
            const { track: he, signalingClient: ye } = this.config, { localPeer: _e, receiveSignalStream: ce, iceServers: le } = this;
            if (!_e || !ce || !le)
              return void f.a.warn("Connect called prior to local peer, receiveSignalStream, and ICE servers ready");
            if (this.getActiveConnection(k))
              return void f.a.warn("Connect called for peer with existing connection.");
            if (this.isOutgoingConnection.get(k))
              return void f.a.warn("Connect called for peer with an existing outgoing connection offer.");
            this.isOutgoingConnection.set(k, !0);
            const Re = function(De, Le, Ve) {
              const { rtcIceTransportPolicies: $e, rtcIceServerProtocol: Ke, useAllServers: Xe } = Le || {}, ot = De.map((it) => Object.assign(Object.assign({}, it), { urls: it.urls.filter((lt) => {
                const Je = ($e === void 0 || $e.some((It) => V(lt, It))) && (Ke === void 0 || Q(lt, Ke));
                return Je || f.a.debug(`Ignoring ICE server: ${lt}`, { organizationId: Ve }), Je;
              }) })).filter(({ urls: it }) => it.filter((lt) => lt).length > 0);
              return Xe ? ot : [F(ot, "stun"), F(ot, "turn")].filter((it) => it !== void 0).map((it) => m(it));
            }(le, W);
            f.a.debug("Received ICE servers:", le), f.a.debug("Using ICE servers:", Re);
            const Me = new yt(yield this.createRTCPeerConnection(Re), { baseConfig: { isOffer: !0, isLan: !1, receive: (De, Le) => this.config.receive(De, Le), onStreamsInfoUpdate: this.config.onStreamsInfoUpdate ? (De, Le) => {
              var Ve, $e;
              return ($e = (Ve = this.config).onStreamsInfoUpdate) === null || $e === void 0 ? void 0 : $e.call(Ve, De, Le);
            } : void 0, track: this.config.lanOnlyMode ? void 0 : this.config.track, localUserId: (X = _e.getUserId()) === null || X === void 0 ? void 0 : X.getValue(), localPeerId: _e.getPeerId(), remotePeerId: k, sessionType: this.config.sessionType }, remoteConfig: {} }, (De) => this.onCustomDataChannel(k, De)), Ne = yield Me.getOffer();
            if (!Ne)
              return f.a.error("Failed to generate offer."), void this.isOutgoingConnection.delete(k);
            f.a.debug("Sending offer."), he == null || he("Sending offer", Ne);
            const Fe = new ee.SendSignalRequest();
            Fe.setSignal(Ne);
            const Ye = yield (() => Ue(this, void 0, void 0, function* () {
              try {
                return yield S.withDeadline(ye.sendSignal(Fe, yield this.getMetadata({})), this.grpcCallDeadline);
              } catch (De) {
                f.a.warn("Error when sending signal", { error: De });
              }
            }))();
            if (!this.isOutgoingConnection.get(k))
              return void f.a.debug("No offer set after receiving offer signal response.");
            f.a.debug("Offer sent.");
            const Ge = (ie = Ye == null ? void 0 : Ye.getSessionId()) === null || ie === void 0 ? void 0 : ie.getValue(), Ze = (oe = Ye == null ? void 0 : Ye.getSessionCreatedTimestamp()) === null || oe === void 0 ? void 0 : oe.getValue();
            return Ge && Ze ? (Me.setSessionId(Ge), Me.setSessionCreatedTimestamp(Ze), this.isOutgoingConnection.delete(k), this.connections.push(Me), this.isConnectionInitiator.set(Me, !0), this.setupHandlers(Me), Ge) : (f.a.warn("No session ID or no session created timestamp on send signal response."), void this.isOutgoingConnection.delete(k));
          });
        }
        connectLan(k) {
          var W, X;
          return Ue(this, void 0, void 0, function* () {
            const ie = new P(k), oe = new yt(yield this.createRTCPeerConnection([]), { baseConfig: { isOffer: !0, isLan: !0, receive: (ce, le) => this.config.receive(ce, le), onStreamsInfoUpdate: this.config.onStreamsInfoUpdate ? (ce, le) => {
              var Re, Me;
              return (Me = (Re = this.config).onStreamsInfoUpdate) === null || Me === void 0 ? void 0 : Me.call(Re, ce, le);
            } : void 0, track: this.config.lanOnlyMode ? void 0 : this.config.track, localUserId: (X = (W = this.localPeer) === null || W === void 0 ? void 0 : W.getUserId()) === null || X === void 0 ? void 0 : X.getValue(), localPeerId: "lan_client", remotePeerId: k } }, (ce) => this.onCustomDataChannel(k, ce)), he = yield oe.getLanOffer();
            if (!he)
              return f.a.warn("Could not generate LAN offer"), !1;
            const ye = yield ie.postLanRtcOffer({ offer: JSON.stringify(he) }), _e = new RTCSessionDescription(JSON.parse(ye.answer));
            return yield oe.handleLanAnswer(_e), this.localConnections.push(oe), this.isConnectionInitiator.set(oe, !0), Object(Y.a)();
          });
        }
        getConnections() {
          return [...this.connections, ...this.localConnections];
        }
        createCustomDataChannel(k, W, X, ie, oe) {
          const he = this.getActiveConnection(k);
          if (he && this.isConnectionInitiator.has(he)) {
            const _e = he.peerConnection.createDataChannel("custom." + W, X);
            return ie && (_e.binaryType = "arraybuffer"), oe(k, _e), () => {
            };
          }
          const ye = (_e, ce) => {
            k === _e && ce.label === "custom." + W && oe(k, ce);
          };
          return this.peerDataChannelListeners.push(ye), () => {
            this.peerDataChannelListeners = this.peerDataChannelListeners.filter((_e) => _e !== ye);
          };
        }
        onCustomDataChannel(k, W) {
          this.peerDataChannelListeners.forEach((X) => X(k, W));
        }
        getConnectionStatus(k) {
          if (this.isOutgoingConnection.get(k))
            return "connecting";
          const W = this.getActiveConnection(k);
          return W ? W.isReady() ? "connected" : "connecting" : "disconnected";
        }
        getConnectionStatsInfo(k) {
          return Ue(this, void 0, void 0, function* () {
            const W = this.getActiveConnection(k);
            if (W)
              return yield W.getConnectionStatsInfo();
          });
        }
        disconnect(k) {
          return Ue(this, void 0, void 0, function* () {
            const W = this.getActiveConnection(k);
            W && (yield W.close());
          });
        }
        getPeers() {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              throw new Error("getPeers method cannot be used in local-only mode.");
            const { signalingClient: k } = this.config, W = yield (() => Ue(this, void 0, void 0, function* () {
              try {
                return yield S.withDeadline(k.getPeers(new ee.GetPeersRequest(), yield this.getMetadata({})), this.grpcCallDeadline);
              } catch (oe) {
                f.a.warn("Error when getting peers", { error: oe });
              }
            }))();
            if (!W)
              return [];
            const X = W.getPeersList();
            if (!X)
              return [];
            const ie = (oe) => {
              var he, ye;
              return (ye = (he = oe.getPeerCreatedTimestamp()) === null || he === void 0 ? void 0 : he.getValue()) !== null && ye !== void 0 ? ye : 0;
            };
            return X.sort((oe, he) => ie(he) - ie(oe)).map((oe) => St(oe));
          });
        }
        getSessions() {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              throw new Error("getPeers method cannot be used in local-only mode.");
            const { signalingClient: k } = this.config, W = yield (() => Ue(this, void 0, void 0, function* () {
              try {
                return yield S.withDeadline(k.getPeers(new ee.GetPeersRequest(), yield this.getMetadata({})), this.grpcCallDeadline);
              } catch (oe) {
                f.a.warn("Error when getting peers", { error: oe });
              }
            }))();
            if (!W)
              return {};
            const X = W.getPeersList(), ie = {};
            for (const oe of X)
              ie[oe.getPeerId()] = oe.getSessionIdsList();
            return ie;
          });
        }
        getPing(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getPing();
          f.a.warn("Attempted to get ping time from inactive peer.");
        }
        getPingInfo(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getPingInfo();
          f.a.warn("Attempted to get ping time from inactive peer.");
        }
        getLastMessageTimestamp(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getLastMessageTimestamp();
          f.a.warn("Attempted to get last message time from inactive peer.");
        }
        getSessionMetricsMessageCounts(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getSessionMetricsMessageCounts();
          f.a.warn("Attempted to get session metrics counts from inactive peer.");
        }
        isReady() {
          if (this.config.lanOnlyMode)
            return !0;
          const { localPeer: k, receiveSignalStream: W, iceServers: X } = this;
          return !!(k && W && X);
        }
        shutdown() {
          return Ue(this, void 0, void 0, function* () {
            f.a.info("Shutdown called on RTC client"), yield this.refreshInterval.stop(), this.receiveSignalStream && this.receiveSignalStream.cancel();
            const k = this.connections;
            this.connections = [], yield this.closeConnections(k);
            const { localPeer: W } = this;
            if (!W || this.config.lanOnlyMode)
              return;
            const { signalingClient: X } = this.config;
            yield (() => Ue(this, void 0, void 0, function* () {
              try {
                const ie = new ee.DeletePeerRequest();
                ie.setPeerId(W.getPeerId()), yield S.withDeadline(X.deletePeer(ie, yield this.getMetadata({})), this.grpcCallDeadline);
              } catch (ie) {
                return void f.a.warn("Error deleting local peer", { error: ie });
              }
            }))();
          });
        }
        createPeer() {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              throw new Error("createPeer method cannot be used in local-only mode.");
            const { signalingClient: k } = this.config, W = yield (() => Ue(this, void 0, void 0, function* () {
              try {
                return yield S.withDeadline(k.createPeer(new ee.CreatePeerRequest(), yield this.getMetadata({})), this.grpcCallDeadline);
              } catch (ie) {
                const oe = ie;
                f.a.debug("createPeer failed", { error: oe });
                const he = Ot(oe);
                throw new Error(`Was not able to create peer: ${he}`);
              }
            }))(), X = W == null ? void 0 : W.getPeer();
            if (!X)
              throw new Error("Response did not provide peer.");
            return this.localPeer = X;
          });
        }
        createReceiveSignalStream() {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              throw new Error("createReceiveSignalStream method cannot be used in local-only mode.");
            const { signalingClient: k } = this.config, { localPeer: W, iceServers: X } = this;
            if (!W || !X)
              return;
            const { receiveSignalStream: ie } = this;
            ie && ie.cancel();
            const oe = new ee.ReceiveSignalStreamRequest();
            oe.setPeerId(W.getPeerId());
            const he = yield (() => Ue(this, void 0, void 0, function* () {
              try {
                return k.receiveSignalStream(oe, yield this.getMetadata({ hasDeadline: !1 }));
              } catch (ye) {
                f.a.debug("createReceiveSignalStream failed", { error: ye });
                const _e = Ot(ye);
                throw new Error(`Unable to create receive signal stream: ${_e}`);
              }
            }))();
            if (!he)
              throw new Error("Response did not provide stream.");
            return he.on("data", (ye) => Ue(this, void 0, void 0, function* () {
              var _e, ce, le, Re;
              const Me = ye.getSignal(), Ne = (_e = Me == null ? void 0 : Me.getSessionId()) === null || _e === void 0 ? void 0 : _e.getValue(), Fe = Me == null ? void 0 : Me.getSenderId(), Ye = Me == null ? void 0 : Me.getReceiverId(), Ge = (ce = Me == null ? void 0 : Me.getSessionCreatedTimestamp()) === null || ce === void 0 ? void 0 : ce.getValue();
              if (!(Me && Ne && Fe && Ye && Ge))
                return void f.a.warn("Received signal with missing information.");
              const Ze = this.getActiveConnection(Fe);
              if (Ze)
                if (Ze.getSessionId() !== Ne) {
                  if (f.a.debug("Received signal: different session for a peer we're already connected to."), (Ze.getSessionCreatedTimestamp() || 0) > Ge)
                    return;
                  const De = new yt(yield this.createRTCPeerConnection(X), { baseConfig: { isOffer: !1, isLan: !1, receive: (Le, Ve) => this.config.receive(Le, Ve), onStreamsInfoUpdate: this.config.onStreamsInfoUpdate ? (Le, Ve) => {
                    var $e, Ke;
                    return (Ke = ($e = this.config).onStreamsInfoUpdate) === null || Ke === void 0 ? void 0 : Ke.call($e, Le, Ve);
                  } : void 0, track: this.config.lanOnlyMode ? void 0 : this.config.track, localPeerId: W.getPeerId(), localUserId: (Re = W.getUserId()) === null || Re === void 0 ? void 0 : Re.getValue(), remotePeerId: Fe }, remoteConfig: { sessionId: Ne, sessionCreatedTimestamp: Ge } }, (Le) => this.onCustomDataChannel(Fe, Le));
                  yield De.handleSignal(Me), this.connections.push(De);
                } else
                  f.a.debug("Received signal: for an existing connection."), yield Ze.handleSignal(Me);
              else {
                f.a.debug("Received signal: new connection.");
                const De = new yt(yield this.createRTCPeerConnection(X), { baseConfig: { isOffer: !1, isLan: !1, receive: (Le, Ve) => this.config.receive(Le, Ve), onStreamsInfoUpdate: this.config.onStreamsInfoUpdate ? (Le, Ve) => {
                  var $e, Ke;
                  return (Ke = ($e = this.config).onStreamsInfoUpdate) === null || Ke === void 0 ? void 0 : Ke.call($e, Le, Ve);
                } : void 0, track: this.config.lanOnlyMode ? void 0 : this.config.track, localPeerId: W.getPeerId(), localUserId: (le = W.getUserId()) === null || le === void 0 ? void 0 : le.getValue(), remotePeerId: Fe }, remoteConfig: { sessionId: Ne, sessionCreatedTimestamp: Ge } }, (Le) => this.onCustomDataChannel(Fe, Le));
                yield De.handleSignal(Me), this.connections.push(De);
              }
            })), he.on("end", () => {
              he.cancel(), this.receiveSignalStream = void 0;
            }), he.on("error", (ye) => {
              switch (ye.code) {
                case ne.StatusCode.CANCELLED:
                case ne.StatusCode.UNAVAILABLE:
                case ne.StatusCode.UNKNOWN:
                  f.a.debug("Receive signal stream error", { error: ye });
                  break;
                case ne.StatusCode.UNAUTHENTICATED:
                  f.a.warn("Receive signal stream error", { error: ye });
                  break;
                default:
                  f.a.error("Receive signal stream error", { error: ye });
              }
              he.cancel(), this.receiveSignalStream = void 0;
            }), this.receiveSignalStream = he;
          });
        }
        createRTCPeerConnection(k) {
          var W;
          return Ue(this, void 0, void 0, function* () {
            const X = (W = this.config.alternateRTCPeerConnection) !== null && W !== void 0 ? W : window.RTCPeerConnection;
            if (!X)
              throw function() {
                const { userAgent: ie } = navigator;
                return ie.includes("Firefox/") ? "Firefox" : ie.includes("Edg/") ? "Edge" : ie.includes("Chrome/") ? "Chrome" : ie.includes("Safari/") ? "Safari" : ie.includes("MSIE/") || ie.includes("Trident/") ? "IE" : "Other";
              }() !== "Chrome" ? new Error("WebRTC is not enabled. Please try again with the latest version of Google Chrome.") : new Error("WebRTC is not enabled. Please ensure WebRTC is not disabled by ad blocking software.");
            this.rtcInstancesConstructed++, this.rtcInstancesConstructed % 20 || _t();
            try {
              return new X({ iceServers: k });
            } catch (ie) {
              throw f.a.debug(`Failed to create RTCPeerConnection: ${this.rtcInstancesConstructed} total allocated`), ie;
            }
          });
        }
        closeConnections(k) {
          return Ue(this, void 0, void 0, function* () {
            const W = yield O(k.map((X) => Ue(this, void 0, void 0, function* () {
              yield X.close();
            })));
            for (const X of W)
              f.a.warn("Request to close session failed", { error: X });
          });
        }
        getActiveConnection(k) {
          return this.getConnections().find((W) => W.getRemotePeerId() === k && W.isActive());
        }
        update() {
          var k;
          return Ue(this, void 0, void 0, function* () {
            if (this.localConnections = this.localConnections.filter((ye) => ye.isActive()), this.config.lanOnlyMode)
              return;
            const { signalingClient: W } = this.config;
            if (!this.localPeer || !this.receiveSignalStream || !this.iceServers) {
              const ye = [];
              return this.localPeer || ye.push(this.createPeer()), this.iceServers || ye.push(this.updateIceServers()), yield Promise.all(ye), void (this.receiveSignalStream || (yield this.createReceiveSignalStream()));
            }
            yield this.closeConnections(this.connections.filter((ye) => !ye.isActive())), this.connections = this.connections.filter((ye) => ye.isActive());
            const { localPeer: X } = this, ie = this.connections.filter((ye) => ye.getSessionId).map((ye) => m(ye.getSessionId()));
            X.setSessionIdsList(ie);
            const oe = new ee.RefreshPeerRequest();
            oe.setPeer(X);
            try {
              yield S.withDeadline(W.refreshPeer(oe, yield this.getMetadata({})), this.grpcCallDeadline);
            } catch (ye) {
              ye.code === ne.StatusCode.NOT_FOUND ? (f.a.warn("Peer expired, creating new peer", { peerId: X.getPeerId() }), yield this.reset()) : f.a.warn("Error calling RefreshPeer", { error: ye });
            }
            const he = yield this.getPeers();
            for (const ye of this.connections)
              ye.setRemoteDeviceId((k = he.find((_e) => _e.id === ye.getRemotePeerId())) === null || k === void 0 ? void 0 : k.deviceId);
          });
        }
        reset() {
          return Ue(this, void 0, void 0, function* () {
            yield this.closeConnections(this.connections), this.connections = [], this.isOutgoingConnection = /* @__PURE__ */ new Map(), yield this.createPeer(), yield this.createReceiveSignalStream();
          });
        }
        updateIceServers() {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              return;
            const { iceServersLastUpdate: k, iceServersTtl: W } = this, X = (/* @__PURE__ */ new Date()).getTime();
            if (!k || X - k > W)
              try {
                const ie = (yield S.withDeadline(this.config.signalingClient.getIceServers(new ee.GetIceServersRequest(), yield this.getMetadata({})), this.grpcCallDeadline)).getIceServers();
                this.iceServers = JSON.parse(ie), this.iceServersLastUpdate = X;
              } catch (ie) {
                f.a.warn("Error in updateIceServers", { error: ie });
              }
          });
        }
        setupHandlers(k) {
          const { peerConnection: W } = k, X = k.getSessionCreatedTimestamp();
          W.onconnectionstatechange = () => Ue(this, void 0, void 0, function* () {
            const ie = W.connectionState;
            if (!X)
              return;
            const oe = k.getRemoteDeviceId();
            switch (ie) {
              case "connected":
                _.aggregate("rtc-connect-time", (/* @__PURE__ */ new Date()).getTime() - X, Object.assign({}, oe ? { deviceId: oe } : {}));
                break;
              case "failed":
                _.increment("rtc-connect-failed", Object.assign({}, oe ? { deviceId: oe } : {}));
            }
          });
        }
        getMetadata(k) {
          return Ue(this, void 0, void 0, function* () {
            if (this.config.lanOnlyMode)
              throw new Error("getMetadata method cannot be called in local-only mode");
            const { getToken: W } = this.config, { grpcCallDeadline: X } = this, { hasDeadline: ie } = k, oe = ie === !1 ? void 0 : (/* @__PURE__ */ new Date()).getTime() + X;
            try {
              return { authorization: yield W(), deadline: oe };
            } catch (he) {
              throw f.a.error("getToken() failed", { error: he }), new Error("Cannot get authorization token");
            }
          });
        }
      }
      var tt = n(10), rt = n(11), jt = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class ht {
        constructor(k, W) {
          this.sessionId = k, this.connection = W, this.sentMessagesCounts = /* @__PURE__ */ new Map(), this.receivedMessagesCounts = /* @__PURE__ */ new Map(), this.sessionId = k, this.connection = W;
        }
        incrementMessageSent(k) {
          const W = Ce(k.header.stream);
          this.sentMessagesCounts.set(W, (this.sentMessagesCounts.get(W) || 0) + 1);
        }
        incrementMessageReceived(k) {
          const W = Ce(k.header.stream);
          this.receivedMessagesCounts.set(W, (this.receivedMessagesCounts.get(W) || 0) + 1);
        }
        uploadMetrics() {
          return jt(this, void 0, void 0, function* () {
            const { sessionId: k } = this, W = yield this.connection.peerConnection.getStats(), X = {};
            W.forEach((oe) => X[oe.id] = oe), f.a.debug("rtc-stats", Object.assign(Object.assign({}, X), { sessionId: k }));
            const ie = [...new Set(Array.from(this.sentMessagesCounts.keys()).concat(Array.from(this.receivedMessagesCounts.keys())))].reduce((oe, he) => {
              const ye = this.sentMessagesCounts.get(he), _e = this.receivedMessagesCounts.get(he);
              return Object.assign(Object.assign({}, oe), { [`${he}-sent`]: ye, [`${he}-received`]: _e });
            }, { sessionId: k });
            f.a.debug("rtc-message-report", ie);
          });
        }
      }
      function Ct(pe, k) {
        return Ce(pe) === Ce(k);
      }
      var st = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class Et {
        constructor(k, W) {
          this.peerConnection = k, this.config = W, this.connectTimeoutMs = 10 * g.a.second, this.gatherIceTimeoutMs = 5 * g.a.second, this.pingUpdateTimeoutMs = 2 * g.a.second, this.streamLatestTimestamp = /* @__PURE__ */ new Map(), this.closeCalled = !1, this.connectCalled = !1, this.sentOffer = !1, this.receivedIceCandidate = !1;
          const { isOffer: X } = W;
          X ? this.initializeChannels(k) : k.ondatachannel = (ie) => {
            switch (ie.channel.label) {
              case "stream.latest-ttl":
                this.latestTtlStreamChannel = ie.channel;
                break;
              case "stream.reliable":
                this.reliableStreamChannel = ie.channel;
                break;
              case "stream.latest-reliable":
                this.latestReliableStreamChannel = ie.channel;
                break;
              case "stream.latest-try-once":
                this.latestTryOnceStreamChannel = ie.channel;
            }
            this.setupChannel(ie.channel);
          }, this.sessionMetrics = new ht(this.getSessionId(), this);
        }
        connect() {
          return st(this, void 0, void 0, function* () {
            if (this.connectCalled)
              return;
            this.connectCalled = !0, this.pingUpdateTimeout = setInterval(() => {
              const { reliableStreamChannel: ie } = this;
              ie && this.sendSystemMessage(ie, { type: "ping" });
            }, this.pingUpdateTimeoutMs), this.connectTimeout = setTimeout(() => st(this, void 0, void 0, function* () {
              this.isReady() || (f.a.warn("RTC connect timed out, closing connection"), yield this.close());
            }), this.connectTimeoutMs);
            const { peerConnection: k, config: { isOffer: W, sessionId: X } } = this;
            if (W) {
              const ie = yield k.createOffer();
              yield k.setLocalDescription(ie);
            }
            W && (this.gatherIceTimeout = setTimeout(() => st(this, void 0, void 0, function* () {
              this.sentOffer || (f.a.warn("ICE gathering timed out"), this.receivedIceCandidate ? (f.a.warn("Attempting to connect with partial ICE candidate pool"), yield this.sendOffer()) : yield this.close());
            }), this.gatherIceTimeoutMs), k.onicecandidate = (ie) => st(this, void 0, void 0, function* () {
              ie.candidate ? this.receivedIceCandidate = !0 : yield this.sendOffer();
            }), k.onicegatheringstatechange = () => st(this, void 0, void 0, function* () {
              k.iceGatheringState === "complete" && (yield this.sendOffer());
            }), k.onnegotiationneeded = () => {
              f.a.debug("Negotiation needed", { sessionId: X });
            });
          });
        }
        handleSignal(k) {
          return st(this, void 0, void 0, function* () {
            const { peerConnection: W, config: { sessionId: X, sendSignal: ie } } = this, { description: oe } = JSON.parse(k.payload);
            if (f.a.debug("Handling signal", { sessionId: X, description: JSON.stringify(oe) }), oe)
              if (W.signalingState !== "stable" || W.connectionState !== "connected")
                if (W.remoteDescription)
                  f.a.warn(`Received SDP signal during negotiation when remote description is already set: ${JSON.stringify(k)}`);
                else if (oe.type === "offer") {
                  yield W.setRemoteDescription(oe);
                  const he = yield W.createAnswer();
                  yield W.setLocalDescription(he), yield ie({ payload: JSON.stringify({ description: he }) });
                } else
                  oe.type === "answer" && (yield W.setRemoteDescription(oe));
              else
                f.a.warn(`Received SDP signal when signaling is stable and connected: ${JSON.stringify(k)}`);
            else
              f.a.warn(`Received non-SDP signal: ${JSON.stringify(k)}`);
          });
        }
        send(k, W) {
          const X = this.getChannelFromLabel(W.channelLabel);
          X ? this.sendOnChannel(X, k) : f.a.warn("Send called with unexpected channel label", { channelLabel: W.channelLabel });
        }
        controlRemoteStream(k) {
          this.sendSystemMessage(m(this.reliableStreamChannel), { type: "stream-control", streamControl: k });
        }
        isActive() {
          return (/* @__PURE__ */ new Set(["new", "connecting", "connected"])).has(this.peerConnection.connectionState);
        }
        isReady() {
          const { peerConnection: k, latestTtlStreamChannel: W, reliableStreamChannel: X, latestTryOnceStreamChannel: ie } = this;
          return !!(X && W && ie) && k.connectionState === "connected" && X.readyState === "open" && W.readyState === "open" && ie.readyState === "open";
        }
        isClosed() {
          const { peerConnection: k, reliableStreamChannel: W, latestTryOnceStreamChannel: X, latestTtlStreamChannel: ie } = this;
          return !(k.connectionState !== "closed" || W !== void 0 && W.readyState !== "closed" || X !== void 0 && X.readyState !== "closed" || ie !== void 0 && ie.readyState !== "closed");
        }
        needsClosing() {
          const { peerConnection: k, latestTtlStreamChannel: W, reliableStreamChannel: X, latestTryOnceStreamChannel: ie } = this;
          if (this.isClosed())
            return !1;
          const oe = /* @__PURE__ */ new Set(["closing", "closed"]), he = (ye) => ye && oe.has(ye.readyState);
          return qe(k) || he(W) || he(X) || he(ie);
        }
        close() {
          return st(this, void 0, void 0, function* () {
            this.closeCalled || (this.closeCalled = !0, yield this.sessionMetrics.uploadMetrics(), this.pingUpdateTimeout && clearInterval(this.pingUpdateTimeout), this.connectTimeout && clearTimeout(this.connectTimeout), this.gatherIceTimeout && clearTimeout(this.gatherIceTimeout), this.peerConnection.close());
          });
        }
        getPing() {
          return this.pingTimeMs;
        }
        getLastMessageTimestamp() {
          return this.lastMessageTimestamp;
        }
        getSessionId() {
          return this.config.sessionId;
        }
        getRemotePeer() {
          return this.config.remotePeer;
        }
        initializeChannels(k) {
          this.latestTtlStreamChannel = k.createDataChannel("stream.latest-ttl", U), this.reliableStreamChannel = k.createDataChannel("stream.reliable", J), this.latestReliableStreamChannel = k.createDataChannel("stream.latest-reliable", K), this.latestTryOnceStreamChannel = k.createDataChannel("stream.latest-try-once", re), this.setupChannel(this.latestTtlStreamChannel), this.setupChannel(this.reliableStreamChannel), this.setupChannel(this.latestReliableStreamChannel), this.setupChannel(this.latestTryOnceStreamChannel);
        }
        sendOffer() {
          return st(this, void 0, void 0, function* () {
            if (this.sentOffer || (this.sentOffer = !0, qe(this.peerConnection)))
              return;
            const { peerConnection: k, config: { sendSignal: W } } = this, X = yield k.createOffer();
            yield k.setLocalDescription(X);
            const ie = { payload: JSON.stringify({ description: X }) };
            yield W(ie);
          });
        }
        getChannelFromLabel(k) {
          switch (k) {
            case "stream.latest-ttl":
              return this.latestTtlStreamChannel;
            case "stream.reliable":
              return this.reliableStreamChannel;
            case "stream.latest-reliable":
              return this.latestReliableStreamChannel;
            case "stream.latest-try-once":
              return this.latestTryOnceStreamChannel;
          }
        }
        sendOnChannel(k, W) {
          let X;
          try {
            X = Object(A.encode)(JSON.stringify(W));
          } catch (ie) {
            return void f.a.warn("Failed to encode RTC message", { error: ie });
          }
          try {
            k.send(X), this.sessionMetrics.incrementMessageSent(W);
          } catch (ie) {
            f.a.warn("Failed to send message to channel", { error: ie, channel: k.label });
          }
        }
        channelNotRecognized(k) {
          return k !== this.latestTtlStreamChannel && k !== this.latestReliableStreamChannel && k !== this.latestTryOnceStreamChannel && k !== this.reliableStreamChannel;
        }
        setupChannel(k) {
          k.onmessage = (W) => {
            if (this.channelNotRecognized(k))
              return void f.a.warn("Received message on unrecognized data channel.");
            let X;
            try {
              X = JSON.parse(Object(A.decode)(W.data));
            } catch (ie) {
              return void f.a.warn("Received unparseable RTC message", { error: ie, channel: k.label });
            }
            if (this.lastMessageTimestamp = (/* @__PURE__ */ new Date()).getTime(), X = et(X), this.sessionMetrics.incrementMessageReceived(X), !this.handleSystemMessage(k, X)) {
              if (!this.hasCapabilities(X))
                return void f.a.warn("Received RTC message that was not within the capability scope of the connection.");
              (k === this.latestTryOnceStreamChannel || k === this.latestTtlStreamChannel || k === this.latestReliableStreamChannel) && !this.isLatestMessage(X) || this.config.receive(this.config.remotePeer.id, X);
            }
          }, k.onerror = (W) => {
            f.a.warn(`Channel error: ${W.error}`, { error: W.error, sessionId: this.getSessionId(), channelLabel: k.label });
          }, k.onopen = () => {
            f.a.debug("Channel opened", { sessionId: this.getSessionId(), channelLabel: k.label });
          }, k.onclose = () => {
            const W = { bufferedAmount: k.bufferedAmount, sessionId: this.getSessionId(), channelLabel: k.label };
            this.closeCalled === !1 ? f.a.debug("Unexpected channel closed", W) : f.a.debug("Channel closed", W);
          };
        }
        handleSystemMessage(k, W) {
          switch (W.header.stream.streamType) {
            case "ping":
              return this.sendSystemMessage(k, { type: "pong", timestamp: m(W.payload.ping) }), !0;
            case "pong": {
              const X = (/* @__PURE__ */ new Date()).getTime() - m(W.payload.pong);
              return this.pingTimeMs = X, _.aggregate("rtc-ping-time", X), !0;
            }
            case "stream-control":
              return !0;
            default:
              return !1;
          }
        }
        sendSystemMessage(k, W) {
          if (k.readyState !== "open")
            return;
          const X = { entityId: m(this.config.localPeer.deviceId || this.config.localPeer.userId), streamName: `$.${W.type}`, streamType: W.type };
          let ie;
          switch (W.type) {
            case "ping":
              ie = { ping: (/* @__PURE__ */ new Date()).getTime() };
              break;
            case "pong":
              ie = { pong: W.timestamp };
              break;
            case "stream-control":
              ie = { streamControl: W.streamControl };
          }
          this.sendOnChannel(k, Pe(X, ie));
        }
        hasCapabilities(k) {
          var W, X;
          const { localPeer: ie, remotePeer: oe } = this.config, he = (W = ie.capabilitySet.streaming) === null || W === void 0 ? void 0 : W.streams, ye = he && he.some((le) => le.receive && Ct(le.stream, k.header.stream)), _e = (X = oe.capabilitySet.streaming) === null || X === void 0 ? void 0 : X.streams, ce = _e && _e.some((le) => le.send && Ct(le.stream, k.header.stream));
          return ye || ce;
        }
        isLatestMessage(k) {
          const W = Ce(k.header.stream), X = (this.streamLatestTimestamp.get(W) || 0) <= k.header.created;
          return X && this.streamLatestTimestamp.set(W, k.header.created), X;
        }
      }
      var Be = function(pe, k, W, X) {
        return new (W || (W = Promise))(function(ie, oe) {
          function he(ce) {
            try {
              _e(X.next(ce));
            } catch (le) {
              oe(le);
            }
          }
          function ye(ce) {
            try {
              _e(X.throw(ce));
            } catch (le) {
              oe(le);
            }
          }
          function _e(ce) {
            var le;
            ce.done ? ie(ce.value) : (le = ce.value, le instanceof W ? le : new W(function(Re) {
              Re(le);
            })).then(he, ye);
          }
          _e((X = X.apply(pe, k || [])).next());
        });
      };
      class Tt {
        constructor(k) {
          this.config = k, this.connections = [], this.connectingSessions = /* @__PURE__ */ new Map(), this.rtcInstancesConstructed = 0, this.updateInterval = p({ func: () => Be(this, void 0, void 0, function* () {
            try {
              yield this.update();
            } catch (W) {
              f.a.warn("RTC update failed", { error: W });
            }
          }), delay: 250 * g.a.millisecond, immediate: !0 }), this.localPeer = this.createPeer();
        }
        send(k, W, X) {
          const ie = this.getActiveConnection(k);
          ie ? ie.isReady() ? ie.send(W, X) : f.a.warn("Attempted to send with an active connection to that peer which was not yet ready.") : f.a.warn("Attempted to send with no active connection to that peer.");
        }
        controlRemoteStream(k, W) {
          const X = this.getActiveConnection(k);
          X ? X.isReady() ? X.controlRemoteStream(W) : f.a.warn("Attempted to control remote stream with an active connection to that peer which was not yet ready.") : f.a.warn("Attempted to control remote stream with no active connection to that peer.");
        }
        connect(k) {
          return Be(this, void 0, void 0, function* () {
            const W = yield this.getLocalPeer();
            if (this.getActiveConnection(k))
              return void f.a.warn("Attempted to connect to peer with an already active connection.");
            let X;
            try {
              X = yield this.config.signalingClient.createSession(yield this.config.getToken(), { offerPeerId: W.id, answerPeerId: k });
            } catch (ie) {
              Object(rt.a)(ie, tt.a, (oe) => oe.statusCode === 404), f.a.warn("Attempted to connect to peer that does not exist.");
            }
            if (X)
              for (this.connectingSessions.set(X.id, (/* @__PURE__ */ new Date()).getTime()), yield this.connectToSession(X); ; )
                switch (yield Object(c.a)(0.1), this.getConnectionStatus(k)) {
                  case "connecting":
                    continue;
                  case "connected":
                    return X.id;
                  case "disconnected":
                    return;
                }
          });
        }
        getConnectionStatus(k) {
          const W = this.getActiveConnection(k);
          return W ? W.isReady() ? "connected" : "connecting" : "disconnected";
        }
        getIceMode(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.iceMode;
        }
        disconnect(k) {
          return Be(this, void 0, void 0, function* () {
            const W = this.getActiveConnection(k);
            W && (yield this.closeConnection(W));
          });
        }
        getLocalPeer() {
          return Be(this, void 0, void 0, function* () {
            return yield this.localPeer;
          });
        }
        getPeers() {
          return Be(this, void 0, void 0, function* () {
            return yield this.config.signalingClient.getPeers(yield this.config.getToken());
          });
        }
        getPing(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getPing();
          f.a.warn("Attempted to get ping time from inactive peer.");
        }
        getLastMessageTimestamp(k) {
          const W = this.getActiveConnection(k);
          if (W)
            return W.getLastMessageTimestamp();
          f.a.warn("Attempted to get ping time from inactive peer.");
        }
        shutdown() {
          return Be(this, void 0, void 0, function* () {
            yield this.updateInterval.stop();
            const k = this.connections;
            this.connections = [], yield this.closeConnections(k);
          });
        }
        closeConnection(k) {
          return Be(this, void 0, void 0, function* () {
            this.connectingSessions.delete(k.getSessionId()), yield k.close();
            try {
              yield this.config.signalingClient.deleteSession(yield this.config.getToken(), k.getSessionId());
            } catch (W) {
              Object(rt.a)(W, tt.a, (X) => X.statusCode === 404);
            }
          });
        }
        getSessions() {
          return Be(this, void 0, void 0, function* () {
            const k = yield this.getLocalPeer();
            return (yield this.config.signalingClient.getSessions(yield this.config.getToken())).filter((W) => W.offer.peer.id === k.id || W.answer.peer.id === k.id);
          });
        }
        createPeer() {
          return Be(this, void 0, void 0, function* () {
            return yield this.config.signalingClient.createPeer(yield this.config.getToken(), { capabilitySet: this.config.capabilitySet || {} });
          });
        }
        createRTCPeerConnection(k = {}) {
          return Be(this, void 0, void 0, function* () {
            const W = this.config.alternateRTCPeerConnection || RTCPeerConnection;
            this.rtcInstancesConstructed++, this.rtcInstancesConstructed % 20 || _t();
            try {
              return new W(Object.assign({ iceServers: yield this.config.signalingClient.getIceServers(yield this.config.getToken()) }, k));
            } catch (X) {
              throw f.a.debug(`Failed to create RTCPeerConnection: ${this.rtcInstancesConstructed} total allocated`), X;
            }
          });
        }
        closeConnections(k) {
          return Be(this, void 0, void 0, function* () {
            const W = yield O(k.map((X) => Be(this, void 0, void 0, function* () {
              yield this.closeConnection(X);
            })));
            for (const X of W)
              f.a.warn("Request to close session failed", { error: X });
          });
        }
        reset() {
          return Be(this, void 0, void 0, function* () {
            yield this.closeConnections(this.connections), this.connections = [], this.connectingSessions = /* @__PURE__ */ new Map(), this.localPeer = this.createPeer(), yield this.localPeer;
          });
        }
        getActiveConnection(k) {
          return this.connections.find((W) => W.getRemotePeer().id === k && W.isActive());
        }
        update() {
          return Be(this, void 0, void 0, function* () {
            const k = yield this.getLocalPeer();
            try {
              yield this.config.signalingClient.refreshPeer(yield this.config.getToken(), k.id);
            } catch (W) {
              Object(rt.a)(W, tt.a, (X) => X.statusCode === 404), f.a.warn("Peer expired, creating new peer", { peerId: k.id }), yield this.reset();
            }
            yield this.handleSessions(yield this.getSessions());
          });
        }
        handleSessions(k) {
          return Be(this, void 0, void 0, function* () {
            yield this.syncConnectionsAndSessions(k);
            const W = k.map((X) => ({ session: X, connection: this.connections.find((ie) => ie.getSessionId() === X.id) }));
            yield Promise.all(W.map(({ session: X, connection: ie }) => Be(this, void 0, void 0, function* () {
              return yield this.maintainConnection(X, ie);
            })));
          });
        }
        syncConnectionsAndSessions(k) {
          return Be(this, void 0, void 0, function* () {
            const W = new Set(k.map((oe) => oe.id)), X = (oe) => W.has(oe.getSessionId()) || this.connectingSessions.has(oe.getSessionId());
            this.connections = this.connections.filter((oe) => X(oe));
            const ie = this.connections.filter((oe) => !X(oe) || oe.needsClosing());
            yield Promise.all(ie.map((oe) => Be(this, void 0, void 0, function* () {
              yield this.closeConnection(oe);
            })));
          });
        }
        maintainConnection(k, W) {
          return Be(this, void 0, void 0, function* () {
            const X = yield this.getLocalPeer(), ie = k.offer.peer.id === X.id;
            if (W) {
              if (W.isReady())
                try {
                  yield this.config.signalingClient.refreshSession(yield this.config.getToken(), k.id);
                } catch (oe) {
                  Object(rt.a)(oe, tt.a, (he) => he.statusCode === 404), f.a.debug("Refresh session not found", { sessionId: k.id });
                }
              else if (W.isActive())
                try {
                  yield this.consumeSignals(W);
                } catch (oe) {
                  f.a.warn("Failed to ingest signals, closing connection", { error: oe }), yield this.closeConnection(W);
                }
            } else {
              if (ie)
                return;
              yield this.connectToSession(k);
            }
          });
        }
        connectToSession(k) {
          return Be(this, void 0, void 0, function* () {
            const W = yield this.getLocalPeer(), X = k.offer.peer.id === W.id, ie = yield this.createRTCPeerConnection(), oe = new Et(ie, { localPeer: X ? k.offer.peer : k.answer.peer, remotePeer: X ? k.answer.peer : k.offer.peer, sessionId: k.id, isOffer: X, sendSignal: (he) => this.sendSignal(k.id, he), receive: (he, ye) => this.config.receive(he, ye) });
            if (this.connections.find((he) => he.getSessionId() === k.id))
              return f.a.warn("connectToSession called on a session that already has a connection.", { sessionId: k.id }), void (yield oe.close());
            this.setupHandlers(oe), this.connections.push(oe);
            try {
              yield oe.connect();
            } catch (he) {
              f.a.warn("Failed to handle negotiation, closing connection", { error: he }), yield this.closeConnection(oe);
            }
          });
        }
        setupHandlers(k) {
          const { peerConnection: W } = k, X = k.getSessionId();
          W.onconnectionstatechange = () => Be(this, void 0, void 0, function* () {
            const ie = this.connectingSessions.get(X);
            if (ie === void 0)
              return;
            const oe = W.connectionState;
            switch (qe(W) && this.connectingSessions.delete(X), oe) {
              case "connected": {
                this.connectingSessions.delete(X);
                const he = (/* @__PURE__ */ new Date()).getTime() - ie;
                _.aggregate("rtc-connect-time", he);
                break;
              }
              case "failed":
                _.increment("rtc-connect-failed"), yield this.closeConnection(k);
            }
          });
        }
        consumeSignals(k) {
          return Be(this, void 0, void 0, function* () {
            let W = [];
            try {
              W = yield this.config.signalingClient.takeSignals(yield this.config.getToken(), k.getSessionId());
            } catch (X) {
              Object(rt.a)(X, tt.a, (ie) => ie.statusCode === 404);
            }
            for (const X of W)
              yield k.handleSignal(X);
          });
        }
        sendSignal(k, W) {
          return Be(this, void 0, void 0, function* () {
            try {
              yield this.config.signalingClient.addSignals(yield this.config.getToken(), k, { signals: [W] });
            } catch (X) {
              Object(rt.a)(X, tt.a, (ie) => ie.statusCode === 404);
            }
          });
        }
      }
    }, function(e, t, n) {
      var r = { randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
      let o;
      const l = new Uint8Array(16);
      function u() {
        if (!o && (o = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !o))
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return o(l);
      }
      const s = [];
      for (let c = 0; c < 256; ++c)
        s.push((c + 256).toString(16).slice(1));
      function g(c, d = 0) {
        return (s[c[d + 0]] + s[c[d + 1]] + s[c[d + 2]] + s[c[d + 3]] + "-" + s[c[d + 4]] + s[c[d + 5]] + "-" + s[c[d + 6]] + s[c[d + 7]] + "-" + s[c[d + 8]] + s[c[d + 9]] + "-" + s[c[d + 10]] + s[c[d + 11]] + s[c[d + 12]] + s[c[d + 13]] + s[c[d + 14]] + s[c[d + 15]]).toLowerCase();
      }
      t.a = function(c, d, T) {
        if (r.randomUUID && !d && !c)
          return r.randomUUID();
        const b = (c = c || {}).random || (c.rng || u)();
        if (b[6] = 15 & b[6] | 64, b[8] = 63 & b[8] | 128, d) {
          T = T || 0;
          for (let h = 0; h < 16; ++h)
            d[T + h] = b[h];
          return d;
        }
        return g(b);
      };
    }, , function(e, t, n) {
      n.r(t), n.d(t, "LogClient", function() {
        return s;
      });
      var r = n(28), o = n(11), l = n(10), u = function(g, c, d, T) {
        return new (d || (d = Promise))(function(b, h) {
          function f(j) {
            try {
              E(T.next(j));
            } catch (B) {
              h(B);
            }
          }
          function v(j) {
            try {
              E(T.throw(j));
            } catch (B) {
              h(B);
            }
          }
          function E(j) {
            var B;
            j.done ? b(j.value) : (B = j.value, B instanceof d ? B : new d(function(I) {
              I(B);
            })).then(f, v);
          }
          E((T = T.apply(g, c || [])).next());
        });
      };
      class s extends r.a {
        log(c) {
          return u(this, void 0, void 0, function* () {
            const d = s.token;
            try {
              yield this.fetch("logs", { token: d, method: "POST", body: JSON.stringify({ logs: c }), allowUnsafeRetries: !0 });
            } catch (T) {
              Object(o.a)(T, l.a, (b) => b.statusCode === 401 && d !== void 0), s.token === d && delete s.token, yield this.log(c);
            }
          });
        }
      }
    }]);
  });
})(dist);
var distExports = dist.exports;
const SessionTypes = {
  UNKNOWN: 0,
  TELEOP: 1,
  PORT_FORWARD: 2,
  OBSERVE: 3
}, SessionTypeConstants = {
  ...SessionTypes,
  Unknown: SessionTypes.UNKNOWN,
  Teleop: SessionTypes.TELEOP,
  PortForward: SessionTypes.PORT_FORWARD,
  Observe: SessionTypes.OBSERVE,
  unknown: SessionTypes.UNKNOWN,
  teleop: SessionTypes.TELEOP,
  portForward: SessionTypes.PORT_FORWARD,
  observe: SessionTypes.OBSERVE
}, singleton = Symbol("RtcClientPool.instance");
var un;
class RtcClientPool {
  constructor(t) {
    be(this, un, null);
    be(this, "createClient");
    be(this, "ttlMs");
    be(this, "proxyHandler");
    be(this, "proxyReceivers", /* @__PURE__ */ new Map());
    be(this, "teardownTimeout", null);
    be(this, "dispatch", (t, n) => {
      this.proxyReceivers.forEach((r) => r == null ? void 0 : r(t, n));
    });
    const { createClient: n, ttlMs: r = 0 } = t;
    this.createClient = n, this.ttlMs = Math.max(r, 0), this.proxyHandler = {
      get: (o, l, u) => {
        switch (l) {
          case "shutdown":
            return () => this.releaseInstance(u);
          default:
            return Reflect.get(o, l, u);
        }
      }
    };
  }
  get isActive() {
    return this[singleton] !== null;
  }
  get size() {
    return this.proxyReceivers.size;
  }
  get(t) {
    const n = new Proxy(this.allocate(), this.proxyHandler);
    return this.proxyReceivers.set(n, t ?? null), n;
  }
  allocate() {
    if (this[singleton])
      return this.teardownTimeout && (clearTimeout(this.teardownTimeout), this.teardownTimeout = null), this[singleton];
    const t = this.createClient(this.dispatch);
    return this[singleton] = t, t;
  }
  async teardown() {
    const t = this[singleton];
    if (!t) {
      console.warn("singleton has already been shutdown!");
      return;
    }
    try {
      await t.shutdown();
    } finally {
      this[singleton] = null;
    }
  }
  async releaseInstance(t) {
    return this.proxyReceivers.delete(t) ? this.proxyReceivers.size !== 0 ? !1 : (!this.teardownTimeout && Number.isFinite(this.ttlMs) && (this.ttlMs === 0 ? await this.teardown() : this.teardownTimeout = setTimeout(() => {
      this.teardown().catch((n) => console.error("teardown failed", { err: n })).finally(() => this.teardownTimeout = null);
    }, this.ttlMs)), !0) : (console.warn("this instance has already been released!"), !1);
  }
}
un = singleton;
const getToken = async () => defined(Authentication.token, "Realtime when user isn't authorized"), EnumRtcClientPools = {
  [SessionTypes.UNKNOWN]: new RtcClientPool({
    ttlMs: 2500,
    createClient: (e) => new distExports.RtcClient({
      signalingClient: new distExports.SignalingPromiseClient(FORMANT_API_URL),
      getToken,
      sessionType: SessionTypes.UNKNOWN,
      receive: e
    })
  }),
  [SessionTypes.TELEOP]: new RtcClientPool({
    ttlMs: 2500,
    createClient: (e) => new distExports.RtcClient({
      signalingClient: new distExports.SignalingPromiseClient(FORMANT_API_URL),
      getToken,
      sessionType: SessionTypes.TELEOP,
      receive: e
    })
  }),
  [SessionTypes.PORT_FORWARD]: new RtcClientPool({
    ttlMs: 2500,
    createClient: (e) => new distExports.RtcClient({
      signalingClient: new distExports.SignalingPromiseClient(FORMANT_API_URL),
      getToken,
      sessionType: SessionTypes.PORT_FORWARD,
      receive: e
    })
  }),
  [SessionTypes.OBSERVE]: new RtcClientPool({
    ttlMs: 2500,
    createClient: (e) => new distExports.RtcClient({
      signalingClient: new distExports.SignalingPromiseClient(FORMANT_API_URL),
      getToken,
      sessionType: SessionTypes.OBSERVE,
      receive: e
    })
  })
}, AppRtcClientPools = {
  ...EnumRtcClientPools,
  unknown: EnumRtcClientPools[SessionTypes.UNKNOWN],
  teleop: EnumRtcClientPools[SessionTypes.TELEOP],
  portForward: EnumRtcClientPools[SessionTypes.PORT_FORWARD],
  observe: EnumRtcClientPools[SessionTypes.OBSERVE]
}, defaultRtcClientPool = EnumRtcClientPools[SessionTypes.TELEOP], getRtcClientPool = (e) => {
  const { sessionType: t } = e;
  return t ? AppRtcClientPools[t] : defaultRtcClientPool;
};
class CaptureStream {
  constructor(t) {
    be(this, "token");
    this.captureSession = t;
  }
  async ingestJSON(t) {
    if (!this.token) {
      const r = await (await fetch(
        `${FORMANT_API_URL}/v1/admin/capture-sessions/${this.captureSession.code}/authenticate`,
        {
          method: "POST"
        }
      )).json();
      this.token = r.token;
    }
    await fetch(`${FORMANT_API_URL}/v1/ingest`, {
      method: "POST",
      body: JSON.stringify({
        deviceId: this.captureSession.deviceId,
        name: this.captureSession.streamName,
        type: "json",
        points: [[Date.now(), JSON.stringify(t)]]
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + this.token
      }
    });
  }
}
function delay(e) {
  return new Promise((t) => setTimeout(t, e));
}
const isRtcPeer = (e) => e !== void 0 && e.capabilities !== void 0 && e.capabilitySet !== void 0;
class DataChannel {
  constructor(t) {
    be(this, "ready", !1);
    be(this, "listeners", []);
    be(this, "openListeners", []);
    be(this, "closeListeners", []);
    be(this, "errorListeners", []);
    be(this, "binaryListeners", []);
    be(this, "error");
    be(this, "decoder", new TextDecoder());
    this.dataChannel = t, this.dataChannel.binaryType = "arraybuffer", this.dataChannel.onopen = () => {
      this.setReady();
    }, this.dataChannel.onclose = () => {
      this.ready = !1, this.closeListeners.forEach((n) => n());
    }, this.dataChannel.onerror = (n) => {
      console.error(n), this.error = "An error occurred in DataChannel", this.errorListeners.forEach((r) => r(n));
    }, this.dataChannel.onmessage = (n) => {
      this.listeners.forEach((r) => {
        const o = new Uint8Array(n.data), l = this.decoder.decode(o);
        r(l);
      }), this.binaryListeners.forEach((r) => {
        r(new Uint8Array(n.data));
      });
    };
  }
  setReady() {
    this.ready = !0, this.openListeners.forEach((t) => t());
  }
  addOpenListener(t) {
    this.openListeners.push(t);
  }
  removeOpenListener(t) {
    this.openListeners = this.openListeners.filter((n) => n !== t);
  }
  addCloseListener(t) {
    this.closeListeners.push(t);
  }
  removeCloseListener(t) {
    this.closeListeners = this.closeListeners.filter((n) => n !== t);
  }
  addErrorListener(t) {
    this.errorListeners.push(t);
  }
  removeErrorListener(t) {
    this.errorListeners = this.errorListeners.filter((n) => n !== t);
  }
  async waitTilReady() {
    return this.ready ? !0 : new Promise((n, r) => {
      let o = setInterval(() => {
        this.dataChannel.readyState === "open" && this.setReady(), this.ready && (clearInterval(o), n(!0)), this.error && r(this.error);
      }, 10);
    });
  }
  send(t) {
    if (!this.ready)
      throw new Error("Connection has been closed");
    this.dataChannel.send(t);
  }
  sendBinary(t) {
    if (!this.ready)
      throw new Error("Connection has been closed");
    this.dataChannel.send(t);
  }
  addListener(t) {
    this.listeners.push(t);
  }
  removeListener(t) {
    const n = this.listeners.indexOf(t);
    if (n === -1)
      throw new Error("Could not find data channel listener to remove");
    if (this.error)
      throw new Error(this.error);
    this.listeners.splice(n, 1);
  }
  addBinaryListener(t) {
    this.binaryListeners.push(t);
  }
  removeBinaryListener(t) {
    const n = this.binaryListeners.indexOf(t);
    if (n === -1)
      throw new Error("Could not find data channel listener to remove");
    if (this.error)
      throw new Error(this.error);
    this.binaryListeners.splice(n, 1);
  }
}
var eventemitter3 = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function o(g, c, d) {
    this.fn = g, this.context = c, this.once = d || !1;
  }
  function l(g, c, d, T, b) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var h = new o(d, T || g, b), f = n ? n + c : c;
    return g._events[f] ? g._events[f].fn ? g._events[f] = [g._events[f], h] : g._events[f].push(h) : (g._events[f] = h, g._eventsCount++), g;
  }
  function u(g, c) {
    --g._eventsCount === 0 ? g._events = new r() : delete g._events[c];
  }
  function s() {
    this._events = new r(), this._eventsCount = 0;
  }
  s.prototype.eventNames = function() {
    var c = [], d, T;
    if (this._eventsCount === 0)
      return c;
    for (T in d = this._events)
      t.call(d, T) && c.push(n ? T.slice(1) : T);
    return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(d)) : c;
  }, s.prototype.listeners = function(c) {
    var d = n ? n + c : c, T = this._events[d];
    if (!T)
      return [];
    if (T.fn)
      return [T.fn];
    for (var b = 0, h = T.length, f = new Array(h); b < h; b++)
      f[b] = T[b].fn;
    return f;
  }, s.prototype.listenerCount = function(c) {
    var d = n ? n + c : c, T = this._events[d];
    return T ? T.fn ? 1 : T.length : 0;
  }, s.prototype.emit = function(c, d, T, b, h, f) {
    var v = n ? n + c : c;
    if (!this._events[v])
      return !1;
    var E = this._events[v], j = arguments.length, B, I;
    if (E.fn) {
      switch (E.once && this.removeListener(c, E.fn, void 0, !0), j) {
        case 1:
          return E.fn.call(E.context), !0;
        case 2:
          return E.fn.call(E.context, d), !0;
        case 3:
          return E.fn.call(E.context, d, T), !0;
        case 4:
          return E.fn.call(E.context, d, T, b), !0;
        case 5:
          return E.fn.call(E.context, d, T, b, h), !0;
        case 6:
          return E.fn.call(E.context, d, T, b, h, f), !0;
      }
      for (I = 1, B = new Array(j - 1); I < j; I++)
        B[I - 1] = arguments[I];
      E.fn.apply(E.context, B);
    } else {
      var R = E.length, p;
      for (I = 0; I < R; I++)
        switch (E[I].once && this.removeListener(c, E[I].fn, void 0, !0), j) {
          case 1:
            E[I].fn.call(E[I].context);
            break;
          case 2:
            E[I].fn.call(E[I].context, d);
            break;
          case 3:
            E[I].fn.call(E[I].context, d, T);
            break;
          case 4:
            E[I].fn.call(E[I].context, d, T, b);
            break;
          default:
            if (!B)
              for (p = 1, B = new Array(j - 1); p < j; p++)
                B[p - 1] = arguments[p];
            E[I].fn.apply(E[I].context, B);
        }
    }
    return !0;
  }, s.prototype.on = function(c, d, T) {
    return l(this, c, d, T, !1);
  }, s.prototype.once = function(c, d, T) {
    return l(this, c, d, T, !0);
  }, s.prototype.removeListener = function(c, d, T, b) {
    var h = n ? n + c : c;
    if (!this._events[h])
      return this;
    if (!d)
      return u(this, h), this;
    var f = this._events[h];
    if (f.fn)
      f.fn === d && (!b || f.once) && (!T || f.context === T) && u(this, h);
    else {
      for (var v = 0, E = [], j = f.length; v < j; v++)
        (f[v].fn !== d || b && !f[v].once || T && f[v].context !== T) && E.push(f[v]);
      E.length ? this._events[h] = E.length === 1 ? E[0] : E : u(this, h);
    }
    return this;
  }, s.prototype.removeAllListeners = function(c) {
    var d;
    return c ? (d = n ? n + c : c, this._events[d] && u(this, d)) : (this._events = new r(), this._eventsCount = 0), this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s;
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class Manipulator {
  constructor(t, n) {
    be(this, "currentListeners", []);
    be(this, "onRealtimeMessage", (t, n) => {
      n.payload.jointState && this.currentListeners.forEach((r) => {
        n.payload.jointState && r(n.payload.jointState);
      });
    });
    this.device = t, this.config = n;
  }
  async synchronize() {
    this.device.addRealtimeListener(this.onRealtimeMessage), this.device.startListeningToRealtimeDataStream(
      this.config.currentJointStateStream
    );
  }
  async desynchronize() {
    this.device.removeRealtimeListener(this.onRealtimeMessage), this.device.stopListeningToRealtimeDataStream(
      this.config.currentJointStateStream
    );
  }
  async addCurrentJointStateListener(t) {
    this.currentListeners.push(t);
  }
}
class RequestDataChannel {
  constructor(t, n, r) {
    be(this, "channel");
    be(this, "requestIdToResponseMap", /* @__PURE__ */ new Map());
    this.device = t, this.channel_name = n, this.timeout = r;
  }
  addOpenListener(t) {
    defined(this.channel, "channel not initalized").addOpenListener(t);
  }
  removeOpenListener(t) {
    defined(this.channel, "channel not initalized").removeOpenListener(
      t
    );
  }
  addCloseListener(t) {
    defined(this.channel, "channel not initalized").addCloseListener(t);
  }
  removeCloseListener(t) {
    defined(this.channel, "channel not initalized").removeCloseListener(
      t
    );
  }
  addErrorListener(t) {
    defined(this.channel, "channel not initalized").addErrorListener(t);
  }
  removeErrorListener(t) {
    defined(this.channel, "channel not initalized").removeErrorListener(
      t
    );
  }
}
class BinaryRequestDataChannel extends RequestDataChannel {
  constructor() {
    super(...arguments);
    be(this, "RESPONSE_SUCCESS_BYTE", 0);
    be(this, "decoder", new TextDecoder());
  }
  /*
      Request binary payload layout:
          16-bytes         arbitrary-length
      [     ID       ] [        PAYLOAD         ]
  
      Response binary payload layout:
              1-byte               16-bytes         arbitrary-length
      [ SUCCESS OR ERROR BYTE ] [     ID       ] [        PAYLOAD         ]
      */
  generateBinaryId() {
    const n = new Uint8Array(16);
    for (let r = 0; r < n.length; r++)
      n[r] = Math.floor(Math.random() * 256);
    return n;
  }
  async initialize() {
    this.channel = await this.device.createCustomDataChannel(this.channel_name), this.channel.addBinaryListener((n) => {
      const o = n.slice(0, 16).toString();
      if (o.length === 0)
        throw new Error("Invalid response");
      const l = n.slice(16);
      if (l.length === 0)
        throw new Error("Invalid response");
      this.requestIdToResponseMap.has(o) && this.requestIdToResponseMap.set(o, l);
    });
  }
  async request(n) {
    if (this.channel || await this.initialize(), !this.channel)
      throw new Error("Failed to create channel");
    const { channel: r, requestIdToResponseMap: o, timeout: l } = this;
    await r.waitTilReady();
    const u = this.generateBinaryId(), s = u.toString();
    o.set(s, !0), r.sendBinary(new Uint8Array([...u, ...n]));
    const g = (/* @__PURE__ */ new Date()).getTime();
    for (; (/* @__PURE__ */ new Date()).getTime() < g + l; )
      if (await delay(50), o.has(s)) {
        const c = o.get(s);
        if (c !== !0) {
          o.delete(s);
          const d = c[0] === this.RESPONSE_SUCCESS_BYTE, T = c.slice(1);
          if (d)
            return T;
          throw console.error({
            name: "AdapterError",
            message: this.decoder.decode(T)
          }), new Error("Binary request datachannel adapter error");
        }
      }
    throw o.delete(s), console.error({
      name: "TimeoutError",
      message: `Request timed out after ${l / 1e3} seconds`
    }), new Error("Binary request data channel request timed out");
  }
}
class TextRequestDataChannel extends RequestDataChannel {
  generateTextId() {
    return Math.random().toString(36).substring(2) + "-" + Math.random().toString(36).substring(2);
  }
  async initialize() {
    this.channel = await this.device.createCustomDataChannel(this.channel_name), this.channel.addListener((t) => {
      const n = JSON.parse(t), { id: r, data: o, error: l } = n;
      if (!r)
        throw new Error("Invalid response");
      if (!o && !l)
        throw new Error("Invalid response");
      this.requestIdToResponseMap.has(r) && this.requestIdToResponseMap.set(r, n);
    });
  }
  async request(t) {
    if (this.channel || await this.initialize(), !this.channel)
      throw new Error("Failed to create channel");
    const { channel: n, requestIdToResponseMap: r, timeout: o } = this;
    await n.waitTilReady();
    const l = this.generateTextId();
    r.set(l, !0), n.send(
      JSON.stringify({
        id: l,
        data: t
      })
    );
    const u = (/* @__PURE__ */ new Date()).getTime();
    for (; (/* @__PURE__ */ new Date()).getTime() < u + o; )
      if (await delay(50), r.has(l)) {
        const s = r.get(l);
        if (s !== !0) {
          r.delete(l);
          const { data: g, error: c } = s;
          if (g)
            return g;
          if (c)
            throw console.error({
              name: "AdapterError",
              message: c
            }), new Error("Text request datachannel adapter error");
        }
      }
    throw r.delete(l), console.error({
      name: "TimeoutError",
      message: `Request timed out after ${o / 1e3} seconds`
    }), new Error("Text request datachannel request timed out");
  }
}
class BaseDevice extends EventEmitter {
  constructor() {
    super(...arguments);
    be(this, "rtcClient");
    be(this, "remoteDevicePeerId", null);
    be(this, "realtimeListeners", []);
    be(this, "connectionMonitorInterval");
    be(this, "handleMessage", (n, r) => {
      this.realtimeListeners.forEach((o) => o(n, r));
    });
  }
  stopConnectionMonitoring() {
    clearInterval(this.connectionMonitorInterval), this.connectionMonitorInterval = void 0;
  }
  assertNotCancelled(n) {
    if (n)
      throw new Error("Cancelled by deadline");
  }
  getRealtimeStatus() {
    if (this.rtcClient && this.remoteDevicePeerId)
      return this.rtcClient.getConnectionStatus(this.remoteDevicePeerId);
    throw new Error("Realtime connection hasn't been started");
  }
  getRealtimePing() {
    if (this.rtcClient && this.remoteDevicePeerId)
      return this.rtcClient.getPing(this.remoteDevicePeerId);
    throw new Error("Realtime connection hasn't been started");
  }
  addRealtimeListener(n) {
    this.realtimeListeners.push(n);
  }
  removeRealtimeListener(n) {
    const r = this.realtimeListeners.indexOf(n);
    if (r === -1)
      throw new Error("Could not find realtime listener to remove");
    this.realtimeListeners.splice(r, 1);
  }
  async getRealtimeManipulators() {
    const n = await this.getConfiguration(), r = [];
    for (const o of n.teleop.rosStreams ?? [])
      o.topicType == "sensor_msgs/JointState" && r.push(
        new Manipulator(this, {
          currentJointStateStream: { name: o.topicName },
          plannedJointStateStream: o.plannedTopic ? { name: o.plannedTopic } : void 0,
          planValidStream: o.planValidTopic ? { name: o.planValidTopic } : void 0,
          endEffectorStream: o.endEffectorTopic ? { name: o.endEffectorTopic } : void 0,
          endEffectorLinkName: o.endEffectorLinkName,
          baseReferenceFrame: o.baseReferenceFrame,
          localFrame: o.localFrame
        })
      );
    return r;
  }
  async getRealtimeVideoStreams() {
    var o, l, u;
    const n = await this.getConfiguration(), r = [];
    for (const s of ((o = n.teleop) == null ? void 0 : o.hardwareStreams) ?? [])
      s.rtcStreamType === "h264-video-frame" && r.push({
        name: s.name
      });
    for (const s of ((l = n.teleop) == null ? void 0 : l.rosStreams) ?? [])
      s.topicType == "formant/H264VideoFrame" && r.push({
        name: s.topicName
      }), (s.topicType === "sensor_msgs/Image" || s.topicType === "sensor_msgs/CompressedImage") && s.encodeVideo && r.push({
        name: s.topicName
      });
    for (const s of ((u = n.teleop) == null ? void 0 : u.customStreams) ?? [])
      s.rtcStreamType === "h264-video-frame" && r.push({
        name: s.name
      });
    return r;
  }
  createCustomRequestDataChannel(n, r = 3e3) {
    return new TextRequestDataChannel(this, n, r);
  }
  createCustomBinaryRequestDataChannel(n, r = 3e3) {
    return new BinaryRequestDataChannel(this, n, r);
  }
  async startListeningToRealtimeVideo(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n.name,
      enable: !0,
      pipeline: "rtc"
    });
  }
  async stopListeningToRealtimeVideo(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n.name,
      enable: !1,
      pipeline: "rtc"
    });
  }
  async startListeningToRealtimeDataStream(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n.name,
      enable: !0,
      pipeline: "rtc"
    });
  }
  async stopListeningToRealtimeDataStream(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n.name,
      enable: !1,
      pipeline: "rtc"
    });
  }
  async enableRealtimeTelemetryPriorityIngestion(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n,
      enablePriorityUpload: !0,
      pipeline: "telemetry"
    });
  }
  async disableRealtimeTelemetryPriorityIngestion(n) {
    const r = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), o = await this.getRemotePeer();
    r.controlRemoteStream(defined(o).id, {
      streamName: n,
      enablePriorityUpload: !1,
      pipeline: "telemetry"
    });
  }
  async changeStreamAudioType(n, r) {
    const o = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), l = await this.getRemotePeer();
    o.controlRemoteStream(defined(l).id, {
      streamName: n,
      setAudioFormat: r
    });
  }
  async createCustomDataChannel(n, r) {
    const o = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), l = await this.getRemotePeer(), u = await new Promise((s) => {
      o.createCustomDataChannel(
        defined(l).id,
        n,
        {
          ordered: !0,
          ...r
        },
        !1,
        (g, c) => {
          const d = new DataChannel(c);
          s(d);
        }
      );
    });
    return await u.waitTilReady(), u;
  }
  async sendRealtimeMessage(n, r = {
    channelLabel: "stream.reliable"
  }) {
    const o = defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ), l = await this.getRemotePeer();
    o.send(defined(l).id, n, r);
  }
  async getRealtimeAudioStreams() {
    var o, l, u;
    const n = await this.getConfiguration(), r = [];
    for (const s of ((o = n.teleop) == null ? void 0 : o.hardwareStreams) ?? [])
      s.rtcStreamType === "audio-chunk" && r.push({
        name: s.name
      });
    for (const s of ((l = n.teleop) == null ? void 0 : l.rosStreams) ?? [])
      s.topicType == "audio_common_msgs/AudioData" && r.push({
        name: s.topicName
      });
    for (const s of ((u = n.teleop) == null ? void 0 : u.customStreams) ?? [])
      s.rtcStreamType === "audio-chunk" && r.push({
        name: s.name
      });
    return r;
  }
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4, Z_BINARY = 0, Z_TEXT = 1, Z_UNKNOWN$1 = 2;
function zero$1(e) {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}
const STORED_BLOCK = 0, STATIC_TREES = 1, DYN_TREES = 2, MIN_MATCH$1 = 3, MAX_MATCH$1 = 258, LENGTH_CODES$1 = 29, LITERALS$1 = 256, L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1, D_CODES$1 = 30, BL_CODES$1 = 19, HEAP_SIZE$1 = 2 * L_CODES$1 + 1, MAX_BITS$1 = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
), extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
), extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
), bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), DIST_CODE_LEN = 512, static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(e, t, n, r, o) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = n, this.elems = r, this.max_length = o, this.has_stree = e && e.length;
}
let static_l_desc, static_d_desc, static_bl_desc;
function TreeDesc(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
const d_code = (e) => e < 256 ? _dist_code[e] : _dist_code[256 + (e >>> 7)], put_short = (e, t) => {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}, send_bits = (e, t, n) => {
  e.bi_valid > Buf_size - n ? (e.bi_buf |= t << e.bi_valid & 65535, put_short(e, e.bi_buf), e.bi_buf = t >> Buf_size - e.bi_valid, e.bi_valid += n - Buf_size) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += n);
}, send_code = (e, t, n) => {
  send_bits(
    e,
    n[t * 2],
    n[t * 2 + 1]
    /*.Len*/
  );
}, bi_reverse = (e, t) => {
  let n = 0;
  do
    n |= e & 1, e >>>= 1, n <<= 1;
  while (--t > 0);
  return n >>> 1;
}, bi_flush = (e) => {
  e.bi_valid === 16 ? (put_short(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}, gen_bitlen = (e, t) => {
  const n = t.dyn_tree, r = t.max_code, o = t.stat_desc.static_tree, l = t.stat_desc.has_stree, u = t.stat_desc.extra_bits, s = t.stat_desc.extra_base, g = t.stat_desc.max_length;
  let c, d, T, b, h, f, v = 0;
  for (b = 0; b <= MAX_BITS$1; b++)
    e.bl_count[b] = 0;
  for (n[e.heap[e.heap_max] * 2 + 1] = 0, c = e.heap_max + 1; c < HEAP_SIZE$1; c++)
    d = e.heap[c], b = n[n[d * 2 + 1] * 2 + 1] + 1, b > g && (b = g, v++), n[d * 2 + 1] = b, !(d > r) && (e.bl_count[b]++, h = 0, d >= s && (h = u[d - s]), f = n[d * 2], e.opt_len += f * (b + h), l && (e.static_len += f * (o[d * 2 + 1] + h)));
  if (v !== 0) {
    do {
      for (b = g - 1; e.bl_count[b] === 0; )
        b--;
      e.bl_count[b]--, e.bl_count[b + 1] += 2, e.bl_count[g]--, v -= 2;
    } while (v > 0);
    for (b = g; b !== 0; b--)
      for (d = e.bl_count[b]; d !== 0; )
        T = e.heap[--c], !(T > r) && (n[T * 2 + 1] !== b && (e.opt_len += (b - n[T * 2 + 1]) * n[T * 2], n[T * 2 + 1] = b), d--);
  }
}, gen_codes = (e, t, n) => {
  const r = new Array(MAX_BITS$1 + 1);
  let o = 0, l, u;
  for (l = 1; l <= MAX_BITS$1; l++)
    o = o + n[l - 1] << 1, r[l] = o;
  for (u = 0; u <= t; u++) {
    let s = e[u * 2 + 1];
    s !== 0 && (e[u * 2] = bi_reverse(r[s]++, s));
  }
}, tr_static_init = () => {
  let e, t, n, r, o;
  const l = new Array(MAX_BITS$1 + 1);
  for (n = 0, r = 0; r < LENGTH_CODES$1 - 1; r++)
    for (base_length[r] = n, e = 0; e < 1 << extra_lbits[r]; e++)
      _length_code[n++] = r;
  for (_length_code[n - 1] = r, o = 0, r = 0; r < 16; r++)
    for (base_dist[r] = o, e = 0; e < 1 << extra_dbits[r]; e++)
      _dist_code[o++] = r;
  for (o >>= 7; r < D_CODES$1; r++)
    for (base_dist[r] = o << 7, e = 0; e < 1 << extra_dbits[r] - 7; e++)
      _dist_code[256 + o++] = r;
  for (t = 0; t <= MAX_BITS$1; t++)
    l[t] = 0;
  for (e = 0; e <= 143; )
    static_ltree[e * 2 + 1] = 8, e++, l[8]++;
  for (; e <= 255; )
    static_ltree[e * 2 + 1] = 9, e++, l[9]++;
  for (; e <= 279; )
    static_ltree[e * 2 + 1] = 7, e++, l[7]++;
  for (; e <= 287; )
    static_ltree[e * 2 + 1] = 8, e++, l[8]++;
  for (gen_codes(static_ltree, L_CODES$1 + 1, l), e = 0; e < D_CODES$1; e++)
    static_dtree[e * 2 + 1] = 5, static_dtree[e * 2] = bi_reverse(e, 5);
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}, init_block = (e) => {
  let t;
  for (t = 0; t < L_CODES$1; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < D_CODES$1; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < BL_CODES$1; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[END_BLOCK * 2] = 1, e.opt_len = e.static_len = 0, e.sym_next = e.matches = 0;
}, bi_windup = (e) => {
  e.bi_valid > 8 ? put_short(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}, smaller = (e, t, n, r) => {
  const o = t * 2, l = n * 2;
  return e[o] < e[l] || e[o] === e[l] && r[t] <= r[n];
}, pqdownheap = (e, t, n) => {
  const r = e.heap[n];
  let o = n << 1;
  for (; o <= e.heap_len && (o < e.heap_len && smaller(t, e.heap[o + 1], e.heap[o], e.depth) && o++, !smaller(t, r, e.heap[o], e.depth)); )
    e.heap[n] = e.heap[o], n = o, o <<= 1;
  e.heap[n] = r;
}, compress_block = (e, t, n) => {
  let r, o, l = 0, u, s;
  if (e.sym_next !== 0)
    do
      r = e.pending_buf[e.sym_buf + l++] & 255, r += (e.pending_buf[e.sym_buf + l++] & 255) << 8, o = e.pending_buf[e.sym_buf + l++], r === 0 ? send_code(e, o, t) : (u = _length_code[o], send_code(e, u + LITERALS$1 + 1, t), s = extra_lbits[u], s !== 0 && (o -= base_length[u], send_bits(e, o, s)), r--, u = d_code(r), send_code(e, u, n), s = extra_dbits[u], s !== 0 && (r -= base_dist[u], send_bits(e, r, s)));
    while (l < e.sym_next);
  send_code(e, END_BLOCK, t);
}, build_tree = (e, t) => {
  const n = t.dyn_tree, r = t.stat_desc.static_tree, o = t.stat_desc.has_stree, l = t.stat_desc.elems;
  let u, s, g = -1, c;
  for (e.heap_len = 0, e.heap_max = HEAP_SIZE$1, u = 0; u < l; u++)
    n[u * 2] !== 0 ? (e.heap[++e.heap_len] = g = u, e.depth[u] = 0) : n[u * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    c = e.heap[++e.heap_len] = g < 2 ? ++g : 0, n[c * 2] = 1, e.depth[c] = 0, e.opt_len--, o && (e.static_len -= r[c * 2 + 1]);
  for (t.max_code = g, u = e.heap_len >> 1; u >= 1; u--)
    pqdownheap(e, n, u);
  c = l;
  do
    u = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], pqdownheap(
      e,
      n,
      1
      /*SMALLEST*/
    ), s = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = u, e.heap[--e.heap_max] = s, n[c * 2] = n[u * 2] + n[s * 2], e.depth[c] = (e.depth[u] >= e.depth[s] ? e.depth[u] : e.depth[s]) + 1, n[u * 2 + 1] = n[s * 2 + 1] = c, e.heap[
      1
      /*SMALLEST*/
    ] = c++, pqdownheap(
      e,
      n,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], gen_bitlen(e, t), gen_codes(n, g, e.bl_count);
}, scan_tree = (e, t, n) => {
  let r, o = -1, l, u = t[0 * 2 + 1], s = 0, g = 7, c = 4;
  for (u === 0 && (g = 138, c = 3), t[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++)
    l = u, u = t[(r + 1) * 2 + 1], !(++s < g && l === u) && (s < c ? e.bl_tree[l * 2] += s : l !== 0 ? (l !== o && e.bl_tree[l * 2]++, e.bl_tree[REP_3_6 * 2]++) : s <= 10 ? e.bl_tree[REPZ_3_10 * 2]++ : e.bl_tree[REPZ_11_138 * 2]++, s = 0, o = l, u === 0 ? (g = 138, c = 3) : l === u ? (g = 6, c = 3) : (g = 7, c = 4));
}, send_tree = (e, t, n) => {
  let r, o = -1, l, u = t[0 * 2 + 1], s = 0, g = 7, c = 4;
  for (u === 0 && (g = 138, c = 3), r = 0; r <= n; r++)
    if (l = u, u = t[(r + 1) * 2 + 1], !(++s < g && l === u)) {
      if (s < c)
        do
          send_code(e, l, e.bl_tree);
        while (--s !== 0);
      else
        l !== 0 ? (l !== o && (send_code(e, l, e.bl_tree), s--), send_code(e, REP_3_6, e.bl_tree), send_bits(e, s - 3, 2)) : s <= 10 ? (send_code(e, REPZ_3_10, e.bl_tree), send_bits(e, s - 3, 3)) : (send_code(e, REPZ_11_138, e.bl_tree), send_bits(e, s - 11, 7));
      s = 0, o = l, u === 0 ? (g = 138, c = 3) : l === u ? (g = 6, c = 3) : (g = 7, c = 4);
    }
}, build_bl_tree = (e) => {
  let t;
  for (scan_tree(e, e.dyn_ltree, e.l_desc.max_code), scan_tree(e, e.dyn_dtree, e.d_desc.max_code), build_tree(e, e.bl_desc), t = BL_CODES$1 - 1; t >= 3 && e.bl_tree[bl_order[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}, send_all_trees = (e, t, n, r) => {
  let o;
  for (send_bits(e, t - 257, 5), send_bits(e, n - 1, 5), send_bits(e, r - 4, 4), o = 0; o < r; o++)
    send_bits(e, e.bl_tree[bl_order[o] * 2 + 1], 3);
  send_tree(e, e.dyn_ltree, t - 1), send_tree(e, e.dyn_dtree, n - 1);
}, detect_data_type = (e) => {
  let t = 4093624447, n;
  for (n = 0; n <= 31; n++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[n * 2] !== 0)
      return Z_BINARY;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Z_TEXT;
  for (n = 32; n < LITERALS$1; n++)
    if (e.dyn_ltree[n * 2] !== 0)
      return Z_TEXT;
  return Z_BINARY;
};
let static_init_done = !1;
const _tr_init$1 = (e) => {
  static_init_done || (tr_static_init(), static_init_done = !0), e.l_desc = new TreeDesc(e.dyn_ltree, static_l_desc), e.d_desc = new TreeDesc(e.dyn_dtree, static_d_desc), e.bl_desc = new TreeDesc(e.bl_tree, static_bl_desc), e.bi_buf = 0, e.bi_valid = 0, init_block(e);
}, _tr_stored_block$1 = (e, t, n, r) => {
  send_bits(e, (STORED_BLOCK << 1) + (r ? 1 : 0), 3), bi_windup(e), put_short(e, n), put_short(e, ~n), n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending), e.pending += n;
}, _tr_align$1 = (e) => {
  send_bits(e, STATIC_TREES << 1, 3), send_code(e, END_BLOCK, static_ltree), bi_flush(e);
}, _tr_flush_block$1 = (e, t, n, r) => {
  let o, l, u = 0;
  e.level > 0 ? (e.strm.data_type === Z_UNKNOWN$1 && (e.strm.data_type = detect_data_type(e)), build_tree(e, e.l_desc), build_tree(e, e.d_desc), u = build_bl_tree(e), o = e.opt_len + 3 + 7 >>> 3, l = e.static_len + 3 + 7 >>> 3, l <= o && (o = l)) : o = l = n + 5, n + 4 <= o && t !== -1 ? _tr_stored_block$1(e, t, n, r) : e.strategy === Z_FIXED$1 || l === o ? (send_bits(e, (STATIC_TREES << 1) + (r ? 1 : 0), 3), compress_block(e, static_ltree, static_dtree)) : (send_bits(e, (DYN_TREES << 1) + (r ? 1 : 0), 3), send_all_trees(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, u + 1), compress_block(e, e.dyn_ltree, e.dyn_dtree)), init_block(e), r && bi_windup(e);
}, _tr_tally$1 = (e, t, n) => (e.pending_buf[e.sym_buf + e.sym_next++] = t, e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8, e.pending_buf[e.sym_buf + e.sym_next++] = n, t === 0 ? e.dyn_ltree[n * 2]++ : (e.matches++, t--, e.dyn_ltree[(_length_code[n] + LITERALS$1 + 1) * 2]++, e.dyn_dtree[d_code(t) * 2]++), e.sym_next === e.sym_end);
var _tr_init_1 = _tr_init$1, _tr_stored_block_1 = _tr_stored_block$1, _tr_flush_block_1 = _tr_flush_block$1, _tr_tally_1 = _tr_tally$1, _tr_align_1 = _tr_align$1, trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (e, t, n, r) => {
  let o = e & 65535 | 0, l = e >>> 16 & 65535 | 0, u = 0;
  for (; n !== 0; ) {
    u = n > 2e3 ? 2e3 : n, n -= u;
    do
      o = o + t[r++] | 0, l = l + o | 0;
    while (--u);
    o %= 65521, l %= 65521;
  }
  return o | l << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let e, t = [];
  for (var n = 0; n < 256; n++) {
    e = n;
    for (var r = 0; r < 8; r++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[n] = e;
  }
  return t;
}, crcTable = new Uint32Array(makeTable()), crc32 = (e, t, n, r) => {
  const o = crcTable, l = r + n;
  e ^= -1;
  for (let u = r; u < l; u++)
    e = e >>> 8 ^ o[(e ^ t[u]) & 255];
  return e ^ -1;
};
var crc32_1 = crc32, messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees, {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2, MAX_MEM_LEVEL = 9, MAX_WBITS$1 = 15, DEF_MEM_LEVEL = 8, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, PRESET_DICT = 32, INIT_STATE = 42, GZIP_STATE = 57, EXTRA_STATE = 69, NAME_STATE = 73, COMMENT_STATE = 91, HCRC_STATE = 103, BUSY_STATE = 113, FINISH_STATE = 666, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4, OS_CODE = 3, err = (e, t) => (e.msg = messages[t], t), rank = (e) => e * 2 - (e > 4 ? 9 : 0), zero = (e) => {
  let t = e.length;
  for (; --t >= 0; )
    e[t] = 0;
}, slide_hash = (e) => {
  let t, n, r, o = e.w_size;
  t = e.hash_size, r = t;
  do
    n = e.head[--r], e.head[r] = n >= o ? n - o : 0;
  while (--t);
  t = o, r = t;
  do
    n = e.prev[--r], e.prev[r] = n >= o ? n - o : 0;
  while (--t);
};
let HASH_ZLIB = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask, HASH = HASH_ZLIB;
const flush_pending = (e) => {
  const t = e.state;
  let n = t.pending;
  n > e.avail_out && (n = e.avail_out), n !== 0 && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out), e.next_out += n, t.pending_out += n, e.total_out += n, e.avail_out -= n, t.pending -= n, t.pending === 0 && (t.pending_out = 0));
}, flush_block_only = (e, t) => {
  _tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, flush_pending(e.strm);
}, put_byte = (e, t) => {
  e.pending_buf[e.pending++] = t;
}, putShortMSB = (e, t) => {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}, read_buf = (e, t, n, r) => {
  let o = e.avail_in;
  return o > r && (o = r), o === 0 ? 0 : (e.avail_in -= o, t.set(e.input.subarray(e.next_in, e.next_in + o), n), e.state.wrap === 1 ? e.adler = adler32_1(e.adler, t, o, n) : e.state.wrap === 2 && (e.adler = crc32_1(e.adler, t, o, n)), e.next_in += o, e.total_in += o, o);
}, longest_match = (e, t) => {
  let n = e.max_chain_length, r = e.strstart, o, l, u = e.prev_length, s = e.nice_match;
  const g = e.strstart > e.w_size - MIN_LOOKAHEAD ? e.strstart - (e.w_size - MIN_LOOKAHEAD) : 0, c = e.window, d = e.w_mask, T = e.prev, b = e.strstart + MAX_MATCH;
  let h = c[r + u - 1], f = c[r + u];
  e.prev_length >= e.good_match && (n >>= 2), s > e.lookahead && (s = e.lookahead);
  do
    if (o = t, !(c[o + u] !== f || c[o + u - 1] !== h || c[o] !== c[r] || c[++o] !== c[r + 1])) {
      r += 2, o++;
      do
        ;
      while (c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && c[++r] === c[++o] && r < b);
      if (l = MAX_MATCH - (b - r), r = b - MAX_MATCH, l > u) {
        if (e.match_start = t, u = l, l >= s)
          break;
        h = c[r + u - 1], f = c[r + u];
      }
    }
  while ((t = T[t & d]) > g && --n !== 0);
  return u <= e.lookahead ? u : e.lookahead;
}, fill_window = (e) => {
  const t = e.w_size;
  let n, r, o;
  do {
    if (r = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - MIN_LOOKAHEAD) && (e.window.set(e.window.subarray(t, t + t - r), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, e.insert > e.strstart && (e.insert = e.strstart), slide_hash(e), r += t), e.strm.avail_in === 0)
      break;
    if (n = read_buf(e.strm, e.window, e.strstart + e.lookahead, r), e.lookahead += n, e.lookahead + e.insert >= MIN_MATCH)
      for (o = e.strstart - e.insert, e.ins_h = e.window[o], e.ins_h = HASH(e, e.ins_h, e.window[o + 1]); e.insert && (e.ins_h = HASH(e, e.ins_h, e.window[o + MIN_MATCH - 1]), e.prev[o & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = o, o++, e.insert--, !(e.lookahead + e.insert < MIN_MATCH)); )
        ;
  } while (e.lookahead < MIN_LOOKAHEAD && e.strm.avail_in !== 0);
}, deflate_stored = (e, t) => {
  let n = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, r, o, l, u = 0, s = e.strm.avail_in;
  do {
    if (r = 65535, l = e.bi_valid + 42 >> 3, e.strm.avail_out < l || (l = e.strm.avail_out - l, o = e.strstart - e.block_start, r > o + e.strm.avail_in && (r = o + e.strm.avail_in), r > l && (r = l), r < n && (r === 0 && t !== Z_FINISH$3 || t === Z_NO_FLUSH$2 || r !== o + e.strm.avail_in)))
      break;
    u = t === Z_FINISH$3 && r === o + e.strm.avail_in ? 1 : 0, _tr_stored_block(e, 0, 0, u), e.pending_buf[e.pending - 4] = r, e.pending_buf[e.pending - 3] = r >> 8, e.pending_buf[e.pending - 2] = ~r, e.pending_buf[e.pending - 1] = ~r >> 8, flush_pending(e.strm), o && (o > r && (o = r), e.strm.output.set(e.window.subarray(e.block_start, e.block_start + o), e.strm.next_out), e.strm.next_out += o, e.strm.avail_out -= o, e.strm.total_out += o, e.block_start += o, r -= o), r && (read_buf(e.strm, e.strm.output, e.strm.next_out, r), e.strm.next_out += r, e.strm.avail_out -= r, e.strm.total_out += r);
  } while (u === 0);
  return s -= e.strm.avail_in, s && (s >= e.w_size ? (e.matches = 2, e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0), e.strstart = e.w_size, e.insert = e.strstart) : (e.window_size - e.strstart <= s && (e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, e.insert > e.strstart && (e.insert = e.strstart)), e.window.set(e.strm.input.subarray(e.strm.next_in - s, e.strm.next_in), e.strstart), e.strstart += s, e.insert += s > e.w_size - e.insert ? e.w_size - e.insert : s), e.block_start = e.strstart), e.high_water < e.strstart && (e.high_water = e.strstart), u ? BS_FINISH_DONE : t !== Z_NO_FLUSH$2 && t !== Z_FINISH$3 && e.strm.avail_in === 0 && e.strstart === e.block_start ? BS_BLOCK_DONE : (l = e.window_size - e.strstart, e.strm.avail_in > l && e.block_start >= e.w_size && (e.block_start -= e.w_size, e.strstart -= e.w_size, e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0), e.matches < 2 && e.matches++, l += e.w_size, e.insert > e.strstart && (e.insert = e.strstart)), l > e.strm.avail_in && (l = e.strm.avail_in), l && (read_buf(e.strm, e.window, e.strstart, l), e.strstart += l, e.insert += l > e.w_size - e.insert ? e.w_size - e.insert : l), e.high_water < e.strstart && (e.high_water = e.strstart), l = e.bi_valid + 42 >> 3, l = e.pending_buf_size - l > 65535 ? 65535 : e.pending_buf_size - l, n = l > e.w_size ? e.w_size : l, o = e.strstart - e.block_start, (o >= n || (o || t === Z_FINISH$3) && t !== Z_NO_FLUSH$2 && e.strm.avail_in === 0 && o <= l) && (r = o > l ? l : o, u = t === Z_FINISH$3 && e.strm.avail_in === 0 && r === o ? 1 : 0, _tr_stored_block(e, e.block_start, r, u), e.block_start += r, flush_pending(e.strm)), u ? BS_FINISH_STARTED : BS_NEED_MORE);
}, deflate_fast = (e, t) => {
  let n, r;
  for (; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), n !== 0 && e.strstart - n <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, n)), e.match_length >= MIN_MATCH)
      if (r = _tr_tally(e, e.strstart - e.match_start, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= MIN_MATCH) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + 1]);
    else
      r = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (r && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_slow = (e, t) => {
  let n, r, o;
  for (; ; ) {
    if (e.lookahead < MIN_LOOKAHEAD) {
      if (fill_window(e), e.lookahead < MIN_LOOKAHEAD && t === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (n = 0, e.lookahead >= MIN_MATCH && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = MIN_MATCH - 1, n !== 0 && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - MIN_LOOKAHEAD && (e.match_length = longest_match(e, n), e.match_length <= 5 && (e.strategy === Z_FILTERED || e.match_length === MIN_MATCH && e.strstart - e.match_start > 4096) && (e.match_length = MIN_MATCH - 1)), e.prev_length >= MIN_MATCH && e.match_length <= e.prev_length) {
      o = e.strstart + e.lookahead - MIN_MATCH, r = _tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - MIN_MATCH), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= o && (e.ins_h = HASH(e, e.ins_h, e.window[e.strstart + MIN_MATCH - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = MIN_MATCH - 1, e.strstart++, r && (flush_block_only(e, !1), e.strm.avail_out === 0))
        return BS_NEED_MORE;
    } else if (e.match_available) {
      if (r = _tr_tally(e, 0, e.window[e.strstart - 1]), r && flush_block_only(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return BS_NEED_MORE;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (r = _tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < MIN_MATCH - 1 ? e.strstart : MIN_MATCH - 1, t === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_rle = (e, t) => {
  let n, r, o, l;
  const u = e.window;
  for (; ; ) {
    if (e.lookahead <= MAX_MATCH) {
      if (fill_window(e), e.lookahead <= MAX_MATCH && t === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= MIN_MATCH && e.strstart > 0 && (o = e.strstart - 1, r = u[o], r === u[++o] && r === u[++o] && r === u[++o])) {
      l = e.strstart + MAX_MATCH;
      do
        ;
      while (r === u[++o] && r === u[++o] && r === u[++o] && r === u[++o] && r === u[++o] && r === u[++o] && r === u[++o] && r === u[++o] && o < l);
      e.match_length = MAX_MATCH - (l - o), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= MIN_MATCH ? (n = _tr_tally(e, 1, e.match_length - MIN_MATCH), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (n = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), n && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = 0, t === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
}, deflate_huff = (e, t) => {
  let n;
  for (; ; ) {
    if (e.lookahead === 0 && (fill_window(e), e.lookahead === 0)) {
      if (t === Z_NO_FLUSH$2)
        return BS_NEED_MORE;
      break;
    }
    if (e.match_length = 0, n = _tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, n && (flush_block_only(e, !1), e.strm.avail_out === 0))
      return BS_NEED_MORE;
  }
  return e.insert = 0, t === Z_FINISH$3 ? (flush_block_only(e, !0), e.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE) : e.sym_next && (flush_block_only(e, !1), e.strm.avail_out === 0) ? BS_NEED_MORE : BS_BLOCK_DONE;
};
function Config(e, t, n, r, o) {
  this.good_length = e, this.max_lazy = t, this.nice_length = n, this.max_chain = r, this.func = o;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
], lm_init = (e) => {
  e.window_size = 2 * e.w_size, zero(e.head), e.max_lazy_match = configuration_table[e.level].max_lazy, e.good_match = configuration_table[e.level].good_length, e.nice_match = configuration_table[e.level].nice_length, e.max_chain_length = configuration_table[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = MIN_MATCH - 1, e.match_available = 0, e.ins_h = 0;
};
function DeflateState() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED$2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2), this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2), this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(MAX_BITS + 1), this.heap = new Uint16Array(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * L_CODES + 1), zero(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const deflateStateCheck = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.status !== INIT_STATE && //#ifdef GZIP
  t.status !== GZIP_STATE && //#endif
  t.status !== EXTRA_STATE && t.status !== NAME_STATE && t.status !== COMMENT_STATE && t.status !== HCRC_STATE && t.status !== BUSY_STATE && t.status !== FINISH_STATE ? 1 : 0;
}, deflateResetKeep = (e) => {
  if (deflateStateCheck(e))
    return err(e, Z_STREAM_ERROR$2);
  e.total_in = e.total_out = 0, e.data_type = Z_UNKNOWN;
  const t = e.state;
  return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = //#ifdef GZIP
  t.wrap === 2 ? GZIP_STATE : (
    //#endif
    t.wrap ? INIT_STATE : BUSY_STATE
  ), e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = -2, _tr_init(t), Z_OK$3;
}, deflateReset = (e) => {
  const t = deflateResetKeep(e);
  return t === Z_OK$3 && lm_init(e.state), t;
}, deflateSetHeader = (e, t) => deflateStateCheck(e) || e.state.wrap !== 2 ? Z_STREAM_ERROR$2 : (e.state.gzhead = t, Z_OK$3), deflateInit2 = (e, t, n, r, o, l) => {
  if (!e)
    return Z_STREAM_ERROR$2;
  let u = 1;
  if (t === Z_DEFAULT_COMPRESSION$1 && (t = 6), r < 0 ? (u = 0, r = -r) : r > 15 && (u = 2, r -= 16), o < 1 || o > MAX_MEM_LEVEL || n !== Z_DEFLATED$2 || r < 8 || r > 15 || t < 0 || t > 9 || l < 0 || l > Z_FIXED || r === 8 && u !== 1)
    return err(e, Z_STREAM_ERROR$2);
  r === 8 && (r = 9);
  const s = new DeflateState();
  return e.state = s, s.strm = e, s.status = INIT_STATE, s.wrap = u, s.gzhead = null, s.w_bits = r, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = o + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s.window = new Uint8Array(s.w_size * 2), s.head = new Uint16Array(s.hash_size), s.prev = new Uint16Array(s.w_size), s.lit_bufsize = 1 << o + 6, s.pending_buf_size = s.lit_bufsize * 4, s.pending_buf = new Uint8Array(s.pending_buf_size), s.sym_buf = s.lit_bufsize, s.sym_end = (s.lit_bufsize - 1) * 3, s.level = t, s.strategy = l, s.method = n, deflateReset(e);
}, deflateInit = (e, t) => deflateInit2(e, t, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1), deflate$2 = (e, t) => {
  if (deflateStateCheck(e) || t > Z_BLOCK$1 || t < 0)
    return e ? err(e, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  const n = e.state;
  if (!e.output || e.avail_in !== 0 && !e.input || n.status === FINISH_STATE && t !== Z_FINISH$3)
    return err(e, e.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  const r = n.last_flush;
  if (n.last_flush = t, n.pending !== 0) {
    if (flush_pending(e), e.avail_out === 0)
      return n.last_flush = -1, Z_OK$3;
  } else if (e.avail_in === 0 && rank(t) <= rank(r) && t !== Z_FINISH$3)
    return err(e, Z_BUF_ERROR$1);
  if (n.status === FINISH_STATE && e.avail_in !== 0)
    return err(e, Z_BUF_ERROR$1);
  if (n.status === INIT_STATE && n.wrap === 0 && (n.status = BUSY_STATE), n.status === INIT_STATE) {
    let o = Z_DEFLATED$2 + (n.w_bits - 8 << 4) << 8, l = -1;
    if (n.strategy >= Z_HUFFMAN_ONLY || n.level < 2 ? l = 0 : n.level < 6 ? l = 1 : n.level === 6 ? l = 2 : l = 3, o |= l << 6, n.strstart !== 0 && (o |= PRESET_DICT), o += 31 - o % 31, putShortMSB(n, o), n.strstart !== 0 && (putShortMSB(n, e.adler >>> 16), putShortMSB(n, e.adler & 65535)), e.adler = 1, n.status = BUSY_STATE, flush_pending(e), n.pending !== 0)
      return n.last_flush = -1, Z_OK$3;
  }
  if (n.status === GZIP_STATE) {
    if (e.adler = 0, put_byte(n, 31), put_byte(n, 139), put_byte(n, 8), n.gzhead)
      put_byte(
        n,
        (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)
      ), put_byte(n, n.gzhead.time & 255), put_byte(n, n.gzhead.time >> 8 & 255), put_byte(n, n.gzhead.time >> 16 & 255), put_byte(n, n.gzhead.time >> 24 & 255), put_byte(n, n.level === 9 ? 2 : n.strategy >= Z_HUFFMAN_ONLY || n.level < 2 ? 4 : 0), put_byte(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (put_byte(n, n.gzhead.extra.length & 255), put_byte(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = EXTRA_STATE;
    else if (put_byte(n, 0), put_byte(n, 0), put_byte(n, 0), put_byte(n, 0), put_byte(n, 0), put_byte(n, n.level === 9 ? 2 : n.strategy >= Z_HUFFMAN_ONLY || n.level < 2 ? 4 : 0), put_byte(n, OS_CODE), n.status = BUSY_STATE, flush_pending(e), n.pending !== 0)
      return n.last_flush = -1, Z_OK$3;
  }
  if (n.status === EXTRA_STATE) {
    if (n.gzhead.extra) {
      let o = n.pending, l = (n.gzhead.extra.length & 65535) - n.gzindex;
      for (; n.pending + l > n.pending_buf_size; ) {
        let s = n.pending_buf_size - n.pending;
        if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + s), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o)), n.gzindex += s, flush_pending(e), n.pending !== 0)
          return n.last_flush = -1, Z_OK$3;
        o = 0, l -= s;
      }
      let u = new Uint8Array(n.gzhead.extra);
      n.pending_buf.set(u.subarray(n.gzindex, n.gzindex + l), n.pending), n.pending += l, n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o)), n.gzindex = 0;
    }
    n.status = NAME_STATE;
  }
  if (n.status === NAME_STATE) {
    if (n.gzhead.name) {
      let o = n.pending, l;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o)), flush_pending(e), n.pending !== 0)
            return n.last_flush = -1, Z_OK$3;
          o = 0;
        }
        n.gzindex < n.gzhead.name.length ? l = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : l = 0, put_byte(n, l);
      } while (l !== 0);
      n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o)), n.gzindex = 0;
    }
    n.status = COMMENT_STATE;
  }
  if (n.status === COMMENT_STATE) {
    if (n.gzhead.comment) {
      let o = n.pending, l;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o)), flush_pending(e), n.pending !== 0)
            return n.last_flush = -1, Z_OK$3;
          o = 0;
        }
        n.gzindex < n.gzhead.comment.length ? l = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : l = 0, put_byte(n, l);
      } while (l !== 0);
      n.gzhead.hcrc && n.pending > o && (e.adler = crc32_1(e.adler, n.pending_buf, n.pending - o, o));
    }
    n.status = HCRC_STATE;
  }
  if (n.status === HCRC_STATE) {
    if (n.gzhead.hcrc) {
      if (n.pending + 2 > n.pending_buf_size && (flush_pending(e), n.pending !== 0))
        return n.last_flush = -1, Z_OK$3;
      put_byte(n, e.adler & 255), put_byte(n, e.adler >> 8 & 255), e.adler = 0;
    }
    if (n.status = BUSY_STATE, flush_pending(e), n.pending !== 0)
      return n.last_flush = -1, Z_OK$3;
  }
  if (e.avail_in !== 0 || n.lookahead !== 0 || t !== Z_NO_FLUSH$2 && n.status !== FINISH_STATE) {
    let o = n.level === 0 ? deflate_stored(n, t) : n.strategy === Z_HUFFMAN_ONLY ? deflate_huff(n, t) : n.strategy === Z_RLE ? deflate_rle(n, t) : configuration_table[n.level].func(n, t);
    if ((o === BS_FINISH_STARTED || o === BS_FINISH_DONE) && (n.status = FINISH_STATE), o === BS_NEED_MORE || o === BS_FINISH_STARTED)
      return e.avail_out === 0 && (n.last_flush = -1), Z_OK$3;
    if (o === BS_BLOCK_DONE && (t === Z_PARTIAL_FLUSH ? _tr_align(n) : t !== Z_BLOCK$1 && (_tr_stored_block(n, 0, 0, !1), t === Z_FULL_FLUSH$1 && (zero(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), flush_pending(e), e.avail_out === 0))
      return n.last_flush = -1, Z_OK$3;
  }
  return t !== Z_FINISH$3 ? Z_OK$3 : n.wrap <= 0 ? Z_STREAM_END$3 : (n.wrap === 2 ? (put_byte(n, e.adler & 255), put_byte(n, e.adler >> 8 & 255), put_byte(n, e.adler >> 16 & 255), put_byte(n, e.adler >> 24 & 255), put_byte(n, e.total_in & 255), put_byte(n, e.total_in >> 8 & 255), put_byte(n, e.total_in >> 16 & 255), put_byte(n, e.total_in >> 24 & 255)) : (putShortMSB(n, e.adler >>> 16), putShortMSB(n, e.adler & 65535)), flush_pending(e), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3);
}, deflateEnd = (e) => {
  if (deflateStateCheck(e))
    return Z_STREAM_ERROR$2;
  const t = e.state.status;
  return e.state = null, t === BUSY_STATE ? err(e, Z_DATA_ERROR$2) : Z_OK$3;
}, deflateSetDictionary = (e, t) => {
  let n = t.length;
  if (deflateStateCheck(e))
    return Z_STREAM_ERROR$2;
  const r = e.state, o = r.wrap;
  if (o === 2 || o === 1 && r.status !== INIT_STATE || r.lookahead)
    return Z_STREAM_ERROR$2;
  if (o === 1 && (e.adler = adler32_1(e.adler, t, n, 0)), r.wrap = 0, n >= r.w_size) {
    o === 0 && (zero(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
    let g = new Uint8Array(r.w_size);
    g.set(t.subarray(n - r.w_size, n), 0), t = g, n = r.w_size;
  }
  const l = e.avail_in, u = e.next_in, s = e.input;
  for (e.avail_in = n, e.next_in = 0, e.input = t, fill_window(r); r.lookahead >= MIN_MATCH; ) {
    let g = r.strstart, c = r.lookahead - (MIN_MATCH - 1);
    do
      r.ins_h = HASH(r, r.ins_h, r.window[g + MIN_MATCH - 1]), r.prev[g & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = g, g++;
    while (--c);
    r.strstart = g, r.lookahead = MIN_MATCH - 1, fill_window(r);
  }
  return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = MIN_MATCH - 1, r.match_available = 0, e.next_in = u, e.input = s, e.avail_in = l, r.wrap = o, Z_OK$3;
};
var deflateInit_1 = deflateInit, deflateInit2_1 = deflateInit2, deflateReset_1 = deflateReset, deflateResetKeep_1 = deflateResetKeep, deflateSetHeader_1 = deflateSetHeader, deflate_2$1 = deflate$2, deflateEnd_1 = deflateEnd, deflateSetDictionary_1 = deflateSetDictionary, deflateInfo = "pako deflate (from Nodeca project)", deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var assign = function(e) {
  const t = Array.prototype.slice.call(arguments, 1);
  for (; t.length; ) {
    const n = t.shift();
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be non-object");
      for (const r in n)
        _has(n, r) && (e[r] = n[r]);
    }
  }
  return e;
}, flattenChunks = (e) => {
  let t = 0;
  for (let r = 0, o = e.length; r < o; r++)
    t += e[r].length;
  const n = new Uint8Array(t);
  for (let r = 0, o = 0, l = e.length; r < l; r++) {
    let u = e[r];
    n.set(u, o), o += u.length;
  }
  return n;
}, common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = !0;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (e) {
  STR_APPLY_UIA_OK = !1;
}
const _utf8len = new Uint8Array(256);
for (let e = 0; e < 256; e++)
  _utf8len[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (e) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
    return new TextEncoder().encode(e);
  let t, n, r, o, l, u = e.length, s = 0;
  for (o = 0; o < u; o++)
    n = e.charCodeAt(o), (n & 64512) === 55296 && o + 1 < u && (r = e.charCodeAt(o + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), o++)), s += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (t = new Uint8Array(s), l = 0, o = 0; l < s; o++)
    n = e.charCodeAt(o), (n & 64512) === 55296 && o + 1 < u && (r = e.charCodeAt(o + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), o++)), n < 128 ? t[l++] = n : n < 2048 ? (t[l++] = 192 | n >>> 6, t[l++] = 128 | n & 63) : n < 65536 ? (t[l++] = 224 | n >>> 12, t[l++] = 128 | n >>> 6 & 63, t[l++] = 128 | n & 63) : (t[l++] = 240 | n >>> 18, t[l++] = 128 | n >>> 12 & 63, t[l++] = 128 | n >>> 6 & 63, t[l++] = 128 | n & 63);
  return t;
};
const buf2binstring = (e, t) => {
  if (t < 65534 && e.subarray && STR_APPLY_UIA_OK)
    return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
  let n = "";
  for (let r = 0; r < t; r++)
    n += String.fromCharCode(e[r]);
  return n;
};
var buf2string = (e, t) => {
  const n = t || e.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
    return new TextDecoder().decode(e.subarray(0, t));
  let r, o;
  const l = new Array(n * 2);
  for (o = 0, r = 0; r < n; ) {
    let u = e[r++];
    if (u < 128) {
      l[o++] = u;
      continue;
    }
    let s = _utf8len[u];
    if (s > 4) {
      l[o++] = 65533, r += s - 1;
      continue;
    }
    for (u &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && r < n; )
      u = u << 6 | e[r++] & 63, s--;
    if (s > 1) {
      l[o++] = 65533;
      continue;
    }
    u < 65536 ? l[o++] = u : (u -= 65536, l[o++] = 55296 | u >> 10 & 1023, l[o++] = 56320 | u & 1023);
  }
  return buf2binstring(l, o);
}, utf8border = (e, t) => {
  t = t || e.length, t > e.length && (t = e.length);
  let n = t - 1;
  for (; n >= 0 && (e[n] & 192) === 128; )
    n--;
  return n < 0 || n === 0 ? t : n + _utf8len[e[n]] > t ? n : t;
}, strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString, {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(e) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, e || {});
  let t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream(), this.strm.avail_out = 0;
  let n = deflate_1$2.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (n !== Z_OK$2)
    throw new Error(messages[n]);
  if (t.header && deflate_1$2.deflateSetHeader(this.strm, t.header), t.dictionary) {
    let r;
    if (typeof t.dictionary == "string" ? r = strings.string2buf(t.dictionary) : toString$1.call(t.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(t.dictionary) : r = t.dictionary, n = deflate_1$2.deflateSetDictionary(this.strm, r), n !== Z_OK$2)
      throw new Error(messages[n]);
    this._dict_set = !0;
  }
}
Deflate$1.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize;
  let o, l;
  if (this.ended)
    return !1;
  for (t === ~~t ? l = t : l = t === !0 ? Z_FINISH$2 : Z_NO_FLUSH$1, typeof e == "string" ? n.input = strings.string2buf(e) : toString$1.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    if (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (l === Z_SYNC_FLUSH || l === Z_FULL_FLUSH) && n.avail_out <= 6) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (o = deflate_1$2.deflate(n, l), o === Z_STREAM_END$2)
      return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), o = deflate_1$2.deflateEnd(this.strm), this.onEnd(o), this.ended = !0, o === Z_OK$2;
    if (n.avail_out === 0) {
      this.onData(n.output);
      continue;
    }
    if (l > 0 && n.next_out > 0) {
      this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      continue;
    }
    if (n.avail_in === 0)
      break;
  }
  return !0;
};
Deflate$1.prototype.onData = function(e) {
  this.chunks.push(e);
};
Deflate$1.prototype.onEnd = function(e) {
  e === Z_OK$2 && (this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function deflate$1(e, t) {
  const n = new Deflate$1(t);
  if (n.push(e, !0), n.err)
    throw n.msg || messages[n.err];
  return n.result;
}
function deflateRaw$1(e, t) {
  return t = t || {}, t.raw = !0, deflate$1(e, t);
}
function gzip$1(e, t) {
  return t = t || {}, t.gzip = !0, deflate$1(e, t);
}
var Deflate_1$1 = Deflate$1, deflate_2 = deflate$1, deflateRaw_1$1 = deflateRaw$1, gzip_1$1 = gzip$1, constants$1 = constants$2, deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
const BAD$1 = 16209, TYPE$1 = 16191;
var inffast = function e(t, n) {
  let r, o, l, u, s, g, c, d, T, b, h, f, v, E, j, B, I, R, p, M, $, Z, _, y;
  const C = t.state;
  r = t.next_in, _ = t.input, o = r + (t.avail_in - 5), l = t.next_out, y = t.output, u = l - (n - t.avail_out), s = l + (t.avail_out - 257), g = C.dmax, c = C.wsize, d = C.whave, T = C.wnext, b = C.window, h = C.hold, f = C.bits, v = C.lencode, E = C.distcode, j = (1 << C.lenbits) - 1, B = (1 << C.distbits) - 1;
  e:
    do {
      f < 15 && (h += _[r++] << f, f += 8, h += _[r++] << f, f += 8), I = v[h & j];
      t:
        for (; ; ) {
          if (R = I >>> 24, h >>>= R, f -= R, R = I >>> 16 & 255, R === 0)
            y[l++] = I & 65535;
          else if (R & 16) {
            p = I & 65535, R &= 15, R && (f < R && (h += _[r++] << f, f += 8), p += h & (1 << R) - 1, h >>>= R, f -= R), f < 15 && (h += _[r++] << f, f += 8, h += _[r++] << f, f += 8), I = E[h & B];
            n:
              for (; ; ) {
                if (R = I >>> 24, h >>>= R, f -= R, R = I >>> 16 & 255, R & 16) {
                  if (M = I & 65535, R &= 15, f < R && (h += _[r++] << f, f += 8, f < R && (h += _[r++] << f, f += 8)), M += h & (1 << R) - 1, M > g) {
                    t.msg = "invalid distance too far back", C.mode = BAD$1;
                    break e;
                  }
                  if (h >>>= R, f -= R, R = l - u, M > R) {
                    if (R = M - R, R > d && C.sane) {
                      t.msg = "invalid distance too far back", C.mode = BAD$1;
                      break e;
                    }
                    if ($ = 0, Z = b, T === 0) {
                      if ($ += c - R, R < p) {
                        p -= R;
                        do
                          y[l++] = b[$++];
                        while (--R);
                        $ = l - M, Z = y;
                      }
                    } else if (T < R) {
                      if ($ += c + T - R, R -= T, R < p) {
                        p -= R;
                        do
                          y[l++] = b[$++];
                        while (--R);
                        if ($ = 0, T < p) {
                          R = T, p -= R;
                          do
                            y[l++] = b[$++];
                          while (--R);
                          $ = l - M, Z = y;
                        }
                      }
                    } else if ($ += T - R, R < p) {
                      p -= R;
                      do
                        y[l++] = b[$++];
                      while (--R);
                      $ = l - M, Z = y;
                    }
                    for (; p > 2; )
                      y[l++] = Z[$++], y[l++] = Z[$++], y[l++] = Z[$++], p -= 3;
                    p && (y[l++] = Z[$++], p > 1 && (y[l++] = Z[$++]));
                  } else {
                    $ = l - M;
                    do
                      y[l++] = y[$++], y[l++] = y[$++], y[l++] = y[$++], p -= 3;
                    while (p > 2);
                    p && (y[l++] = y[$++], p > 1 && (y[l++] = y[$++]));
                  }
                } else if (R & 64) {
                  t.msg = "invalid distance code", C.mode = BAD$1;
                  break e;
                } else {
                  I = E[(I & 65535) + (h & (1 << R) - 1)];
                  continue n;
                }
                break;
              }
          } else if (R & 64)
            if (R & 32) {
              C.mode = TYPE$1;
              break e;
            } else {
              t.msg = "invalid literal/length code", C.mode = BAD$1;
              break e;
            }
          else {
            I = v[(I & 65535) + (h & (1 << R) - 1)];
            continue t;
          }
          break;
        }
    } while (r < o && l < s);
  p = f >> 3, r -= p, f -= p << 3, h &= (1 << f) - 1, t.next_in = r, t.next_out = l, t.avail_in = r < o ? 5 + (o - r) : 5 - (r - o), t.avail_out = l < s ? 257 + (s - l) : 257 - (l - s), C.hold = h, C.bits = f;
};
const MAXBITS = 15, ENOUGH_LENS$1 = 852, ENOUGH_DISTS$1 = 592, CODES$1 = 0, LENS$1 = 1, DISTS$1 = 2, lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]), lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]), dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]), dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]), inflate_table = (e, t, n, r, o, l, u, s) => {
  const g = s.bits;
  let c = 0, d = 0, T = 0, b = 0, h = 0, f = 0, v = 0, E = 0, j = 0, B = 0, I, R, p, M, $, Z = null, _;
  const y = new Uint16Array(MAXBITS + 1), C = new Uint16Array(MAXBITS + 1);
  let w = null, x, H, L;
  for (c = 0; c <= MAXBITS; c++)
    y[c] = 0;
  for (d = 0; d < r; d++)
    y[t[n + d]]++;
  for (h = g, b = MAXBITS; b >= 1 && y[b] === 0; b--)
    ;
  if (h > b && (h = b), b === 0)
    return o[l++] = 1 << 24 | 64 << 16 | 0, o[l++] = 1 << 24 | 64 << 16 | 0, s.bits = 1, 0;
  for (T = 1; T < b && y[T] === 0; T++)
    ;
  for (h < T && (h = T), E = 1, c = 1; c <= MAXBITS; c++)
    if (E <<= 1, E -= y[c], E < 0)
      return -1;
  if (E > 0 && (e === CODES$1 || b !== 1))
    return -1;
  for (C[1] = 0, c = 1; c < MAXBITS; c++)
    C[c + 1] = C[c] + y[c];
  for (d = 0; d < r; d++)
    t[n + d] !== 0 && (u[C[t[n + d]]++] = d);
  if (e === CODES$1 ? (Z = w = u, _ = 20) : e === LENS$1 ? (Z = lbase, w = lext, _ = 257) : (Z = dbase, w = dext, _ = 0), B = 0, d = 0, c = T, $ = l, f = h, v = 0, p = -1, j = 1 << h, M = j - 1, e === LENS$1 && j > ENOUGH_LENS$1 || e === DISTS$1 && j > ENOUGH_DISTS$1)
    return 1;
  for (; ; ) {
    x = c - v, u[d] + 1 < _ ? (H = 0, L = u[d]) : u[d] >= _ ? (H = w[u[d] - _], L = Z[u[d] - _]) : (H = 32 + 64, L = 0), I = 1 << c - v, R = 1 << f, T = R;
    do
      R -= I, o[$ + (B >> v) + R] = x << 24 | H << 16 | L | 0;
    while (R !== 0);
    for (I = 1 << c - 1; B & I; )
      I >>= 1;
    if (I !== 0 ? (B &= I - 1, B += I) : B = 0, d++, --y[c] === 0) {
      if (c === b)
        break;
      c = t[n + u[d]];
    }
    if (c > h && (B & M) !== p) {
      for (v === 0 && (v = h), $ += T, f = c - v, E = 1 << f; f + v < b && (E -= y[f + v], !(E <= 0)); )
        f++, E <<= 1;
      if (j += 1 << f, e === LENS$1 && j > ENOUGH_LENS$1 || e === DISTS$1 && j > ENOUGH_DISTS$1)
        return 1;
      p = B & M, o[p] = h << 24 | f << 16 | $ - l | 0;
    }
  }
  return B !== 0 && (o[$ + B] = c - v << 24 | 64 << 16 | 0), s.bits = h, 0;
};
var inftrees = inflate_table;
const CODES = 0, LENS = 1, DISTS = 2, {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2, HEAD = 16180, FLAGS = 16181, TIME = 16182, OS = 16183, EXLEN = 16184, EXTRA = 16185, NAME = 16186, COMMENT = 16187, HCRC = 16188, DICTID = 16189, DICT = 16190, TYPE = 16191, TYPEDO = 16192, STORED = 16193, COPY_ = 16194, COPY = 16195, TABLE = 16196, LENLENS = 16197, CODELENS = 16198, LEN_ = 16199, LEN = 16200, LENEXT = 16201, DIST = 16202, DISTEXT = 16203, MATCH = 16204, LIT = 16205, CHECK = 16206, LENGTH = 16207, DONE = 16208, BAD = 16209, MEM = 16210, SYNC = 16211, ENOUGH_LENS = 852, ENOUGH_DISTS = 592, MAX_WBITS = 15, DEF_WBITS = MAX_WBITS, zswap32 = (e) => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
function InflateState() {
  this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const inflateStateCheck = (e) => {
  if (!e)
    return 1;
  const t = e.state;
  return !t || t.strm !== e || t.mode < HEAD || t.mode > SYNC ? 1 : 0;
}, inflateResetKeep = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const t = e.state;
  return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = HEAD, t.last = 0, t.havedict = 0, t.flags = -1, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(ENOUGH_LENS), t.distcode = t.distdyn = new Int32Array(ENOUGH_DISTS), t.sane = 1, t.back = -1, Z_OK$1;
}, inflateReset = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const t = e.state;
  return t.wsize = 0, t.whave = 0, t.wnext = 0, inflateResetKeep(e);
}, inflateReset2 = (e, t) => {
  let n;
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const r = e.state;
  return t < 0 ? (n = 0, t = -t) : (n = (t >> 4) + 5, t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Z_STREAM_ERROR$1 : (r.window !== null && r.wbits !== t && (r.window = null), r.wrap = n, r.wbits = t, inflateReset(e));
}, inflateInit2 = (e, t) => {
  if (!e)
    return Z_STREAM_ERROR$1;
  const n = new InflateState();
  e.state = n, n.strm = e, n.window = null, n.mode = HEAD;
  const r = inflateReset2(e, t);
  return r !== Z_OK$1 && (e.state = null), r;
}, inflateInit = (e) => inflateInit2(e, DEF_WBITS);
let virgin = !0, lenfix, distfix;
const fixedtables = (e) => {
  if (virgin) {
    lenfix = new Int32Array(512), distfix = new Int32Array(32);
    let t = 0;
    for (; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (inftrees(LENS, e.lens, 0, 288, lenfix, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    inftrees(DISTS, e.lens, 0, 32, distfix, 0, e.work, { bits: 5 }), virgin = !1;
  }
  e.lencode = lenfix, e.lenbits = 9, e.distcode = distfix, e.distbits = 5;
}, updatewindow = (e, t, n, r) => {
  let o;
  const l = e.state;
  return l.window === null && (l.wsize = 1 << l.wbits, l.wnext = 0, l.whave = 0, l.window = new Uint8Array(l.wsize)), r >= l.wsize ? (l.window.set(t.subarray(n - l.wsize, n), 0), l.wnext = 0, l.whave = l.wsize) : (o = l.wsize - l.wnext, o > r && (o = r), l.window.set(t.subarray(n - r, n - r + o), l.wnext), r -= o, r ? (l.window.set(t.subarray(n - r, n), 0), l.wnext = r, l.whave = l.wsize) : (l.wnext += o, l.wnext === l.wsize && (l.wnext = 0), l.whave < l.wsize && (l.whave += o))), 0;
}, inflate$2 = (e, t) => {
  let n, r, o, l, u, s, g, c, d, T, b, h, f, v, E = 0, j, B, I, R, p, M, $, Z;
  const _ = new Uint8Array(4);
  let y, C;
  const w = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(e) || !e.output || !e.input && e.avail_in !== 0)
    return Z_STREAM_ERROR$1;
  n = e.state, n.mode === TYPE && (n.mode = TYPEDO), u = e.next_out, o = e.output, g = e.avail_out, l = e.next_in, r = e.input, s = e.avail_in, c = n.hold, d = n.bits, T = s, b = g, Z = Z_OK$1;
  e:
    for (; ; )
      switch (n.mode) {
        case HEAD:
          if (n.wrap === 0) {
            n.mode = TYPEDO;
            break;
          }
          for (; d < 16; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if (n.wrap & 2 && c === 35615) {
            n.wbits === 0 && (n.wbits = 15), n.check = 0, _[0] = c & 255, _[1] = c >>> 8 & 255, n.check = crc32_1(n.check, _, 2, 0), c = 0, d = 0, n.mode = FLAGS;
            break;
          }
          if (n.head && (n.head.done = !1), !(n.wrap & 1) || /* check if zlib header allowed */
          (((c & 255) << 8) + (c >> 8)) % 31) {
            e.msg = "incorrect header check", n.mode = BAD;
            break;
          }
          if ((c & 15) !== Z_DEFLATED) {
            e.msg = "unknown compression method", n.mode = BAD;
            break;
          }
          if (c >>>= 4, d -= 4, $ = (c & 15) + 8, n.wbits === 0 && (n.wbits = $), $ > 15 || $ > n.wbits) {
            e.msg = "invalid window size", n.mode = BAD;
            break;
          }
          n.dmax = 1 << n.wbits, n.flags = 0, e.adler = n.check = 1, n.mode = c & 512 ? DICTID : TYPE, c = 0, d = 0;
          break;
        case FLAGS:
          for (; d < 16; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if (n.flags = c, (n.flags & 255) !== Z_DEFLATED) {
            e.msg = "unknown compression method", n.mode = BAD;
            break;
          }
          if (n.flags & 57344) {
            e.msg = "unknown header flags set", n.mode = BAD;
            break;
          }
          n.head && (n.head.text = c >> 8 & 1), n.flags & 512 && n.wrap & 4 && (_[0] = c & 255, _[1] = c >>> 8 & 255, n.check = crc32_1(n.check, _, 2, 0)), c = 0, d = 0, n.mode = TIME;
        case TIME:
          for (; d < 32; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          n.head && (n.head.time = c), n.flags & 512 && n.wrap & 4 && (_[0] = c & 255, _[1] = c >>> 8 & 255, _[2] = c >>> 16 & 255, _[3] = c >>> 24 & 255, n.check = crc32_1(n.check, _, 4, 0)), c = 0, d = 0, n.mode = OS;
        case OS:
          for (; d < 16; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          n.head && (n.head.xflags = c & 255, n.head.os = c >> 8), n.flags & 512 && n.wrap & 4 && (_[0] = c & 255, _[1] = c >>> 8 & 255, n.check = crc32_1(n.check, _, 2, 0)), c = 0, d = 0, n.mode = EXLEN;
        case EXLEN:
          if (n.flags & 1024) {
            for (; d < 16; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            n.length = c, n.head && (n.head.extra_len = c), n.flags & 512 && n.wrap & 4 && (_[0] = c & 255, _[1] = c >>> 8 & 255, n.check = crc32_1(n.check, _, 2, 0)), c = 0, d = 0;
          } else
            n.head && (n.head.extra = null);
          n.mode = EXTRA;
        case EXTRA:
          if (n.flags & 1024 && (h = n.length, h > s && (h = s), h && (n.head && ($ = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(
            r.subarray(
              l,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              l + h
            ),
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            $
          )), n.flags & 512 && n.wrap & 4 && (n.check = crc32_1(n.check, r, h, l)), s -= h, l += h, n.length -= h), n.length))
            break e;
          n.length = 0, n.mode = NAME;
        case NAME:
          if (n.flags & 2048) {
            if (s === 0)
              break e;
            h = 0;
            do
              $ = r[l + h++], n.head && $ && n.length < 65536 && (n.head.name += String.fromCharCode($));
            while ($ && h < s);
            if (n.flags & 512 && n.wrap & 4 && (n.check = crc32_1(n.check, r, h, l)), s -= h, l += h, $)
              break e;
          } else
            n.head && (n.head.name = null);
          n.length = 0, n.mode = COMMENT;
        case COMMENT:
          if (n.flags & 4096) {
            if (s === 0)
              break e;
            h = 0;
            do
              $ = r[l + h++], n.head && $ && n.length < 65536 && (n.head.comment += String.fromCharCode($));
            while ($ && h < s);
            if (n.flags & 512 && n.wrap & 4 && (n.check = crc32_1(n.check, r, h, l)), s -= h, l += h, $)
              break e;
          } else
            n.head && (n.head.comment = null);
          n.mode = HCRC;
        case HCRC:
          if (n.flags & 512) {
            for (; d < 16; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            if (n.wrap & 4 && c !== (n.check & 65535)) {
              e.msg = "header crc mismatch", n.mode = BAD;
              break;
            }
            c = 0, d = 0;
          }
          n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), e.adler = n.check = 0, n.mode = TYPE;
          break;
        case DICTID:
          for (; d < 32; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          e.adler = n.check = zswap32(c), c = 0, d = 0, n.mode = DICT;
        case DICT:
          if (n.havedict === 0)
            return e.next_out = u, e.avail_out = g, e.next_in = l, e.avail_in = s, n.hold = c, n.bits = d, Z_NEED_DICT$1;
          e.adler = n.check = 1, n.mode = TYPE;
        case TYPE:
          if (t === Z_BLOCK || t === Z_TREES)
            break e;
        case TYPEDO:
          if (n.last) {
            c >>>= d & 7, d -= d & 7, n.mode = CHECK;
            break;
          }
          for (; d < 3; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          switch (n.last = c & 1, c >>>= 1, d -= 1, c & 3) {
            case 0:
              n.mode = STORED;
              break;
            case 1:
              if (fixedtables(n), n.mode = LEN_, t === Z_TREES) {
                c >>>= 2, d -= 2;
                break e;
              }
              break;
            case 2:
              n.mode = TABLE;
              break;
            case 3:
              e.msg = "invalid block type", n.mode = BAD;
          }
          c >>>= 2, d -= 2;
          break;
        case STORED:
          for (c >>>= d & 7, d -= d & 7; d < 32; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if ((c & 65535) !== (c >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", n.mode = BAD;
            break;
          }
          if (n.length = c & 65535, c = 0, d = 0, n.mode = COPY_, t === Z_TREES)
            break e;
        case COPY_:
          n.mode = COPY;
        case COPY:
          if (h = n.length, h) {
            if (h > s && (h = s), h > g && (h = g), h === 0)
              break e;
            o.set(r.subarray(l, l + h), u), s -= h, l += h, g -= h, u += h, n.length -= h;
            break;
          }
          n.mode = TYPE;
          break;
        case TABLE:
          for (; d < 14; ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if (n.nlen = (c & 31) + 257, c >>>= 5, d -= 5, n.ndist = (c & 31) + 1, c >>>= 5, d -= 5, n.ncode = (c & 15) + 4, c >>>= 4, d -= 4, n.nlen > 286 || n.ndist > 30) {
            e.msg = "too many length or distance symbols", n.mode = BAD;
            break;
          }
          n.have = 0, n.mode = LENLENS;
        case LENLENS:
          for (; n.have < n.ncode; ) {
            for (; d < 3; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            n.lens[w[n.have++]] = c & 7, c >>>= 3, d -= 3;
          }
          for (; n.have < 19; )
            n.lens[w[n.have++]] = 0;
          if (n.lencode = n.lendyn, n.lenbits = 7, y = { bits: n.lenbits }, Z = inftrees(CODES, n.lens, 0, 19, n.lencode, 0, n.work, y), n.lenbits = y.bits, Z) {
            e.msg = "invalid code lengths set", n.mode = BAD;
            break;
          }
          n.have = 0, n.mode = CODELENS;
        case CODELENS:
          for (; n.have < n.nlen + n.ndist; ) {
            for (; E = n.lencode[c & (1 << n.lenbits) - 1], j = E >>> 24, B = E >>> 16 & 255, I = E & 65535, !(j <= d); ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            if (I < 16)
              c >>>= j, d -= j, n.lens[n.have++] = I;
            else {
              if (I === 16) {
                for (C = j + 2; d < C; ) {
                  if (s === 0)
                    break e;
                  s--, c += r[l++] << d, d += 8;
                }
                if (c >>>= j, d -= j, n.have === 0) {
                  e.msg = "invalid bit length repeat", n.mode = BAD;
                  break;
                }
                $ = n.lens[n.have - 1], h = 3 + (c & 3), c >>>= 2, d -= 2;
              } else if (I === 17) {
                for (C = j + 3; d < C; ) {
                  if (s === 0)
                    break e;
                  s--, c += r[l++] << d, d += 8;
                }
                c >>>= j, d -= j, $ = 0, h = 3 + (c & 7), c >>>= 3, d -= 3;
              } else {
                for (C = j + 7; d < C; ) {
                  if (s === 0)
                    break e;
                  s--, c += r[l++] << d, d += 8;
                }
                c >>>= j, d -= j, $ = 0, h = 11 + (c & 127), c >>>= 7, d -= 7;
              }
              if (n.have + h > n.nlen + n.ndist) {
                e.msg = "invalid bit length repeat", n.mode = BAD;
                break;
              }
              for (; h--; )
                n.lens[n.have++] = $;
            }
          }
          if (n.mode === BAD)
            break;
          if (n.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", n.mode = BAD;
            break;
          }
          if (n.lenbits = 9, y = { bits: n.lenbits }, Z = inftrees(LENS, n.lens, 0, n.nlen, n.lencode, 0, n.work, y), n.lenbits = y.bits, Z) {
            e.msg = "invalid literal/lengths set", n.mode = BAD;
            break;
          }
          if (n.distbits = 6, n.distcode = n.distdyn, y = { bits: n.distbits }, Z = inftrees(DISTS, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, y), n.distbits = y.bits, Z) {
            e.msg = "invalid distances set", n.mode = BAD;
            break;
          }
          if (n.mode = LEN_, t === Z_TREES)
            break e;
        case LEN_:
          n.mode = LEN;
        case LEN:
          if (s >= 6 && g >= 258) {
            e.next_out = u, e.avail_out = g, e.next_in = l, e.avail_in = s, n.hold = c, n.bits = d, inffast(e, b), u = e.next_out, o = e.output, g = e.avail_out, l = e.next_in, r = e.input, s = e.avail_in, c = n.hold, d = n.bits, n.mode === TYPE && (n.back = -1);
            break;
          }
          for (n.back = 0; E = n.lencode[c & (1 << n.lenbits) - 1], j = E >>> 24, B = E >>> 16 & 255, I = E & 65535, !(j <= d); ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if (B && !(B & 240)) {
            for (R = j, p = B, M = I; E = n.lencode[M + ((c & (1 << R + p) - 1) >> R)], j = E >>> 24, B = E >>> 16 & 255, I = E & 65535, !(R + j <= d); ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            c >>>= R, d -= R, n.back += R;
          }
          if (c >>>= j, d -= j, n.back += j, n.length = I, B === 0) {
            n.mode = LIT;
            break;
          }
          if (B & 32) {
            n.back = -1, n.mode = TYPE;
            break;
          }
          if (B & 64) {
            e.msg = "invalid literal/length code", n.mode = BAD;
            break;
          }
          n.extra = B & 15, n.mode = LENEXT;
        case LENEXT:
          if (n.extra) {
            for (C = n.extra; d < C; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            n.length += c & (1 << n.extra) - 1, c >>>= n.extra, d -= n.extra, n.back += n.extra;
          }
          n.was = n.length, n.mode = DIST;
        case DIST:
          for (; E = n.distcode[c & (1 << n.distbits) - 1], j = E >>> 24, B = E >>> 16 & 255, I = E & 65535, !(j <= d); ) {
            if (s === 0)
              break e;
            s--, c += r[l++] << d, d += 8;
          }
          if (!(B & 240)) {
            for (R = j, p = B, M = I; E = n.distcode[M + ((c & (1 << R + p) - 1) >> R)], j = E >>> 24, B = E >>> 16 & 255, I = E & 65535, !(R + j <= d); ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            c >>>= R, d -= R, n.back += R;
          }
          if (c >>>= j, d -= j, n.back += j, B & 64) {
            e.msg = "invalid distance code", n.mode = BAD;
            break;
          }
          n.offset = I, n.extra = B & 15, n.mode = DISTEXT;
        case DISTEXT:
          if (n.extra) {
            for (C = n.extra; d < C; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            n.offset += c & (1 << n.extra) - 1, c >>>= n.extra, d -= n.extra, n.back += n.extra;
          }
          if (n.offset > n.dmax) {
            e.msg = "invalid distance too far back", n.mode = BAD;
            break;
          }
          n.mode = MATCH;
        case MATCH:
          if (g === 0)
            break e;
          if (h = b - g, n.offset > h) {
            if (h = n.offset - h, h > n.whave && n.sane) {
              e.msg = "invalid distance too far back", n.mode = BAD;
              break;
            }
            h > n.wnext ? (h -= n.wnext, f = n.wsize - h) : f = n.wnext - h, h > n.length && (h = n.length), v = n.window;
          } else
            v = o, f = u - n.offset, h = n.length;
          h > g && (h = g), g -= h, n.length -= h;
          do
            o[u++] = v[f++];
          while (--h);
          n.length === 0 && (n.mode = LEN);
          break;
        case LIT:
          if (g === 0)
            break e;
          o[u++] = n.length, g--, n.mode = LEN;
          break;
        case CHECK:
          if (n.wrap) {
            for (; d < 32; ) {
              if (s === 0)
                break e;
              s--, c |= r[l++] << d, d += 8;
            }
            if (b -= g, e.total_out += b, n.total += b, n.wrap & 4 && b && (e.adler = n.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
            n.flags ? crc32_1(n.check, o, b, u - b) : adler32_1(n.check, o, b, u - b)), b = g, n.wrap & 4 && (n.flags ? c : zswap32(c)) !== n.check) {
              e.msg = "incorrect data check", n.mode = BAD;
              break;
            }
            c = 0, d = 0;
          }
          n.mode = LENGTH;
        case LENGTH:
          if (n.wrap && n.flags) {
            for (; d < 32; ) {
              if (s === 0)
                break e;
              s--, c += r[l++] << d, d += 8;
            }
            if (n.wrap & 4 && c !== (n.total & 4294967295)) {
              e.msg = "incorrect length check", n.mode = BAD;
              break;
            }
            c = 0, d = 0;
          }
          n.mode = DONE;
        case DONE:
          Z = Z_STREAM_END$1;
          break e;
        case BAD:
          Z = Z_DATA_ERROR$1;
          break e;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
  return e.next_out = u, e.avail_out = g, e.next_in = l, e.avail_in = s, n.hold = c, n.bits = d, (n.wsize || b !== e.avail_out && n.mode < BAD && (n.mode < CHECK || t !== Z_FINISH$1)) && updatewindow(e, e.output, e.next_out, b - e.avail_out), T -= e.avail_in, b -= e.avail_out, e.total_in += T, e.total_out += b, n.total += b, n.wrap & 4 && b && (e.adler = n.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
  n.flags ? crc32_1(n.check, o, b, e.next_out - b) : adler32_1(n.check, o, b, e.next_out - b)), e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === TYPE ? 128 : 0) + (n.mode === LEN_ || n.mode === COPY_ ? 256 : 0), (T === 0 && b === 0 || t === Z_FINISH$1) && Z === Z_OK$1 && (Z = Z_BUF_ERROR), Z;
}, inflateEnd = (e) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  let t = e.state;
  return t.window && (t.window = null), e.state = null, Z_OK$1;
}, inflateGetHeader = (e, t) => {
  if (inflateStateCheck(e))
    return Z_STREAM_ERROR$1;
  const n = e.state;
  return n.wrap & 2 ? (n.head = t, t.done = !1, Z_OK$1) : Z_STREAM_ERROR$1;
}, inflateSetDictionary = (e, t) => {
  const n = t.length;
  let r, o, l;
  return inflateStateCheck(e) || (r = e.state, r.wrap !== 0 && r.mode !== DICT) ? Z_STREAM_ERROR$1 : r.mode === DICT && (o = 1, o = adler32_1(o, t, n, 0), o !== r.check) ? Z_DATA_ERROR$1 : (l = updatewindow(e, t, n, n), l ? (r.mode = MEM, Z_MEM_ERROR$1) : (r.havedict = 1, Z_OK$1));
};
var inflateReset_1 = inflateReset, inflateReset2_1 = inflateReset2, inflateResetKeep_1 = inflateResetKeep, inflateInit_1 = inflateInit, inflateInit2_1 = inflateInit2, inflate_2$1 = inflate$2, inflateEnd_1 = inflateEnd, inflateGetHeader_1 = inflateGetHeader, inflateSetDictionary_1 = inflateSetDictionary, inflateInfo = "pako inflate (from Nodeca project)", inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var gzheader = GZheader;
const toString = Object.prototype.toString, {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(e) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, e || {});
  const t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new zstream(), this.strm.avail_out = 0;
  let n = inflate_1$2.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (n !== Z_OK)
    throw new Error(messages[n]);
  if (this.header = new gzheader(), inflate_1$2.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = strings.string2buf(t.dictionary) : toString.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (n = inflate_1$2.inflateSetDictionary(this.strm, t.dictionary), n !== Z_OK)))
    throw new Error(messages[n]);
}
Inflate$1.prototype.push = function(e, t) {
  const n = this.strm, r = this.options.chunkSize, o = this.options.dictionary;
  let l, u, s;
  if (this.ended)
    return !1;
  for (t === ~~t ? u = t : u = t === !0 ? Z_FINISH : Z_NO_FLUSH, toString.call(e) === "[object ArrayBuffer]" ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    for (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), l = inflate_1$2.inflate(n, u), l === Z_NEED_DICT && o && (l = inflate_1$2.inflateSetDictionary(n, o), l === Z_OK ? l = inflate_1$2.inflate(n, u) : l === Z_DATA_ERROR && (l = Z_NEED_DICT)); n.avail_in > 0 && l === Z_STREAM_END && n.state.wrap > 0 && e[n.next_in] !== 0; )
      inflate_1$2.inflateReset(n), l = inflate_1$2.inflate(n, u);
    switch (l) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        return this.onEnd(l), this.ended = !0, !1;
    }
    if (s = n.avail_out, n.next_out && (n.avail_out === 0 || l === Z_STREAM_END))
      if (this.options.to === "string") {
        let g = strings.utf8border(n.output, n.next_out), c = n.next_out - g, d = strings.buf2string(n.output, g);
        n.next_out = c, n.avail_out = r - c, c && n.output.set(n.output.subarray(g, g + c), 0), this.onData(d);
      } else
        this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
    if (!(l === Z_OK && s === 0)) {
      if (l === Z_STREAM_END)
        return l = inflate_1$2.inflateEnd(this.strm), this.onEnd(l), this.ended = !0, !0;
      if (n.avail_in === 0)
        break;
    }
  }
  return !0;
};
Inflate$1.prototype.onData = function(e) {
  this.chunks.push(e);
};
Inflate$1.prototype.onEnd = function(e) {
  e === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var deflate_1 = deflate, fromByteArray_1 = fromByteArray, lookup = [], code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i];
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, n) {
  for (var r, o = [], l = t; l < n; l += 3)
    r = (e[l] << 16 & 16711680) + (e[l + 1] << 8 & 65280) + (e[l + 2] & 255), o.push(tripletToBase64(r));
  return o.join("");
}
function fromByteArray(e) {
  for (var t, n = e.length, r = n % 3, o = [], l = 16383, u = 0, s = n - r; u < s; u += l)
    o.push(encodeChunk(e, u, u + l > s ? s : u + l));
  return r === 1 ? (t = e[n - 1], o.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], o.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), o.join("");
}
const encoder = new TextEncoder();
new TextDecoder();
function serializeHash(e) {
  const t = JSON.stringify(e), n = encoder.encode(t), r = deflate_1(n);
  return fromByteArray_1(r);
}
async function getViews() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/views`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function createShareLink(e, t) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const r = (await getViews()).filter((s) => s.name === t);
  if (r.length === 0)
    return console.warn("View does not exist or it is misspell"), null;
  const o = await fetch(`${FORMANT_API_URL}/v1/admin/shares`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  }), l = FORMANT_API_URL.replace("api", "app"), { code: u } = await o.json();
  return `${l}/shares/${u}#${serializeHash({
    viewId: r[0].id
  })}`;
}
const vailableAggregationIntervals = [
  "day",
  "week",
  "month",
  "year",
  "hour",
  "minute",
  "quarter"
], aggregateFunctions = [
  "interval",
  "start",
  "end",
  "sub",
  "get"
];
function getVariance(e) {
  return e.count < 2 ? 0 : e.sumOfSquares / (e.count - 1);
}
function getStandardDeviation(e) {
  return Math.sqrt(getVariance(e));
}
function getMax(e) {
  return e.max;
}
function getMin(e) {
  return e.min;
}
function getAverage(e) {
  return e.count === 0 ? -1 : e.sum / e.count;
}
function getSum(e) {
  return e.sum;
}
function getCount(e) {
  return e.count;
}
const aggregateFunctionMap = {
  min: getMin,
  max: getMax,
  "standard deviation": getStandardDeviation,
  average: getAverage,
  sum: getSum,
  count: getCount
}, aggregateByDateFunctions = {
  day: {
    interval: eachDayOfInterval,
    start: startOfDay,
    end: endOfDay,
    sub: subDays,
    get: getDay
  },
  week: {
    interval: eachWeekOfInterval,
    start: startOfWeek,
    end: endOfWeek,
    sub: subWeeks,
    get: getWeek
  },
  month: {
    interval: eachMonthOfInterval,
    start: startOfMonth,
    end: endOfMonth,
    sub: subMonths,
    get: getMonth
  },
  year: {
    interval: eachYearOfInterval,
    start: startOfYear,
    end: endOfYear,
    sub: subYears,
    get: getYear
  },
  hour: {
    interval: eachHourOfInterval,
    start: startOfHour,
    end: endOfHour,
    sub: subHours,
    get: getHours
  },
  minute: {
    interval: eachMinuteOfInterval,
    start: startOfMinute,
    end: endOfMinute,
    sub: subMinutes,
    get: getMinutes
  },
  quarter: {
    interval: eachQuarterOfInterval,
    start: startOfQuarter,
    end: endOfQuarter,
    sub: subQuarters,
    get: getQuarter
  }
}, formatTimeFrameText = (e, t) => (
  // FIXME this doesn't work for *a lot* locales, other than en-US
  // en-GB: 'dd/mm/YYYY'
  // ja-jp: 'YYYY/mm/dd'
  // bg-BG: 'dd.mm.YYYY'
  e.split("/")[0] + "/" + e.split("/")[1] + "–" + t.split("/")[0] + "/" + t.split("/")[1]
);
async function queryEvents(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/events/query`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function eventsCounter(e, t, n, r, o) {
  const l = aggregateByDateFunctions[t];
  return await Promise.all(
    Array(n).fill(0).map(async (u, s) => {
      const g = new Date(r), c = l.sub(
        l.start(g),
        n - s - 1
      ), d = l.sub(
        l.end(g),
        n - s - 1
      ), T = formatTimeFrameText(
        c.toLocaleDateString(),
        d.toLocaleDateString()
      ), b = await queryEvents({
        ...o,
        eventTypes: e,
        start: new Date(c).toISOString(),
        end: new Date(d).toISOString()
      });
      return { date: T, events: b };
    })
  );
}
async function getAnnotationCount(e, t) {
  return (await queryEvents({
    ...e,
    eventTypes: ["annotation"]
  })).filter(
    (l) => !!l.tags && Object.keys(l.tags).includes(t)
  ).reduce((l, u) => {
    const s = u.tags[t];
    return s in l ? (l[s] += 1, l) : (l[s] = 1, l);
  }, {});
}
async function getAnnotationCountByIntervals(e, t, n) {
  const { end: r, start: o } = e, u = aggregateByDateFunctions[n].interval({
    start: new Date(o),
    end: new Date(r)
  }), s = u.map((c, d) => {
    const T = new Date(c).toISOString(), b = d === u.length - 1 ? new Date(Date.now()).toISOString() : new Date(u[d + 1]);
    return getAnnotationCount(
      {
        ...e,
        start: T,
        end: b
      },
      t
    );
  }), g = await Promise.all(s);
  return u.map((c, d) => ({
    date: new Date(c).toISOString(),
    annotations: g[d]
  }));
}
async function getTelemetry(e, t, n, r, o) {
  let l = e;
  Array.isArray(e) || (l = [e]);
  let u = t;
  return Array.isArray(t) || (u = [t]), (await (await fetch(`${FORMANT_API_URL}/v1/queries/queries`, {
    method: "POST",
    body: JSON.stringify({
      deviceIds: l,
      end: r.toISOString(),
      names: u,
      start: n.toISOString(),
      tags: o
    }),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function getRealtimeSessions() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const e = defaultRtcClientPool.get();
  try {
    return await e.getSessions();
  } finally {
    await e.shutdown();
  }
}
async function getPeers() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const e = defaultRtcClientPool.get();
  try {
    return await e.getPeers();
  } finally {
    await e.shutdown();
  }
}
async function createDevice(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/devices`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function patchDevice(e, t) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/devices/${e}`, {
    method: "PATCH",
    body: JSON.stringify(t),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function getDevicesData() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/device-details/query`, {
    method: "POST",
    body: JSON.stringify({ enabled: !0, type: "default" }),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function queryDevicesData(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/devices/query`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
class Device extends BaseDevice {
  constructor(t, n, r, o) {
    super(), this.id = t, this.name = n, this.organizationId = r, this.tags = o;
  }
  async getLatestTelemetry() {
    return (await (await fetch(
      `${FORMANT_API_URL}/v1/queries/stream-current-value`,
      {
        method: "POST",
        body: JSON.stringify({
          deviceIds: [this.id]
        }),
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json()).items;
  }
  async getConfiguration() {
    let t = await fetch(`${FORMANT_API_URL}/v1/admin/devices/${this.id}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
    const n = await t.json();
    if (!n.state.reportedConfiguration)
      throw new Error(
        "Device has no configuration, has it ever been turned on?"
      );
    const r = n.state.reportedConfiguration.version;
    return t = await fetch(
      `${FORMANT_API_URL}/v1/admin/devices/${this.id}/configurations/${r}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    ), (await t.json()).document;
  }
  async getFileUrl(t) {
    return (await (await fetch(`${FORMANT_API_URL}/v1/admin/files/query`, {
      method: "POST",
      body: JSON.stringify({
        fileIds: [t]
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json()).fileUrls;
  }
  /**
   * Starts a real-time connection with the remote device using WebRTC.
   * @param {number} [options] - Optional session type to be used for the connection.
   * @throws `Error`  If the connection could not be established or if a connection already exists.
   * @returns {void}
   */
  async startRealtimeConnection(t = {}) {
    if (console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} :: Connection start requested`), this.rtcClient && this.connectionMonitorInterval !== void 0)
      throw new Error(
        `Already created realtime connection to device ${this.id}`
      );
    this.rtcClient && console.warn(
      "overwriting existing rtcClient due to missing connectionMonitorInterval"
    );
    const {
      sessionType: n,
      deadlineMs: r = 1e4,
      maxConnectRetries: o = 3
    } = typeof t == "number" ? { sessionType: t } : t, u = getRtcClientPool({
      sessionType: n
    }).get(this.handleMessage);
    let s = !1;
    const g = new Promise(
      (d, T) => setTimeout(() => {
        s = !0, T(
          new Error(
            "Connection timed out: the connection could not be finalized in time, possibly due to network issues or misconfigured settings."
          )
        );
      }, r)
    ), c = async () => {
      if ("isReady" in u)
        for (; !u.isReady(); )
          this.assertNotCancelled(s), await delay(100);
      const d = await this.getRemoteDevicePeerId(u);
      this.assertNotCancelled(s);
      let T;
      for (let h = 0; h < o && (T = await u.connect(d), !T); h++)
        delay(100), this.assertNotCancelled(s);
      if (!T)
        throw new Error(
          `Session could not be created: exhausted ${o} retries`
        );
      let b = 0;
      for (; !s && u.getConnectionStatus(d) !== "connected"; )
        await delay(100), b += 1;
      return this.assertNotCancelled(s), console.debug(
        `${(/* @__PURE__ */ new Date()).toISOString()} :: Connection completed after ${b} retries`
      ), d;
    };
    return Promise.race([c(), g]).then((d) => {
      this.remoteDevicePeerId = d, this.initConnectionMonitoring(), this.rtcClient = u, this.emit("connect");
    }).catch((d) => {
      throw console.debug(
        `${(/* @__PURE__ */ new Date()).toISOString()} :: Connection failed: %o`,
        d
      ), this.remoteDevicePeerId = null, u.shutdown().catch((T) => {
        console.error("rtcClient cannot shutdown: %o", T);
      }), this.emit("connection_failed", d), d;
    });
  }
  async getRemoteDevicePeerId(t) {
    const r = (await t.getPeers()).find((o) => o.deviceId === this.id);
    if (!isRtcPeer(r))
      throw new Error("Cannot find peer, is the robot offline?");
    return r.id;
  }
  initConnectionMonitoring() {
    this.connectionMonitorInterval = setInterval(async () => {
      let t = !1;
      if (this.rtcClient) {
        const r = this.rtcClient.getConnections().find(
          (o) => o.getRemotePeerId() === this.remoteDevicePeerId && o.isActive()
        );
        (r === void 0 || !r.isReady()) && (console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} :: data channel closed`), t = !0);
      }
      (!this.rtcClient || !this.remoteDevicePeerId || await this.rtcClient.getConnectionStatsInfo(
        this.remoteDevicePeerId
      ) === void 0 || t) && (this.emit("disconnect"), this.stopRealtimeConnection().catch((n) => {
        console.error(n);
      }));
    }, 1e3);
  }
  async getRemotePeer() {
    const n = (await defined(
      this.rtcClient,
      "Realtime connection has not been started"
    ).getPeers()).find((r) => r.deviceId === this.id);
    return defined(
      n,
      "Could not find remote peer for device " + this.id
    );
  }
  async stopRealtimeConnection() {
    let t = !1;
    if (this.rtcClient) {
      this.stopConnectionMonitoring(), this.remoteDevicePeerId ? (await this.rtcClient.disconnect(this.remoteDevicePeerId), this.remoteDevicePeerId = null) : t = !0;
      try {
        await this.rtcClient.shutdown();
      } finally {
        this.rtcClient = void 0;
      }
    }
    if (t)
      throw new Error(`Realtime connection hasn't been started for ${this.id}`);
  }
  async isInRealtimeSession() {
    const t = await getPeers(), n = await getRealtimeSessions(), r = t.find((o) => o.deviceId === this.id);
    return r ? n[r.id].length > 0 : !1;
  }
  async getAvailableCommands() {
    return (await (await fetch(
      `${FORMANT_API_URL}/v1/admin/command-templates/`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json()).items.map((r) => ({
      name: r.name,
      id: r.id,
      command: r.command,
      description: r.description,
      parameterEnabled: r.parameterEnabled,
      parameterValue: r.parameterValue,
      parameterMeta: r.parameterMeta,
      enabled: r.enabled,
      tags: r.tags
    }));
  }
  async sendCommand(t, n, r, o) {
    var d;
    const u = (await this.getAvailableCommands()).find((T) => T.name === t);
    if (!u)
      throw new Error(`Could not find command with name "${t}"`);
    let s = "";
    n === void 0 ? u.parameterEnabled && u.parameterValue && (s = u.parameterValue) : s = n;
    let g = {
      value: s,
      scrubberTime: (r || /* @__PURE__ */ new Date()).toISOString(),
      meta: {
        ...u.parameterMeta,
        ...o
      }
    };
    return await fetch(`${FORMANT_API_URL}/v1/admin/commands`, {
      method: "POST",
      body: JSON.stringify({
        commandTemplateId: u.id,
        organizationId: this.organizationId,
        deviceId: this.id,
        command: u.command,
        parameter: g,
        userId: (d = Authentication.currentUser) == null ? void 0 : d.id
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
  }
  async getCommand(t) {
    return await fetch(`${FORMANT_API_URL}/v1/admin/commands/${t}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
  }
  async createCaptureStream(t) {
    const r = await (await fetch(`${FORMANT_API_URL}/v1/admin/capture-sessions`, {
      method: "POST",
      body: JSON.stringify({
        deviceId: this.id,
        streamName: t,
        tags: {}
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
    return new CaptureStream(r);
  }
  async getTelemetry(t, n, r, o) {
    return await getTelemetry(
      this.id,
      t,
      n,
      r,
      o
    );
  }
  async getTelemetryStreams() {
    var s, g;
    const t = await this.getConfiguration(), n = await fetch(
      `${FORMANT_API_URL}/v1/queries/metadata/stream-names`,
      {
        method: "POST",
        body: JSON.stringify({
          deviceIds: [this.id]
        }),
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    ), r = [], o = [];
    return (g = (s = t.telemetry) == null ? void 0 : s.streams) == null || g.forEach((c) => {
      c.disabled !== !0 && r.push(c.name), c.onDemand === !0 && o.push(c.name);
    }), console.log(o), (await n.json()).items.filter((c) => !r.includes(c)).map((c) => ({ name: c, onDemand: o.includes(c) }));
  }
  async createInterventionRequest(t, n, r, o) {
    return await (await fetch(
      `${FORMANT_API_URL}/v1/admin/intervention-requests`,
      {
        method: "POST",
        body: JSON.stringify({
          message: t,
          interventionType: n,
          time: (/* @__PURE__ */ new Date()).toISOString(),
          deviceId: this.id,
          tags: o,
          data: r
        }),
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json();
  }
  async addInterventionResponse(t, n, r) {
    return await (await fetch(
      `${FORMANT_API_URL}/v1/admin/intervention-responses`,
      {
        method: "POST",
        body: JSON.stringify({
          interventionId: t,
          interventionType: n,
          data: r
        }),
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json();
  }
  async getAnnotationCount(t, n) {
    return await getAnnotationCount({ ...t, deviceIds: [this.id] }, n);
  }
  async getAnnotationCountByIntervals(t, n, r) {
    return await getAnnotationCountByIntervals(
      { ...t, deviceIds: [this.id] },
      n,
      r
    );
  }
  async eventsCounter(t, n, r, o, l) {
    return await eventsCounter(t, n, r, o, {
      ...l,
      deviceIds: [this.id]
    });
  }
  async createShareLink(t, n) {
    return t.scope.deviceIds = [this.id], await createShareLink(t, n);
  }
}
be(Device, "createDevice", createDevice), be(Device, "patchDevice", patchDevice), be(Device, "getDevicesData", getDevicesData), be(Device, "queryDevicesData", queryDevicesData);
class PeerDevice extends BaseDevice {
  constructor(n) {
    super();
    be(this, "id");
    be(this, "telemetryStreamActive", !1);
    be(this, "streamTelemetry", {});
    this.peerUrl = n;
  }
  async getLatestTelemetry() {
    this.telemetryStreamActive || this.subscribeToTelemetry();
    const n = this.streamTelemetry;
    return Object.entries(n).map(([o, l]) => ({
      deviceId: this.id,
      streamName: o,
      streamType: "json",
      currentValue: l,
      currentValueTime: l.timestamp,
      tags: {}
    }));
  }
  subscribeToTelemetry() {
    this.telemetryStreamActive = !0;
    let n = 0;
    const r = new XMLHttpRequest();
    r.responseType = "text", r.addEventListener("error", (o) => {
      this.handleXHRError("error");
    }), r.addEventListener("abort", (o) => {
      this.handleXHRError("abort");
    }), r.addEventListener("timeout", (o) => {
      this.handleXHRError("timeout");
    }), r.addEventListener("readystatechange", (o) => {
      r.readyState === XMLHttpRequest.DONE && this.handleXHRError("closed");
    }), r.addEventListener("progress", (o) => {
      const l = o.loaded, u = l - n;
      n = l, r.responseText.substr(-u).split(`
`).forEach((c) => {
        var d;
        if (c.length > 0) {
          const T = JSON.parse(c);
          if ((d = T.result) != null && d.datapoint) {
            const b = T.result.datapoint, h = b.stream;
            delete b.stream, this.streamTelemetry[h] = b;
          }
        }
      });
    }), r.open("POST", `${this.peerUrl}/v1/telemetry`), r.send();
  }
  handleXHRError(n) {
    console.warn(`Telemetry stream ended: ${n}`), this.telemetryStreamActive = !1;
  }
  async getDeviceId() {
    return (await (await fetch(`${this.peerUrl}/v1/config`)).json()).configuration.id;
  }
  async getConfiguration() {
    return (await (await fetch(`${this.peerUrl}/v1/config`)).json()).configuration.document;
  }
  async startRealtimeConnection(n) {
    if (console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} :: Connection start requested`), this.rtcClient && this.connectionMonitorInterval !== void 0)
      throw new Error(
        `Already created realtime connection to device ${this.id}`
      );
    this.rtcClient && console.warn(
      "overwriting existing rtcClient due to missing connectionMonitorInterval"
    );
    const r = new distExports.RtcClient({
      lanOnlyMode: !0,
      receive: this.handleMessage,
      sessionType: n
    });
    for (await r.connectLan(this.peerUrl); r.getConnectionStatus(this.peerUrl) !== "connected"; )
      await delay(100);
    this.rtcClient = r, this.initConnectionMonitoring();
  }
  initConnectionMonitoring() {
    this.connectionMonitorInterval = setInterval(async () => {
      let n = !1;
      this.rtcClient && this.rtcClient.getConnectionStatus(this.peerUrl) !== "connected" && (console.debug(`${(/* @__PURE__ */ new Date()).toISOString()} :: data channel closed`), n = !0), (!this.rtcClient || n) && (this.emit("disconnect"), this.stopRealtimeConnection().catch((r) => {
        console.error(r);
      }));
    }, 1e3);
  }
  async getRemotePeer() {
    return {
      id: this.peerUrl,
      organizationId: "",
      deviceId: this.id,
      capabilities: [],
      capabilitySet: {}
    };
  }
  async stopRealtimeConnection() {
    let n = !1;
    if (this.rtcClient) {
      this.stopConnectionMonitoring(), this.id ? (await this.rtcClient.disconnect(this.id), this.remoteDevicePeerId = null) : n = !0;
      try {
        await this.rtcClient.shutdown();
      } finally {
        this.rtcClient = void 0;
      }
    }
    if (n)
      throw new Error(`Realtime connection hasn't been started for ${this.id}`);
  }
  async sendCommand(n, r, o, l) {
    const u = {
      value: r,
      scrubberTime: (o || /* @__PURE__ */ new Date()).toISOString(),
      meta: l
    };
    return await fetch(`${this.peerUrl}/v1/enqueue-command`, {
      method: "POST",
      body: JSON.stringify({
        command: n,
        parameter: u
      }),
      headers: {
        "Content-Type": "application/json"
      }
    });
  }
}
async function addDeviceToFleet(e, t) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/devices/${e}`, {
    method: "PATCH",
    body: JSON.stringify({ fleetId: t }),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function aggregateTelemetry(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/queries/queries`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).aggregates;
}
async function deleteFleet(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  await fetch(`${FORMANT_API_URL}/v1/admin/fleets/${e}`, {
    method: "DELETE",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  });
}
async function getAnalyticStreams() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/queries/analytics/streams`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function getAnalyticsModules() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/admin/analytics-modules`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function getAnalyticsRows(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/queries/analytics/rows`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function queryDevices(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/devices/query`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items.map(
    (r) => new Device(r.id, r.name, r.organizationId, r.tags)
  );
}
async function getCurrentGroup() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  let e = new URLSearchParams("");
  typeof window < "u" && window.location && (e = new URLSearchParams(window.location.search));
  const t = e.get("group");
  if (t === null || t.trim() === "")
    return;
  const n = await fetch(
    `${FORMANT_API_URL}/v1/admin/groups/` + t,
    {
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  ), { tagKey: r, tagValue: o } = await n.json();
  return await queryDevices({
    tags: { [r]: [o] },
    enabled: !0,
    type: "default"
  });
}
async function getDevice(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const n = await (await fetch(`${FORMANT_API_URL}/v1/admin/devices/${e}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json(), r = n.name;
  return new Device(e, r, n.organizationId, n.tags);
}
async function getDevices() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const t = await (await fetch(`${FORMANT_API_URL}/v1/admin/device-details/query`, {
    method: "POST",
    body: JSON.stringify({ enabled: !0, type: "default" }),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
  return t.items, t.items.map(
    (n) => new Device(
      n.id,
      n.name,
      n.organizationId,
      n.tags
    )
  );
}
async function getEvent(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/admin/events/query/id=${e}`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function getFileUrl(e) {
  const n = await (await fetch(`${FORMANT_API_URL}/v1/admin/files/query`, {
    method: "POST",
    body: JSON.stringify({
      fileIds: [e]
    }),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
  if (n.fileUrls.length === 0)
    throw new Error("File not found");
  return n.fileUrls[0];
}
async function getFleet(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/fleets/${e}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function getFleetDevices(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/fleets/${e}/devices`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function getInterventions() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/admin/intervention-requests`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function getLatestTelemetry(...e) {
  const t = e.flat().filter((o) => !!o);
  return t.length === 0 ? [] : (await (await fetch(
    `${FORMANT_API_URL}/v1/queries/stream-current-value`,
    {
      method: "POST",
      body: JSON.stringify({
        deviceIds: t
      }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function getOnlineDevices() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const n = (await (await fetch(`${FORMANT_API_URL}/v1/queries/online-devices`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
  return (await getDevices()).filter((o) => n.includes(o.id));
}
async function getRealtimeDevices() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  const n = (await (await fetch(`${FORMANT_API_URL}/v1/signaling/peers`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items.map(
    (o) => o.deviceId
  );
  return (await getDevices()).filter((o) => n.includes(o.id));
}
async function getStreams() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/streams`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items.filter(
    (n) => n.enabled
  );
}
async function getTaskReportRows(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(
    `${FORMANT_API_URL}/v1/queries/analytics/task-report-rows`,
    {
      method: "POST",
      body: JSON.stringify(e),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json();
}
async function getTaskReportTables() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(
    `${FORMANT_API_URL}/v1/queries/analytics/task-reports`,
    {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json()).items;
}
async function listFleets() {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return (await (await fetch(`${FORMANT_API_URL}/v1/admin/fleets`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json()).items;
}
async function patchFleet(e, t) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/fleets/${e}`, {
    method: "PATCH",
    body: JSON.stringify(t),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function patchStream(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(
    `${FORMANT_API_URL}/v1/admin/streams/${e.id}`,
    {
      method: "PATCH",
      body: JSON.stringify(e),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    }
  )).json();
}
async function patchView(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/admin/views/${e.id}`, {
    method: "PATCH",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
async function queryAnalytics(e) {
  if (!Authentication.token)
    throw new Error("Not authenticated");
  return await (await fetch(`${FORMANT_API_URL}/v1/queries/analytics`, {
    method: "POST",
    body: JSON.stringify(e),
    headers: {
      "Content-Type": "application/json",
      Authorization: "Bearer " + Authentication.token
    }
  })).json();
}
const dt = class {
  static async setDefaultDevice(t) {
    dt.defaultDeviceId = t;
  }
  static async getCurrentDevice() {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    if (!dt.defaultDeviceId)
      throw new Error("No known default device");
    const r = (await (await fetch(
      `${FORMANT_API_URL}/v1/admin/device-details/query`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json()).items.find(
      (u) => u.id === dt.defaultDeviceId
    ), o = r.name, l = new Device(
      dt.defaultDeviceId,
      o,
      defined(Authentication.currentOrganization),
      r.tags
    );
    return dt.knownContext.push(new WeakRef(l)), l;
  }
  static async getPeerDevice(t) {
    const n = new PeerDevice(t);
    return n.id = await n.getDeviceId(), n;
  }
  static async getDevice(t) {
    const n = await getDevice(t);
    return dt.knownContext.push(new WeakRef(n)), n;
  }
};
let Fleet = dt;
be(Fleet, "defaultDeviceId"), be(Fleet, "knownContext", []), be(Fleet, "listFleets", listFleets), be(Fleet, "getFleet", getFleet), be(Fleet, "patchFleet", patchFleet), be(Fleet, "deleteFleet", deleteFleet), be(Fleet, "addDeviceToFleet", addDeviceToFleet), be(Fleet, "getFleetDevices", getFleetDevices), be(Fleet, "aggregateTelemetry", aggregateTelemetry), be(Fleet, "createShareLink", createShareLink), be(Fleet, "eventsCounter", eventsCounter), be(Fleet, "getAnalyticStreams", getAnalyticStreams), be(Fleet, "getAnalyticsModules", getAnalyticsModules), be(Fleet, "getAnalyticsRows", getAnalyticsRows), be(Fleet, "getAnnotationCount", getAnnotationCount), be(Fleet, "getAnnotationCountByIntervals", getAnnotationCountByIntervals), be(Fleet, "getCurrentGroup", getCurrentGroup), be(Fleet, "getDevices", getDevices), be(Fleet, "getEvent", getEvent), be(Fleet, "getFileUrl", getFileUrl), be(Fleet, "getInterventions", getInterventions), be(Fleet, "getLatestTelemetry", getLatestTelemetry), be(Fleet, "getOnlineDevices", getOnlineDevices), be(Fleet, "getPeers", getPeers), be(Fleet, "getRealtimeDevices", getRealtimeDevices), be(Fleet, "getRealtimeSessions", getRealtimeSessions), be(Fleet, "getStreams", getStreams), be(Fleet, "getTaskReportRows", getTaskReportRows), be(Fleet, "getTaskReportTables", getTaskReportTables), be(Fleet, "getTelemetry", getTelemetry), be(Fleet, "getViews", getViews), be(Fleet, "patchStream", patchStream), be(Fleet, "patchView", patchView), be(Fleet, "queryAnalytics", queryAnalytics), be(Fleet, "queryDevices", queryDevices), be(Fleet, "queryEvents", queryEvents), be(Fleet, "queryTelemetry", queryTelemetry);
class KeyValue {
  static async set(t, n, r) {
    try {
      const o = await fetch(FORMANT_API_URL + "/v1/admin/key-value", {
        method: "POST",
        body: JSON.stringify({
          organizationId: defined(Authentication.currentUser).organizationId,
          key: t,
          value: n,
          tags: r
        }),
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }), l = await o.json();
      if (o.status !== 200)
        throw new Error(l.message);
    } catch (o) {
      throw o;
    }
  }
  static async get(t) {
    try {
      const n = await fetch(
        FORMANT_API_URL + `/v1/admin/key-value/${t}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + Authentication.token
          }
        }
      ), r = await n.json();
      if (n.status !== 200)
        throw new Error(r.message);
      return r.value;
    } catch (n) {
      throw n;
    }
  }
  static async list() {
    try {
      const t = await fetch(FORMANT_API_URL + "/v1/admin/key-value", {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }), n = await t.json();
      if (t.status !== 200)
        throw new Error(n.message);
      return n.items;
    } catch (t) {
      throw t;
    }
  }
  static async delete(t) {
    try {
      if (!(await fetch(
        FORMANT_API_URL + `/v1/admin/key-value/${t}`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + Authentication.token
          }
        }
      )).ok)
        throw new Error("Unable to handle request");
      return;
    } catch (n) {
      throw n;
    }
  }
}
function stringToArrayBuffer(e) {
  return Uint8Array.from(base64Exports.decode(e), (t) => t.charCodeAt(0));
}
function browser() {
  const { userAgent: e } = navigator;
  return e ? e.includes("Firefox/") ? "Firefox" : e.includes("Edg/") ? "Edge" : e.includes("Chrome/") ? "Chrome" : e.includes("Safari/") ? "Safari" : e.includes("MSIE/") || e.includes("Trident/") ? "IE" : "Other" : "Other";
}
const rtcAudioChunkStreamType = "audio-chunk";
class AudioPlayer {
  constructor(t, n) {
    be(this, "muted", !1);
    be(this, "hasReceivedData", !1);
    be(this, "audioContext");
    be(this, "chunks", []);
    be(this, "isPlaying", !1);
    be(this, "startTime", 0);
    be(this, "lastChunkOffset", 0);
    be(this, "bufferSize", 3);
    be(this, "receive", async (t) => {
      var u;
      const n = (u = t.payload.audioChunk) == null ? void 0 : u.chunk_data;
      if (!n)
        return;
      this.hasReceivedData || (this.hasReceivedData = !0);
      const { audioContext: r, muted: o } = this;
      if (!r || t.header.stream.streamType !== rtcAudioChunkStreamType || o !== !1)
        return;
      const l = stringToArrayBuffer(n);
      try {
        await r.decodeAudioData(
          l.buffer,
          this.scheduleChunk
        );
      } catch (s) {
        console.warn(
          "Error decoding audio buffer, changing audioWireFormat on agent",
          { error: s }
        ), this.changeAudioWireFormat("wav");
      }
    });
    be(this, "scheduleChunk", (t) => {
      const { audioContext: n } = this;
      if (!n)
        return;
      (this.chunks.length > this.bufferSize || this.isPlaying === !1) && (this.chunks.forEach((o) => {
        o.stop();
      }), this.isPlaying = !1, this.chunks = []);
      const r = this.createChunk(t);
      r && r.buffer && (this.isPlaying === !1 && (this.startTime = n.currentTime, this.lastChunkOffset = 0, this.isPlaying = !0), r.start(this.startTime + this.lastChunkOffset, 0, t.duration), this.lastChunkOffset += r.buffer.duration, this.chunks.push(r));
    });
    this.device = t, this.stream = n, this.device.startListeningToRealtimeDataStream(n), this.device.addRealtimeListener((o, l) => {
      this.receive(l);
    }), browser() === "Safari" || browser() === "IE" ? this.changeAudioWireFormat("wav") : this.changeAudioWireFormat("opus");
    const r = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new r();
  }
  async play() {
    var t, n;
    ((t = this.audioContext) == null ? void 0 : t.state) === "suspended" && await ((n = this.audioContext) == null ? void 0 : n.resume()), this.muted = !1;
  }
  async pause() {
    await this.audioContext.suspend(), this.muted = !0;
  }
  destroy() {
    this.device.stopListeningToRealtimeDataStream(this.stream);
  }
  createChunk(t) {
    const { audioContext: n } = this;
    if (!n)
      return;
    const r = n.createBufferSource();
    return r.buffer = t, r.connect(n.destination), r.loop = !1, r.onended = (o) => {
      this.chunks.splice(this.chunks.indexOf(r), 1), this.chunks.length === 0 && (this.isPlaying = !1);
    }, r;
  }
  changeAudioWireFormat(t) {
    const { stream: n } = this;
    (async () => await this.device.changeStreamAudioType(n.name, t))();
  }
}
class Account {
  static async listAccounts() {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return (await (await fetch(`${FORMANT_API_URL}/v1/admin/accounts`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json()).items;
  }
  static async createAccounts(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/accounts`, {
      method: "POST",
      body: JSON.stringify(t),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async getAccount(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/accounts/${t}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async patchAccount(t, n) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/accounts/${t}`, {
      method: "PATCH",
      body: JSON.stringify(n),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async deleteAccount(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    await fetch(`${FORMANT_API_URL}/v1/admin/accounts/${t}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
  }
  static async getAccountTree(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(
      `${FORMANT_API_URL}/v1/admin/accounts/${t}/tree`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer " + Authentication.token
        }
      }
    )).json();
  }
}
class Role {
  static async listRoles() {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return (await (await fetch(`${FORMANT_API_URL}/v1/admin/roles`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json()).items;
  }
  static async createRole(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/roles`, {
      method: "POST",
      body: JSON.stringify(t),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async getRole(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/roles/${t}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async patchRole(t, n) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/roles/${t}`, {
      method: "PATCH",
      body: JSON.stringify(n),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async deleteRole(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    await fetch(`${FORMANT_API_URL}/v1/admin/roles/${t}`, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
  }
}
class User {
  static async listUsers() {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return (await (await fetch(`${FORMANT_API_URL}/v1/admin/users`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json()).items;
  }
  static async createUser(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/users`, {
      method: "POST",
      body: JSON.stringify(t),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async getUser(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/users/${t}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async patchUser(t, n) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    return await (await fetch(`${FORMANT_API_URL}/v1/admin/users/${t}`, {
      method: "PATCH",
      body: JSON.stringify(n),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    })).json();
  }
  static async deleteUser(t) {
    if (!Authentication.token)
      throw new Error("Not authenticated");
    await fetch(`${FORMANT_API_URL}/v1/admin/users/${t}`, {
      method: "PATCH",
      body: JSON.stringify({ enabled: !1, roleId: null, teamId: null }),
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + Authentication.token
      }
    });
  }
}
const accessLevels = ["viewer", "operator", "administrator"], viewer = "viewer", operator = "operator", administrator = "administrator", aggregateLevels = [
  "year",
  "month",
  "week",
  "day",
  "hour",
  "minute"
], annotationTypes = ["tag", "sheet", "user"], eventTypes = [
  "triggered-event",
  "intervention-request",
  "teleop-session-record",
  "port-forwarding-session-record",
  "command-request",
  "command-response",
  "command-delivery",
  "custom",
  "comment",
  "system",
  "annotation"
], healthStatuses = [
  "unknown",
  "operational",
  "offline",
  "error"
], interventionTypes = ["selection", "labeling", "teleop"], severities = ["info", "warning", "error", "critical"], videoMimeTypes = ["video/mp4"];
try {
  const e = typeof window < "u" && window.location ? new URLSearchParams(window.location.search) : new URLSearchParams(""), t = e.get("device");
  t && Fleet.setDefaultDevice(t);
  const n = e.get("auth");
  n && Authentication.loginWithToken(n), e.get("module") && Authentication.listenForRefresh(), typeof window < "u" && App.listenForConnectionEvents();
} catch (e) {
}
export {
  Account,
  App,
  AudioPlayer,
  Authentication,
  BinaryRequestDataChannel,
  CaptureStream,
  DataChannel,
  Device,
  Fleet,
  KeyValue,
  Manipulator,
  PeerDevice,
  Role,
  SessionTypeConstants as SessionType,
  TextRequestDataChannel,
  User,
  accessLevels,
  administrator,
  aggregateByDateFunctions,
  aggregateFunctionMap,
  aggregateFunctions,
  aggregateLevels,
  annotationTypes,
  eventTypes,
  formatTimeFrameText,
  getAverage,
  getCount,
  getMax,
  getMin,
  getStandardDeviation,
  getSum,
  getVariance,
  healthStatuses,
  interventionTypes,
  operator,
  severities,
  vailableAggregationIntervals,
  videoMimeTypes,
  viewer
};
